à¦¤à§à¦®à¦¿ à¦¯à§‡ à¦•à§‹à¦¡à¦Ÿà¦¿ à¦¶à§‡à§Ÿà¦¾à¦° à¦•à¦°à§‡à¦›à§‹, à¦¤à¦¾ à¦¹à¦²à§‹ Linked List à¦ Cycle à¦†à¦›à§‡ à¦•à¦¿à¦¨à¦¾ à¦¤à¦¾ à¦šà§‡à¦• à¦•à¦°à¦¾à¦° à¦à¦•à¦Ÿà¦¿ à¦•à¦¾à¦°à§à¦¯à¦•à¦°à§€ à¦¸à¦®à¦¾à¦§à¦¾à¦¨à¥¤ à¦à¦Ÿà¦¿ Floyd's Tortoise and Hare Algorithm (à¦«à§à¦²à§Ÿà§‡à¦¡à§‡à¦° à¦•à¦šà§à¦›à¦ª à¦“ à¦–à¦°à¦—à§‹à¦¶ à¦…à§à¦¯à¦¾à¦²à¦—à¦°à¦¿à¦¦à¦®) à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦•à¦°à§‡ à¦²à§‡à¦–à¦¾ à¦¹à§Ÿà§‡à¦›à§‡à¥¤


---

ðŸ” à¦¸à¦®à¦¸à§à¦¯à¦¾:

à¦¤à§‹à¦®à¦¾à¦•à§‡ à¦à¦•à¦Ÿà¦¿ à¦¸à¦¿à¦™à§à¦—à¦²à¦¿ à¦²à¦¿à¦™à§à¦•à¦¡ à¦²à¦¿à¦¸à§à¦Ÿ (singly linked list) à¦¦à§‡à¦“à§Ÿà¦¾ à¦¹à§Ÿà§‡à¦›à§‡à¥¤ à¦¦à§‡à¦–à¦¤à§‡ à¦¹à¦¬à§‡ à¦à¦¤à§‡ à¦•à§‹à¦¨à§‹ à¦¸à¦¾à¦‡à¦•à§‡à¦² (à¦šà¦•à§à¦°) à¦†à¦›à§‡ à¦•à¦¿à¦¨à¦¾à¥¤
à¦à¦•à¦Ÿà¦¿ à¦¸à¦¾à¦‡à¦•à§‡à¦² à¦®à¦¾à¦¨à§‡ à¦à¦®à¦¨ à¦à¦•à¦Ÿà¦¿ à¦…à¦‚à¦¶ à¦¯à§‡à¦–à¦¾à¦¨ à¦¥à§‡à¦•à§‡ à¦•à§‹à¦¨à§‹ node à¦†à¦¬à¦¾à¦° à¦¨à¦¿à¦œà§‡à¦•à§‡à¦‡ à¦¬à¦¾ à¦ªà§‚à¦°à§à¦¬à§‡à¦° à¦•à§‹à¦¨à§‹ node-à¦•à§‡ next à¦¦à§à¦¬à¦¾à¦°à¦¾ à¦°à§‡à¦«à¦¾à¦° à¦•à¦°à¦›à§‡à¥¤


---

âœ… à¦…à§à¦¯à¦¾à¦ªà§à¦°à§‹à¦š (Floyd's Algorithm):

ðŸ¢ðŸ‡ à¦§à¦¾à¦ªà¦¸à¦®à§‚à¦¹:

1. à¦¦à§à¦‡à¦Ÿà¦¿ à¦ªà§Ÿà§‡à¦¨à§à¦Ÿà¦¾à¦° à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦•à¦°à§‹:

slow â†’ à¦à¦•à¦¬à¦¾à¦°à§‡ à¦à¦• à¦˜à¦° à¦à¦—à§‹à§Ÿ

fast â†’ à¦à¦•à¦¬à¦¾à¦°à§‡ à¦¦à§à¦‡ à¦˜à¦° à¦à¦—à§‹à§Ÿ



2. à¦²à§à¦ª à¦šà¦¾à¦²à¦¾à¦“ à¦¯à¦¤à¦•à§à¦·à¦£ à¦ªà¦°à§à¦¯à¦¨à§à¦¤ fast à¦à¦¬à¦‚ fast->next à¦†à¦›à§‡:

slow = slow->next

fast = fast->next->next



3. à¦¯à¦¦à¦¿ slow à¦à¦¬à¦‚ fast à¦à¦•à¦‡ node à¦ à¦à¦¸à§‡ à¦ªà§œà§‡:

à¦¤à¦¾à¦¹à¦²à§‡ à¦à¦•à¦Ÿà¦¾ à¦²à§à¦ª (Cycle) à¦†à¦›à§‡

return true



4. à¦¯à¦¦à¦¿ fast à¦¬à¦¾ fast->next null à¦¹à§Ÿà§‡ à¦¯à¦¾à§Ÿ:

à¦¤à¦¾à¦¹à¦²à§‡ à¦•à§‹à¦¨à§‹ à¦²à§à¦ª à¦¨à§‡à¦‡

return false





---

ðŸ§  à¦•à§‡à¦¨ à¦à¦‡ à¦…à§à¦¯à¦¾à¦²à¦—à¦°à¦¿à¦¦à¦® à¦•à¦¾à¦°à§à¦¯à¦•à¦°?

à¦•à¦¾à¦°à¦£ à¦¯à¦¦à¦¿ à¦•à§‹à¦¨à§‹ à¦¸à¦¾à¦‡à¦•à§‡à¦² à¦¥à¦¾à¦•à§‡, à¦¤à¦¾à¦¹à¦²à§‡ fast à¦à¦•à¦¸à¦®à§Ÿ slow-à¦•à§‡ à¦§à¦°à§‡ à¦«à§‡à¦²à¦¬à§‡à¦‡à¥¤

à¦à¦•à§‡ à¦¬à¦²à§‡ Floydâ€™s Cycle Detection Algorithm à¦¬à¦¾ Tortoise and Hare techniqueà¥¤



---

â±ï¸ Time & Space Complexity:

à¦¦à¦¿à¦•	à¦¬à¦¿à¦¶à§à¦²à§‡à¦·à¦£

âŒ› Time Complexity	O(n) â†’ Worst case à¦²à¦¿à¦¸à§à¦Ÿà§‡à¦° à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ node-à¦¤à§‡ à¦à¦•à¦¬à¦¾à¦° traversal
ðŸ§  Space Complexity	O(1) â†’ à¦à¦•à§à¦¸à¦Ÿà§à¦°à¦¾ à¦®à§‡à¦®à¦°à¦¿ à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦•à¦°à¦¾ à¦¹à§Ÿà¦¨à¦¿



---

âœ… Accepted à¦•à¦¾à¦°à¦£:

à¦•à§‹à¦¨à¦“ à¦à¦•à§à¦¸à¦Ÿà§à¦°à¦¾ à¦¸à§à¦Ÿà§‹à¦°à§‡à¦œ à¦²à¦¾à¦—à§‡ à¦¨à¦¾

à¦Ÿà§‡à¦¸à§à¦Ÿ à¦•à§‡à¦¸à§‡ à¦¸à¦ à¦¿à¦•à¦­à¦¾à¦¬à§‡ cycle à¦¥à¦¾à¦•à¦²à§‡ true à¦“ à¦¨à¦¾ à¦¥à¦¾à¦•à¦²à§‡ false à¦¦à§‡à§Ÿ



---

ðŸ§ª à¦‰à¦¦à¦¾à¦¹à¦°à¦£ à¦¦à¦¿à§Ÿà§‡ à¦¬à§à¦¯à¦¾à¦–à§à¦¯à¦¾:

Input:

head = [3,2,0,-4]  
pos = 1 â†’ -4 points to node with value 2

Visual:

3 â†’ 2 â†’ 0 â†’ -4
     â†‘       â†“
     â†â†â†â†â†â†â†â†

Execution:

à¦¶à§à¦°à§à¦¤à§‡ slow = 3, fast = 3

à§§à¦® à¦§à¦¾à¦ªà§‡:
slow = 2, fast = 0

à§¨à§Ÿ à¦§à¦¾à¦ªà§‡:
slow = 0, fast = 2

à§©à§Ÿ à¦§à¦¾à¦ªà§‡:
slow = -4, fast = -4

à¦¦à§à¦œà¦¨ à¦®à¦¿à¦²à§‡ à¦—à§‡à¦›à§‡ â†’ return true



---

ðŸ” à¦…à¦¨à§à¦¯ à¦‰à¦ªà¦¾à§Ÿ (à¦¤à§à¦²à¦¨à¦¾à¦®à§‚à¦²à¦•):

HashSet à¦¦à¦¿à§Ÿà§‡ à¦†à¦—à§‡à¦° à¦­à¦¿à¦œà¦¿à¦Ÿ à¦•à¦°à¦¾ node à¦—à§à¦²à§‹ à¦°à¦¾à¦–à¦²à§‡ O(n) à¦¸à§à¦ªà§‡à¦¸ à¦²à¦¾à¦—à¦¤à§‹à¥¤

à¦•à¦¿à¦¨à§à¦¤à§ à¦à¦‡ à¦•à§‹à¦¡à§‡ O(1) à¦¸à§à¦ªà§‡à¦¸à§‡ à¦¸à¦®à¦¾à¦§à¦¾à¦¨ à¦•à¦°à¦¾ à¦¹à§Ÿà§‡à¦›à§‡à¥¤



---

ðŸ”š à¦‰à¦ªà¦¸à¦‚à¦¹à¦¾à¦°:

à¦à¦‡ à¦•à§‹à¦¡à¦Ÿà¦¿ Floyd's Cycle Detection Algorithm à¦­à¦¿à¦¤à§à¦¤à¦¿à¦•à¥¤
à¦à¦Ÿà¦¿ à¦¦à§à¦°à§à¦¤, à¦•à¦¾à¦°à§à¦¯à¦•à¦° à¦à¦¬à¦‚ à¦®à§‡à¦®à¦°à¦¿ à¦¸à¦¾à¦¶à§à¦°à§Ÿà§€ à¦‰à¦ªà¦¾à§Ÿà§‡ linked list-à¦ cycle à¦šà§‡à¦• à¦•à¦°à¦¤à§‡ à¦¸à¦•à§à¦·à¦®à¥¤


---

ðŸ“Œ à¦®à¦¨à§‡ à¦°à¦¾à¦–à¦¾à¦° à¦¨à¦¿à§Ÿà¦®:

> "ðŸ¢ à¦à¦•à¦˜à¦°à§‡, ðŸ‡ à¦¦à§'à¦˜à¦°à§‡ â†’ à¦¦à§‡à¦–à¦¾ à¦¹à¦²à§‡, à¦²à§à¦ª à¦§à¦°à¦¾ à¦ªà§œà§‡!"




---

à¦ªà§à¦°à§Ÿà§‹à¦œà¦¨à§‡ à¦†à¦®à¦¿ à¦à¦‡ à¦•à§‹à¦¡à§‡à¦° step-by-step dry run, visualization à¦…à¦¥à¦¬à¦¾ HashSet approach-à¦à¦° comparison-à¦“ à¦¦à§‡à¦–à¦¾à¦¤à§‡ à¦ªà¦¾à¦°à¦¿à¥¤ à¦šà¦¾à¦‡à¦²à§‡ à¦¬à¦²à§‹à¥¤

Full Code:
------------
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* slow=head;
        ListNode* fast=head;
        bool cycle=false;
        while(fast&&fast->next)
            {
                slow=slow->next;
                fast=fast->next->next;
                if(slow==fast)
                {
                    cycle=true;
                    break;
                }
            }
        return cycle;
    }
};
