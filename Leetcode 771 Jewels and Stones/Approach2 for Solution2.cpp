সমস্যার বিশ্লেষণ
তোমাকে দুটি স্ট্রিং দেওয়া হবে:

jewels: যে ধরনের পাথরগুলি "গহনা" (jewels) হিসেবে গণ্য হয়, এবং

stones: যে পাথরগুলি তোমার কাছে রয়েছে।

তোমার লক্ষ্য হল, তুমি কতটি পাথর পেয়ে গেছো যা "গহনা" হিসেবে গণ্য হয়, তা বের করা। এখানে গহনা ও পাথরের মধ্যে বড়-ছোট অক্ষরের পার্থক্য থাকবে, অর্থাৎ "a" এবং "A" আলাদা হবে।

উদাহরণ:
উদাহরণ 1:

jewels = "aA"

stones = "aAAbbbb"

এখানে, "a" এবং "A" গহনা হিসেবে আছে, এবং "a", "A" দুটোই stones-এ পাওয়া যাচ্ছে, মোট ৩টি পাথর গহনার মধ্যে পড়ে।

উদাহরণ 2:

jewels = "z"

stones = "ZZ"

এখানে, "z" গহনা হিসাবে আছে, কিন্তু "stones" এ কোনো "z" নেই, ফলে উত্তর হবে ০।

কোড বিশ্লেষণ:
cpp
Copy
Edit
unordered_map<int, int> freq;
for (int i = 0; i < stones.size(); i++) {
    freq[stones[i]]++;  // Frequency map তৈরি করছি
}

vector<int> ans;
for (auto it : freq) {
    if (it.second > 1) {  // যদি কোনো সংখ্যার frequency 1 এর বেশি থাকে, তা হলে তা ডুপ্লিকেট
        ans.push_back(it.first);
    }
}
return ans;
ধাপে ধাপে বিশ্লেষণ (Bangla Test):
unordered_map<int, int> freq;

এখানে আমরা একটি unordered_map তৈরি করছি যার মাধ্যমে পাথরের ধরনের frequency হিসাব করা হবে। এর প্রথম অংশ হল পাথরের চরিত্র এবং দ্বিতীয় অংশ হল তার কতবার ঘটেছে।

for (int i = 0; i < stones.size(); i++) { freq[stones[i]]++; }

এই লুপটি stones স্ট্রিং এর প্রতিটি উপাদানকে চেক করবে এবং সেই অনুযায়ী freq মাপে তার frequency বাড়াবে। অর্থাৎ, যদি stones[i] পাওয়া যায়, তাহলে তার মান ১ বাড়ানো হবে।

যেমন: যদি stones = "aAAbbbb", তাহলে freq হবে:

cpp
Copy
Edit
freq = {
  {'a': 1},
  {'A': 2},
  {'b': 4}
}
vector<int> ans;

এখানে আমরা একটি ans ভেক্টর তৈরি করছি, যাতে আমরা ডুপ্লিকেট পাথরের সংখ্যা সংগ্রহ করব।

for (auto it : freq) { if (it.second > 1) { ans.push_back(it.first); } }

এই লুপে, আমরা freq মাপের প্রতিটি উপাদান চেক করছি। যদি কোনো পাথরের frequency ১ এর বেশি থাকে, তাহলে সেটি ans ভেক্টরে যোগ করা হবে।

যেমন: freq = {'a': 1, 'A': 2, 'b': 4}

এখানে, "A" এবং "b" frequency 1 এর বেশি, তাই "A" এবং "b" ans ভেক্টরে যোগ হবে।

return ans;

শেষে, ans ভেক্টরটি রিটার্ন করা হবে, যাতে কেবলমাত্র সেই পাথরগুলি থাকবে যেগুলি গহনা হিসাবে গণ্য হয়।

উত্তর কোডের ব্যাখ্যা (যথাযথ কোড):
cpp
Copy
Edit
unordered_map<char, int> freq;
int count = 0;

// স্টোনের প্রতিটি উপাদান গুনো মাপ
for (int i = 0; i < stones.size(); i++) {
    freq[stones[i]]++;  // Frequency কাউন্ট
}

// গহনার প্রতিটি চরিত্র চেক করে, যদি সেটা স্টোনের মধ্যে থাকে
for (char ch : jewels) {
    count += freq[ch];  // গহনার পাথরের সংখ্যা যোগ করা
}
return count;
ধাপে ধাপে ব্যাখ্যা:
unordered_map<char, int> freq;

freq মানচিত্রে আমরা পাথরের সংখ্যা গুনছি।

for (int i = 0; i < stones.size(); i++) { freq[stones[i]]++; }

এখানে, আমরা stones স্ট্রিংয়ে প্রতিটি পাথরের জন্য তার frequency গুনছি।

for (char ch : jewels) { count += freq[ch]; }

jewels স্ট্রিংয়ের প্রতিটি চরিত্রের জন্য, আমরা চেক করছি যদি freq মানচিত্রে তার কোনো মান থাকে। যদি থাকে, তাহলে count তে সেই মান যোগ করা হচ্ছে। অর্থাৎ, যেই পাথরগুলো গহনা হিসাবে গণ্য হয়, তার সংখ্যা বের করা হচ্ছে।

return count;

শেষে, মোট সংখ্যা ফিরিয়ে দেওয়া হচ্ছে, যা গহনা হিসাবে গণ্য পাথরের সংখ্যা।

উদাহরণ অনুসারে:
উদাহরণ 1:

jewels = "aA"

stones = "aAAbbbb"

এখানে:

freq হবে: {'a': 1, 'A': 2, 'b': 4}

গহনা পাথর "a" এবং "A" আছে, "a" এর সংখ্যা 1, "A" এর সংখ্যা 2, ফলে মোট গহনা পাথর সংখ্যা হবে 3।

উদাহরণ 2:

jewels = "z"

stones = "ZZ"

এখানে:

freq হবে: {'Z': 2}

গহনা পাথর "z" নেই, ফলে উত্তর হবে 0।

Time Complexity:
প্রথম লুপে stones স্ট্রিংয়ের প্রতিটি চরিত্র চেক করা হচ্ছে, যা O(n) সময় নিবে, যেখানে n হল stones.size()।

দ্বিতীয় লুপে jewels স্ট্রিংয়ের প্রতিটি চরিত্র চেক করা হচ্ছে, যা O(m) সময় নিবে, যেখানে m হল jewels.size()।

মোট কমপ্লেক্সিটি হবে O(n + m), যেখানে n হলো stones এর সাইজ এবং m হলো jewels এর সাইজ।

Space Complexity:
unordered_map ব্যবহার হচ্ছে, যা সর্বাধিক O(n) জায়গা নিবে, যেখানে n হল stones এর সাইজ।

উপসংহার: এই পদ্ধতি efficient এবং optimized, এবং এটি সমস্যাটি O(n + m) টাইম কমপ্লেক্সিটিতে সমাধান করতে সক্ষম।








