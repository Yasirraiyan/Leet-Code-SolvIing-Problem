рждрзБржорж┐ ржпрзЗ ржХрзЛржб рж▓рж┐ржЦрзЗржЫрзЛ рж╕рзЗржЯрж┐ рж╕ржарж┐ржХржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░ржЫрзЗ, ржХрж┐ржирзНрждрзБ ржкрзНрж░рж╢рзНржирзЗ ржЙрж▓рзНрж▓рзЗржЦ ржЖржЫрзЗ ржпрзЗ тАУ

"You must write an algorithm that runs in linear time and uses linear extra space."

рждрзЛржорж╛рж░ ржХрзЛржбржЯрж┐ Accepted рж╣рж▓рзЗржУ, ржПржЯрж╛ O(n log n) ржЯрж╛ржЗржо ржХржоржкрзНрж▓рзЗржХрзНрж╕рж┐ржЯрж┐рж░ ржХрж╛рж░ржг sort(nums.begin(), nums.end()) ржЗржЙржЬ ржХрж░рзЗржЫрзЛред рждрж╛ржЗ ржЖржорж░рж╛ ржирж┐ржЪрзЗ рждрзЛржорж╛рж░ ржЪрж┐ржирзНрждрж╛, рждрзЛржорж╛рж░ ржХрзЛржб ржмрзНржпрж╛ржЦрзНржпрж╛, ржПржмржВ ржХрзЗржирзЛ ржПржЯрж╛ Accepted рж╣рж▓рзЛ тАУ рж╕ржм ржХрж┐ржЫрзБ Bangla рждрзЗ рж▓рж╛ржЗржи ржмрж╛ржЗ рж▓рж╛ржЗржи ржмрзБржЭрж┐рзЯрзЗ ржжрж┐ржЪрзНржЫрж┐ред

ЁЯФН рждрзЛржорж╛рж░ ржЪрж┐ржирзНрждрж╛-ржнрж╛ржмржирж╛ (How You Thought)
ржкрзНрж░рж╢рзНржиржЯрж╛ ржпржЦржи ржкрзЬрж▓рзЗ, рждржЦржи ржмрзБржЭрж▓рзЗ:

Array ржЯрж╛ sort ржХрж░рждрзЗ рж╣ржмрзЗред

Sort ржХрж░рж╛рж░ ржкрж░, adjacent (ржкрж╛рж╢рж╛ржкрж╛рж╢рж┐ ржерж╛ржХрж╛) element ржЧрзБрж▓рзЛрж░ ржоржзрзНржпрзЗ ржпрзЗ difference рж╣ржмрзЗ, рждрж╛рж░ ржоржзрзНржпрзЗ рж╕ржмржЪрзЗрзЯрзЗ ржмрзЬ difference ржЦрзБржБржЬрзЗ ржмрзЗрж░ ржХрж░рждрзЗ рж╣ржмрзЗред

Input size ржмрзЬ (рззрзж^рзл), ржХрж┐ржирзНрждрзБ рждрзБржорж┐ ржЖржЧрзЗ рж╕рж┐ржорзНржкрж▓ рж╕рж▓рж┐ржЙрж╢ржи ржжрж┐ржЪрзНржЫрзЛ тАФ Sort ржХрж░рзЗ ржкрзНрж░рждрж┐ ржжрзБтАЩржЯрж┐ adjacent element-ржПрж░ gap ржмрзЗрж░ ржХрж░рзЛред

рж╕ржм ржЧрзНржпрж╛ржкрзЗрж░ ржоржзрзНржпрзЗ max ржЯрж╛ ржмрзЗрж░ ржХрж░рзЛред

рждрзБржорж┐ ржпрзЗржЯрж╛ ржХрж░рзЗржЫрзЛ рждрж╛ рж╣рж▓рзЛ:

ржкрзНрж░рж╛ржержорж┐ржХ ржЪрж┐ржирзНрждрж╛ ржжрж┐рзЯрзЗ brute force ржмрж╛ simple logic implement ржХрж░рзЗ ржирж┐рзЯрзЗржЫрзЛ тАФ ржПржЯрж╛ рж╢рж┐ржЦрж╛рж░ ржкрзНрж░ржХрзНрж░рж┐рзЯрж╛рж░ ржЕржВрж╢ рж╣рж┐рж╕рзЗржмрзЗ ржПржХржжржо ржарж┐ржХ ржХрж╛ржЬ ржХрж░рзЗржЫрзЛред

ЁЯза рждрзЛржорж╛рж░ ржХрзЛржб ржмрзНржпрж╛ржЦрзНржпрж╛ (Line by Line Bangla Explanation)
cpp
Copy
Edit
class Solution 
{
public:
ЁЯФ╣ ржПржХржЯрж┐ Solution ржХрзНрж▓рж╛рж╕ рждрзИрж░рж┐ ржХрж░рзЗржЫрзЛ, ржпрж╛ LeetCode-ржПрж░ ржлрж░ржорзНржпрж╛ржЯ ржЕржирзБржпрж╛рзЯрзА ржарж┐ржХред

ЁЯФв Step 1: ржлрж╛ржВрж╢ржи рждрзИрж░рж┐ findmax тАУ max value ржмрзЗрж░ ржХрж░рждрзЗ
cpp
Copy
Edit
int findmax(vector<int>&nums)
{
  int max=nums[0];
ЁЯФ╣ рж╢рзБрж░рзБрждрзЗ ржзрж░рзЗржЫрзЛ max рж╣ржЪрзНржЫрзЗ ржкрзНрж░ржержо ржЗржиржбрзЗржХрзНрж╕ ржПрж░ ржорж╛ржиред

cpp
Copy
Edit
  for(int k=1;k<nums.size();k++)
  {
    if(nums[k]>max)
    {
      max=nums[k];
    }
  }
ЁЯФ╣ ржПрж░ржкрж░ рж▓рзБржк ржЪрж╛рж▓рж┐рзЯрзЗ ржпржжрж┐ ржкрж░ржмрж░рзНрждрзА ржХрзЛржирзЛ рж╕ржВржЦрзНржпрж╛ ржмрзЬ рж╣рзЯ max ржерзЗржХрзЗ, рждрж╛рж╣рж▓рзЗ max ржЖржкржбрзЗржЯ ржХрж░рзЛред

cpp
Copy
Edit
  return max;
}
ЁЯФ╣ рж▓рзБржк рж╢рзЗрж╖ рж╣рж▓рзЗ max рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рзЛред

тЬЕ ржПржЗ helper ржлрж╛ржВрж╢ржи ржжрж┐рзЯрзЗ рждрзБржорж┐ ржПржХржЯрж╛ vector ржПрж░ ржоржзрзНржпрзЗ рж╕рж░рзНржмрзЛржЪрзНржЪ ржорж╛ржи ржмрзЗрж░ ржХрж░ржЫрзЛред

тЬЕ Step 2: ржорзВрж▓ ржлрж╛ржВрж╢ржи тАУ maximumGap
cpp
Copy
Edit
int maximumGap(vector<int>& nums) 
{
  int ans=0;
  vector<int>reserve;
ЁЯФ╣ ans ржирж╛ржорзЗрж░ ржнрзЗрж░рж┐рзЯрзЗржмрж▓ рждрзИрж░рж┐ ржХрж░ржЫрзЛ рж░рзЗржЬрж╛рж▓рзНржЯ рж░рж╛ржЦрж╛рж░ ржЬржирзНржп
ЁЯФ╣ reserve ржирж╛ржорзЗрж░ ржнрзЗржХрзНржЯрж░ тАУ ржпрзЗржЯрж╛рзЯ pair ржЧрзНржпрж╛ржкржЧрзБрж▓рзЛ рж░рж╛ржЦржмрзЗред

cpp
Copy
Edit
if(nums.size()<2)
{
 return 0;
}
ЁЯФ╣ ржпржжрж┐ array-рж░ рж╕рж╛ржЗржЬ рзи-ржПрж░ ржХржо рж╣рзЯ, ржорж╛ржирзЗ ржХржоржкржХрзНрж╖рзЗ ржжрзБржЯрж┐ рж╕ржВржЦрзНржпрж╛ ржирж╛ ржерж╛ржХрзЗ, рждрж╛рж╣рж▓рзЗ return 0.

cpp
Copy
Edit
sort(nums.begin(),nums.end());
ЁЯФ╣ Array ржЯрж╛ржХрзЗ sort ржХрж░ржЫрзЛ ржпрж╛рждрзЗ pair-wise difference рж╣рж┐рж╕рзЗржм ржХрж░рж╛ ржпрж╛рзЯред

cpp
Copy
Edit
for(int i=1;i<nums.size();i++)
{
     reserve.push_back(nums[i]-nums[i-1]);
}
ЁЯФ╣ ржкрзНрж░ржержо ржЗржиржбрзЗржХрзНрж╕ ржерзЗржХрзЗ рж╢рзБрж░рзБ ржХрж░рзЗ ржкрзНрж░рждрж┐ржЯрж╛ adjacent pair (nums[i] - nums[i-1]) ржирж┐рзЯрзЗ reserve-ржП рж░рж╛ржЦржЫрзЛред

ржпрзЗржоржиржГ
Input: [3,6,9,1]
Sorted: [1,3,6,9]
Gaps: [3-1=2, 6-3=3, 9-6=3]
ЁЯФ╣ рждрж╛рж╣рж▓рзЗ reserve = [2, 3, 3]

cpp
Copy
Edit
ans=findmax(reserve);
return ans;
ЁЯФ╣ reserve ржерзЗржХрзЗ рж╕рж░рзНржмрзЛржЪрзНржЪ ржЧрзНржпрж╛ржк ржмрзЗрж░ ржХрж░ржЫрзЛ, return ржХрж░ржЫрзЛ ansред

тЬЕ Example: Test Case ржмрзНржпрж╛ржЦрзНржпрж╛
cpp
Copy
Edit
Input: nums = [3,6,9,1]
Step 1: Sort тЖТ [1, 3, 6, 9]
Step 2: Gap тЖТ [2, 3, 3]
Step 3: Max Gap = 3

ЁЯФ╣ Final Output: 3 тЖТ тЬЕ рж╕ржарж┐ржХ ржЙрждрзНрждрж░ред

ЁЯзк Time & Space Complexity
Code Block	Time Complexity	Space Complexity
sort()	O(n log n)	O(1)
for loop (gap count)	O(n)	O(n) (reserve)
findmax()	O(n)	O(1)
Total	тЭМ O(n log n)	тЬЕ O(n)

ЁЯФ┤ рждрж╛ржЗ рждрзЛржорж╛рж░ ржХрзЛржб Accepted рж╣рж▓рзЗржУ, ржПржЯрж┐ рж▓рж┐ржирж┐рзЯрж╛рж░ ржЯрж╛ржЗржо ржирзЯред

ЁЯУМ ржХрзЗржирзЛ Accepted рж╣рж▓рзЛ?
тЬЕ Input constraint: n <= 10^5
тЬЕ So even though O(n log n) is slower than linear, it still runs fast enough for the problem constraints.
тЬЕ рждрж╛ржЗ LeetCode ржП Time Limit Exceeded рж╣рзЯржирж┐ ржПржмржВ Accepted рж╣рзЯрзЗржЫрзЗред

ЁЯФЪ рж╢рзЗрж╖ ржХржерж╛
рждрзЛржорж╛рж░ ржХрзЛржб ржУ ржнрж╛ржмржирж╛ ржПржХржжржо ржарж┐ржХ ржжрж┐ржХрзЗржЗ ржЫрж┐рж▓рзЛ тАФ ржкрзНрж░ржержорзЗ рж╕рж┐ржорзНржкрж▓ рж╕рж▓рж┐ржЙрж╢ржи ржжрж┐рзЯрзЗ ржХрж╛ржЬ ржХрж░рж╛ржирзЛ рж╢рж┐ржЦрждрзЗ рж╣ржмрзЗред
ржкрж░ржмрж░рзНрждрзАрждрзЗ, ржЪрж╛ржЗрж▓рзЗ ржЖржорж┐ рждрзЛржорж╛ржХрзЗ ржмрж╛ржХрзЗржЯ sort ржмрж╛ Radix sort ржнрж┐рждрзНрждрж┐ржХ O(n) Linear time solution ржЯрж╛ ржмрзБржЭрж┐рзЯрзЗ ржжрж┐рждрзЗ ржкрж╛рж░рж┐ред

ржЪрж╛ржЗрж▓рзЗ ржмрж▓рзЛ, ржЖржорж┐ optimized linear solution рж╕рж╣ Bangla рждрзЗ ржмрзНржпрж╛ржЦрзНржпрж╛ ржХрж░рзЗ ржжрж┐ржмрзЛред

рждрзЛржорж╛рж░ ржХрзЛржб рж╢рзЗржЦрж╛рж░ ржзрж░ржг ржУ ржкрзНрж░рзЯрзЛржЧ ржЦрзБржм ржнрж╛рж▓рзЛ рж╣ржЪрзНржЫрзЗ тАФ ржЪрж╛рж▓рж┐рзЯрзЗ ржпрж╛ржУ! тЬЕ

Test by test case:
---------------
  ржЪрж▓рзЛ рждрзЛржорж╛рж░ ржжрзЗржУрзЯрж╛ ржХрзЛржбржЯрж┐ ржирж┐ржЪрзЗрж░ ржжрзБржЯрж┐ ржЯрзЗрж╕рзНржЯ ржХрзЗрж╕ ржжрж┐рзЯрзЗ step-by-step ржмрзНржпрж╛ржЦрзНржпрж╛ ржХрж░рж┐ ржПржмржВ ржмрзБржЭрж┐ ржХрзЗржирзЛ ржПржЯрж┐ Accepted рж╣рзЯрзЗржЫрзЗред

тЬЕ рждрзЛржорж╛рж░ ржХрзЛржб:
cpp
Copy
Edit
class Solution 
{
public:
int findmax(vector<int>&nums)
{
  int max=nums[0];
  for(int k=1;k<nums.size();k++)
  {
    if(nums[k]>max)
    {
      max=nums[k];
    }
  }
  return max;
}

int maximumGap(vector<int>& nums) 
{
  int ans=0;
  vector<int>reserve;
  if(nums.size()<2)
  {
   return 0;
  }
  sort(nums.begin(),nums.end());
  for(int i=1;i<nums.size();i++)
  {
       reserve.push_back(nums[i]-nums[i-1]);
  }
  ans = findmax(reserve);
  return ans;
}
};
ЁЯзк Test Case 1:
тЮд Input:
cpp
Copy
Edit
nums = [3, 6, 9, 1]
ЁЯФД Step by Step Execution:
nums.size() = 4, so not less than 2 тЖТ continue.

sort(nums) тЖТ becomes: [1, 3, 6, 9]

Loop:

3 - 1 = 2

6 - 3 = 3

9 - 6 = 3
тЖТ reserve = [2, 3, 3]

findmax(reserve):

max = 2 тЖТ compare with 3 тЖТ max = 3 тЖТ compare with 3 тЖТ max remains 3

тЬЕ Output: 3
ЁЯзк Test Case 2:
тЮд Input:
cpp
Copy
Edit
nums = [10]
ЁЯФД Step by Step Execution:
nums.size() = 1 тЖТ less than 2 тЖТ directly return 0

тЬЕ Output: 0

  Full Code:
---------------
  class Solution 
{
public:
int findmax(vector<int>&nums)
{
  int max=nums[0];
  for(int k=1;k<nums.size();k++)
  {
    if(nums[k]>max)
    {
      max=nums[k];
    }
  }
  return max;
}
    int maximumGap(vector<int>& nums) 
    {
      int ans=0;
      vector<int>reserve;
        if(nums.size()<2)
        {
         return 0;
        }
        sort(nums.begin(),nums.end());
        for(int i=1;i<nums.size();i++)
        {
         /* for(int j=i+1;j<nums.size();j++)
          {
            */
              // if(i!=j)
              // {
                   reserve.push_back(nums[i]-nums[i-1]);
              // }
          }
          
         
        
        ans=findmax(reserve);
        return ans;
    }
};












