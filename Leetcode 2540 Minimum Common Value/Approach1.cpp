ЁЯФН ржкрзНрж░рж╢рзНржиржЯрж┐ ржмрзБржЭрзЗ рж╕ржорж╛ржзрж╛ржирзЗрж░ ржзрж╛рж░ржгрж╛ ржХрж┐ржнрж╛ржмрзЗ ржмрж╛ржирж╛рждрзЗ рж╣рзЯ:
ржкрзНрж░рж╢рзНржиржЯрж┐ ржмрж▓ржЫрзЗ:

ржжрзБржЗржЯрж┐ ржЗржиржкрзБржЯ ржЕрзНржпрж╛рж░рзЗ nums1 ржПржмржВ nums2 ржжрзЗрзЯрж╛ ржЖржЫрзЗ тАФ ржжрзБржЗржЯрж┐ржЗ sorted in non-decreasing order (ржорж╛ржирзЗ ржмрж╛рзЬрждрзЗ ржерж╛ржХрж╛ ржХрзНрж░ржорзЗ рж╕рж╛ржЬрж╛ржирзЛ)ред
ржЖржорж╛ржжрзЗрж░ ржПржоржи рж╕рж░рзНржмржирж┐ржорзНржи рж╕ржВржЦрзНржпрж╛ржЯрж┐ ржмрзЗрж░ ржХрж░рждрзЗ рж╣ржмрзЗ, ржпрзЗржЯрж┐ ржЙржнрзЯ ржЕрзНржпрж╛рж░рзЗрждрзЗ ржХржоржи ржЖржЫрзЗред
ржпржжрж┐ ржХрзЛржи ржХржоржи рж╕ржВржЦрзНржпрж╛ ржирж╛ ржерж╛ржХрзЗ тАФ return -1.

тЬЕ рж╕ржорж╛ржзрж╛ржирзЗрж░ ржзрж╛ржк ржУ рж▓ржЬрж┐ржХ (Approach in Bangla):
ржЖржорж░рж╛ ржпрзЗрж╣рзЗрждрзБ ржжрзБржЗржЯрж┐ sorted ржЕрзНржпрж╛рж░рзЗ ржкрзЗрзЯрзЗржЫрж┐, рждрж╛ржЗ efficient рж╕ржорж╛ржзрж╛ржи ржЪрж╛ржУрзЯрж╛рж░ рж╕ржмржЪрзЗрзЯрзЗ ржнрж╛рж▓рзЛ ржЙржкрж╛рзЯ рж╣рж▓ тАФ
ЁЯСЙ ржПржХржЯрж┐ ржЕрзНржпрж╛рж░рзЗржХрзЗ hash/set ржХрж░рзЗ ржлрзЗрж▓рж┐, ржЖрж░рзЗржХржЯрж╛рждрзЗ ржЧрж┐рзЯрзЗ ржжрзЗржЦрж┐ ржХрзЛржи ржХржоржи ржПрж▓рж┐ржорзЗржирзНржЯ ржЖржЫрзЗ ржХрж┐ржирж╛ред

рждрзБржорж┐ ржарж┐ржХ рждрж╛ржЗ ржХрж░рзЗржЫрзЛ:

тЦ╢я╕П Step-by-step:
ЁЯФ╣ Step 1: nums1 ржХрзЗ unordered_set ржП рж░рзВржкрж╛ржирзНрждрж░ ржХрж░рзЛ
cpp
Copy
Edit
unordered_set<int> set1;
for(int i = 0; i < nums1.size(); i++) {
    set1.insert(nums1[i]);
}
ЁЯСЙ ржПрждрзЗ nums1 ржПрж░ рж╕ржм ржПрж▓рж┐ржорзЗржирзНржЯ O(1) ржЯрж╛ржЗржорзЗ ржЦрзЛржБржЬрж╛ ржпрж╛ржмрзЗред

ЁЯФ╣ Step 2: nums2 рждрзЗ рж▓рзБржк ржЪрж╛рж▓рж┐рзЯрзЗ ржжрзЗржЦрж┐ ржХрзЛржи ржПрж▓рж┐ржорзЗржирзНржЯ set1-ржП ржЖржЫрзЗ ржХрж┐ржирж╛
cpp
Copy
Edit
vector<int> v;
for(int j = 0; j < nums2.size(); j++) {
    if(set1.find(nums2[j]) != set1.end()) {
        v.push_back(nums2[j]);  // ржХржоржи рж╣рж▓рзЗ ржпрзЛржЧ ржХрж░рж┐
    }
}
ЁЯФ╣ Step 3: ржпржжрж┐ v ржлрж╛ржБржХрж╛ рж╣рзЯ, return -1, ржирж╛рж╣рж▓рзЗ v ржерзЗржХрзЗ ржорж┐ржирж┐ржорж╛ржо ржмрзЗрж░ ржХрж░рж┐
cpp
Copy
Edit
if(v.empty()) return -1;
ans = findmin(v);
return ans;
ЁЯФ╣ Helper function: findmin()
cpp
Copy
Edit
int findmin(vector<int>& v) {
    int min = v[0];
    for(int k = 1; k < v.size(); k++) {
        if(v[k] < min) {
            min = v[k];
        }
    }
    return min;
}
ЁЯзк Test Case ржжрж┐рзЯрзЗ ржмрзНржпрж╛ржЦрзНржпрж╛:
Test Case 1:
cpp
Copy
Edit
nums1 = [1, 2, 3], nums2 = [2, 4]
Step 1:
set1 = {1, 2, 3}

Step 2:
nums2 ржПрж░ 2 тЖТ set1 ржП ржЖржЫрзЗ тЖТ v = [2]
nums2 ржПрж░ 4 тЖТ ржирзЗржЗ

Step 3:
v = [2], findmin(v) = 2 тЖТ return 2

тЬЕ Output: 2

Test Case 2:
cpp
Copy
Edit
nums1 = [1, 2, 3, 6], nums2 = [2, 3, 4, 5]
Step 1:
set1 = {1, 2, 3, 6}

Step 2:
nums2 ржПрж░ 2 тЖТ ржЖржЫрзЗ тЖТ v = [2]
nums2 ржПрж░ 3 тЖТ ржЖржЫрзЗ тЖТ v = [2, 3]
nums2 ржПрж░ 4, 5 тЖТ ржирзЗржЗ

Step 3:
v = [2, 3], findmin = 2 тЖТ return 2

тЬЕ Output: 2

тЪЩя╕П ржХрзЛржб ржЖрж░ржУ Efficient ржХрж░рж╛ ржпрж╛рзЯ?
рждрзБржорж┐ set ржжрж┐рзЯрзЗ O(n + m) ржЯрж╛ржЗржорзЗ ржХрж╛ржЬ ржХрж░рзЗржЫрзЛ, ржпрзЗржЯрж╛ ржнрж╛рж▓рзЛред
ржХрж┐ржирзНрждрзБ ржпрзЗрж╣рзЗрждрзБ ржжрзБржЗржЯрж┐ ржЕрзНржпрж╛рж░рзЗ sorted, рждрж╛ржЗ ржЖржорж░рж╛ ржжрзБржЗржЯрж┐ pointer ржжрж┐рзЯрзЗ O(n + m) ржЯрж╛ржЗржорзЗ ржЖрж░ржУ ржХржо ржорзЗржорж░рж┐рждрзЗ ржХрж╛ржЬ ржХрж░рждрзЗ ржкрж╛рж░рж┐ред

рждржмрзБржУ, рждрзЛржорж╛рж░ ржХрзЛржб ACCEPTED рж╣рзЯрзЗржЫрзЗ ржХрж╛рж░ржг:

тЬЕ Time Complexity: O(n + m)
тЬЕ Space Complexity: O(n)
тЬЕ ржпржерзЗрж╖рзНржЯ Efficient
тЬЕ рж╕рж╣ржЬрзЗржЗ ржмрзЛржЭрж╛ ржпрж╛рзЯ

тЬЕ Final Tips:
рждрзБржорж┐ рж╕рзБржирзНржжрж░ржнрж╛ржмрзЗ ржнрзЗржмрзЗржЫрзЛ тАУ "ржХржоржи" ржмрж▓рждрзЗ ржмрзБржЭрж┐рзЯрзЗржЫрзЛ set1.find() ржжрж┐рзЯрзЗ ржорж┐рж▓ ржЦрзЛржБржЬрзЛ

"рж╕рж░рзНржмржирж┐ржорзНржи" ржмрзЗрж░ ржХрж░рзЗржЫрзЛ findmin() ржжрж┐рзЯрзЗ

ржнрзБрж▓ржнрж╛ржмрзЗ else ans = -1 рж▓рж┐ржЦрзЗржЫрж┐рж▓рзЗ, ржпрзЗржЯрж╛ ржкрзНрж░рзЯрзЛржЬржи ржирзЗржЗ ржХрж╛рж░ржг ржЖржорж░рж╛ рж╢рзЗрж╖рзЗ ржпрж╛ржЪрж╛ржЗ ржХрж░ржЫрж┐ v.empty() ржХрж┐ржирж╛ред

  Full Code for Solution1:
---------------------------

  class Solution 
{
  int findmin(vector<int>& v)
  {
    int min=v[0];
    for(int k=1;k<v.size();k++)
    {
            if(v[k]<min)
            {
              min=v[k];
            }
    }
    return min;
  }
public:
    int getCommon(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int>set1;
        int ans;
        for(int i=0;i<nums1.size();i++)
        {
          set1.insert(nums1[i]);
        }
        vector<int>v;
        for(int j=0;j<nums2.size();j++)
        {
          if(set1.find(nums2[j])!=set1.end())
          {
            v.push_back(nums2[j]);
          }
          else
          {
            ans=-1;
          }
        }
        if(v.empty()) return -1;
        ans=findmin(v);
        return ans;
    }
};
