ЁЯФН рж╕ржорж╕рзНржпрж╛ржЯрж┐ ржХрзА ржмрж▓ржЫрзЗ?
рждрзЛржорж╛ржХрзЗ ржПржоржи ржПржХржЯрж┐ ржХрзНрж▓рж╛рж╕ ржмрж╛ржирж╛рждрзЗ рж╣ржмрзЗ MyHashSet ржирж╛ржорзЗ, ржпрж╛рждрзЗ ржирж┐ржЪрзЗрж░ рждрж┐ржиржЯрж┐ ржХрж╛ржЬ ржХрж░рж╛ ржпрж╛рзЯ:

add(key): ржХрзЛржи key ржЗржирж╕рж╛рж░рзНржЯ ржХрж░ржмрзЗ рж╕рзЗржЯ-ржПред

remove(key): рж╕рзЗржЯ ржерзЗржХрзЗ key рж░рж┐ржорзБржн ржХрж░ржмрзЗ (ржпржжрж┐ ржерж╛ржХрзЗ)ред

contains(key): ржжрзЗржЦрзЗ ржмрж▓ржмрзЗ ржПржЗ key ржЯрж╛ рж╕рзЗржЯрзЗ ржЖржЫрзЗ ржХрж┐ ржирж╛ (true/false)ред

тЬЕ Input/Output ржПрж░ ржЙржжрж╛рж╣рж░ржг ржжрзЗржЦрзЗ ржмрзБржЭрзЗ ржирзЗржУрзЯрж╛ ржпрж╛ржХ:
graphql
Copy
Edit
Input:
["MyHashSet", "add", "add", "contains", "contains", "add", "contains", "remove", "contains"]
[[], [1], [2], [1], [3], [2], [2], [2], [2]]

Output:
[null, null, null, true, false, null, true, null, false]
ржорж╛ржирзЗ:

MyHashSet рждрзИрж░рж┐ рж╣рж▓рзЛ тЖТ ржХрзЛржирзЛ рж░рж┐ржЯрж╛рж░рзНржи ржирзЗржЗ тЖТ null

add(1) тЖТ [1]

add(2) тЖТ [1, 2]

contains(1) тЖТ true

contains(3) тЖТ false

add(2) тЖТ [1, 2] (2 ржЫрж┐рж▓рзЛ, ржЖржмрж╛рж░ ржжрж┐рж▓рзЗ ржХрж┐ржЫрзБ рж╣ржмрзЗ ржирж╛)

contains(2) тЖТ true

remove(2) тЖТ [1]

contains(2) тЖТ false

ЁЯТб рж╕ржорж╛ржзрж╛ржирзЗрж░ ржкрзЗржЫржирзЗ ржЪрж┐ржирзНрждрж╛рж░ ржкрзНрж░ржХрзНрж░рж┐рзЯрж╛:
Step-by-step ржЪрж┐ржирзНрждрж╛:

ржкрзНрж░рж╢рзНржирзЗ ржмрж▓рж╛ рж╣рзЯрзЗржЫрзЗ ржирж┐ржЬрзЗржЗ HashSet ржмрж╛ржирж╛рждрзЗ рж╣ржмрзЗред

HashSet ржПржоржи ржПржХржЯрж╛ ржбрзЗржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░ ржпрзЗржЯрж╛ insert, remove, ржЖрж░ contains тАФ ржПржЗ рждрж┐ржиржЯрж╛ ржЕржкрж╛рж░рзЗрж╢ржи constant time O(1) ржП ржХрж░рзЗред

unordered_set ржарж┐ржХ ржПржЯрж╛ржЗ ржХрж░рзЗ ржерж╛ржХрзЗ, рждрж╛ржЗ рждрзБржорж┐ ржПржЯрж╛ ржЗржЙржЬ ржХрж░рзЗржЫрзЛ тАФ ржХрж┐ржирзНрждрзБ ржкрзНрж░рж╢рзНржирзЗ ржирж┐рж╖рзЗржз ржХрж░рж╛ ржерж╛ржХрж▓рзЗ рждрзЛржорж╛ржХрзЗ ржирж┐ржЬрзЗржЗ implement ржХрж░рждрзЗ рж╣ржмрзЗред


unordered_set<int> set1;
рждрзБржорж┐ STL-ржПрж░ unordered_set ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗржЫрзЛ тАФ ржЕржержЪ ржкрзНрж░рж╢рзНржирзЗ ржмрж▓рж╛, тАЬdonтАЩt use any built-in hash table librariesтАЭред

рждрж╛ржЗ ржПржЗ ржХрзЛржб test case ржП accepted рж╣рж▓рзЗржУ, problem constraints ржнржЩрзНржЧ ржХрж░рзЗржЫрзЗред

тЬЕ рждрж╛рж╣рж▓рзЗ ржХрзАржнрж╛ржмрзЗ ржХрзЛржб рж▓рзЗржЦрж╛ ржЙржЪрж┐ржд?
рждрзБржорж┐ ржирж┐ржЬрзЗрж░ ржПржХржЯрж╛ Hash Table ржмрж╛ржирж┐рзЯрзЗ ржХрж╛ржЬ ржХрж░рждрзЗ ржкрж╛рж░рзЛред ржирж┐ржЪрзЗ ржЖржорж┐ рждрзЛржорж╛ржХрзЗ ржирж┐ржЬрзЗрж░ ржмрж╛ржирж╛ржирзЛ HashSet ржПрж░ ржХрзЛржб ржжрж┐ржЪрзНржЫрж┐ тАФ STL ржЫрж╛рзЬрж╛ред

тЬЕFull Code:
  ----------

  class MyHashSet 
{
public:
  unordered_set<int>set1;
    MyHashSet()
     {
       //  unordered_set<int>set1;
    }
    
    void add(int key) 
    {
       set1.insert(key);
    }
    
    void remove(int key)
     {
       if(!set1.empty())
       {
        set1.erase(key);
       }
    }
    
    bool contains(int key) 
    {
      bool contain=false;
      if(set1.find(key)!=set1.end())
      {
        contain=true;
      }
      return contain;
    }
};

/**
 * Your MyHashSet object will be instantiated and called as such:
 * MyHashSet* obj = new MyHashSet();
 * obj->add(key);
 * obj->remove(key);
 * bool param_3 = obj->contains(key);
 */
