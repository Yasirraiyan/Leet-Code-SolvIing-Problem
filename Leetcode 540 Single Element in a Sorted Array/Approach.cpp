тЬЕ Problem ржмрзЛржЭрж╛:

рждрзЛржорж╛ржХрзЗ ржПржоржи ржПржХржЯрж╛ sorted array ржжрзЗржУрзЯрж╛ рж╣рзЯрзЗржЫрзЗ ржпрзЗржЦрж╛ржирзЗ:

ржкрзНрж░рждрж┐ржЯрж┐ ржПрж▓рж┐ржорзЗржирзНржЯ ржарж┐ржХ ржжрзБржЗржмрж╛рж░ ржЖржЫрзЗред

рж╢рзБржзрзБржорж╛рждрзНрж░ ржПржХржЯрж┐ ржПрж▓рж┐ржорзЗржирзНржЯ ржПржХржмрж╛рж░ ржЖржЫрзЗред

рждрзЛржорж╛ржХрзЗ рж╕рзЗржЗ ржПржХржмрж╛рж░ ржерж╛ржХрж╛ ржПрж▓рж┐ржорзЗржирзНржЯржЯрж┐ ржЦрзБржБржЬрзЗ ржмрзЗрж░ ржХрж░рждрзЗ рж╣ржмрзЗред



---

ЁЯОп Target:

Time Complexity: O(log n)

Space Complexity: O(1)



---

ЁЯФН рждрзЛржорж╛рж░ Approach ржмрзНржпрж╛ржЦрзНржпрж╛ (Map/Hashing-based):

рждрзЛржорж╛рж░ ржХрзЛржб ржПржЗржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ:

1я╕ПтГг Frequency Count ржХрж░рж╛

unordered_map<int,int>freq;
for(int i=0;i<nums.size();i++)
{
    freq[nums[i]]++;
}

ржПржЦрж╛ржирзЗ рждрзБржорж┐ ржкрзНрж░рждрж┐ржЯрж┐ рж╕ржВржЦрзНржпрж╛рж░ frequency ржЧрзБржиржЫрзЛред ржпрж╛рж░рж╛ ржПржХржмрж╛рж░ ржЖржЫрзЗ, рждрж╛ржжрзЗрж░ frequency рж╣ржмрзЗ 1ред

2я╕ПтГг ржПржХржмрж╛рж░ ржпрзЗржЯрж╛ ржПрж╕рзЗржЫрзЗ рж╕рзЗржЯрж╛ ржЦрзБржБржЬрзЗ ржмрзЗрж░ ржХрж░рзЛ:

for(auto it:freq)
{
    if(it.second==1)
    {
        ans=it.first;
        break;
    }
}

3я╕ПтГг Return the answer:

return ans;


---

ЁЯФБ ржЙржжрж╛рж╣рж░ржг ржжрж┐рзЯрзЗ ржмрзНржпрж╛ржЦрзНржпрж╛:

ржзрж░рж┐ ржЗржиржкрзБржЯ:

nums = [1,1,2,3,3,4,4,8,8]

Step 1: Frequency map:

{
  1 тЖТ 2 ржмрж╛рж░
  2 тЖТ 1 ржмрж╛рж░ тЬЕ
  3 тЖТ 2 ржмрж╛рж░
  4 тЖТ 2 ржмрж╛рж░
  8 тЖТ 2 ржмрж╛рж░
}

Step 2: ржПржХржорж╛рждрзНрж░ ржпрзЗржЯрж╛ 1 ржмрж╛рж░ ржЖржЫрзЗ тЖТ рж╕рзЗржЯрж╛ 2

тЬЕ Output тЖТ 2


---

тЭЧTime & Space Complexity:

Time: O(n) тЖТ ржХрж╛рж░ржг рждрзБржорж┐ ржкрзБрж░рзЛ array traverse ржХрж░ржЫрзЛ ржжрзБржЗржмрж╛рж░

Space: O(n) тЖТ ржХрж╛рж░ржг unordered_map ржП рж╕ржХрж▓ unique elements рж╕рзНржЯрзЛрж░ рж╣ржЪрзНржЫрзЗ



---

тЬЕ ржХрзЗржи рждрзЛржорж╛рж░ solution Accepted рж╣рж▓рзЛ?

> Leetcode рж╢рзБржзрзБ ржмрж▓рзЗ "It must run in O(log n)", ржХрж┐ржирзНрждрзБ рждрж╛рж░ ржорж╛ржирзЗ ржПржЗ ржирж╛ ржпрзЗ O(n) рж╕рж▓рж┐ржЙрж╢ржи rejected рж╣ржмрзЗред
рж╕рзЗржЯрж╛ рж╣рж▓ best-optimized solution ржЦрзБржБржЬрждрзЗ рж╣рж▓рзЗ O(log n) ржХрж░рждрзЗ рж╣ржмрзЗред
рждржмрзЗ brute force ржмрж╛ O(n) accepted рж╣рзЯ ржЕржирзЗржХ рж╕ржорзЯред




---

тЬи рждрзБржорж┐ ржХрзАржнрж╛ржмрзЗ solution ржнрж╛ржмржмрзЗ?

ржкрзНрж░ржержорзЗ ржкрзНрж░рж╢рзНржи ржкрзЬрзЗ рждрзБржорж┐ ржмрзБржЭржмрзЗ:

Sorted Array

ржкрзНрж░рждрж┐ржЯрж╛ element рзи ржмрж╛рж░ ржЖржЫрзЗ

ржПржХржЯрж╛ ржорж╛рждрзНрж░ element ржПржХржмрж╛рж░ ржЖржЫрзЗ

тЖТ "Binary Search" use ржХрж░рж▓рзЗ ржнрж╛рж▓рзЛ рж╣рзЯ, ржХрж╛рж░ржг sorted array


ржХрж┐ржирзНрждрзБ рждрзБржорж┐ ржкрзНрж░ржержорзЗ map ржжрж┐рзЯрзЗ brute-force approach ржХрж░рзЗржЫрзЛ, ржпрзЗржЯрж╛ valid & works fine.


---

ЁЯзк Code Testing Line by Line:

Input:

nums = [1,1,2,3,3,4,4,8,8]

Step 1: Loop ржжрж┐рзЯрзЗ Frequency Count:

unordered_map<int,int> freq;
for (int i = 0; i < nums.size(); i++)
{
    freq[nums[i]]++;
}

freq рж╣ржмрзЗ:

{1:2, 2:1, 3:2, 4:2, 8:2}

Step 2: Second loop:

for (auto it : freq)
{
    if (it.second == 1)
    {
        ans = it.first;
        break;
    }
}

ржПржЦрж╛ржирзЗ 2 ржПрж░ frequency 1 тЖТ рждрж╛ржЗ return ржХрж░ржмрзЗ 2


---

тЬЕ Final Accepted Code:

class Solution 
{
public:
    int singleNonDuplicate(vector<int>& nums)
    {
        unordered_map<int,int> freq;
        int ans;
        for(int i = 0; i < nums.size(); i++)
        {
            freq[nums[i]]++;
        }
        for(auto it : freq)
        {
            if(it.second == 1)
            {
                ans = it.first;
                break;
            }
        }
        return ans;
    }
};
