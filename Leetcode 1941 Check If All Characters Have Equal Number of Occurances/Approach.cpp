এই সমস্যাটি সলভ করার জন্য আমাদের একটি স্ট্রিং দেওয়া হবে এবং আমাদের কাজ হল চেক করা যে সব ক্যারেক্টারগুলো একই সংখ্যক বার স্ট্রিংয়ে উপস্থিত হয়েছে কিনা। যদি সব ক্যারেক্টারের উপস্থিতির সংখ্যা সমান হয়, তবে স্ট্রিংটি "good" হবে, অন্যথায় তা হবে "bad"।

ধাপে ধাপে সমাধান:
স্ট্রিংয়ের ক্যারেক্টার গননা:
প্রথমে আমাদের স্ট্রিংয়ের প্রতিটি ক্যারেক্টারের গননা করতে হবে। এর জন্য আমরা unordered_map ব্যবহার করব, যেখানে প্রতিটি ক্যারেক্টার হবে কিও এবং তার উপস্থিতির সংখ্যা হবে ভ্যালু।

উপস্থিতি গননার মান সঞ্চয় করা:
এরপর, যেসব ক্যারেক্টার স্ট্রিংয়ে আছে, তাদের গননা একটি ভেক্টরে সঞ্চয় করব।

সামঞ্জস্য যাচাই করা:
এখন, যেহেতু আমাদের কাছে প্রতিটি ক্যারেক্টারের উপস্থিতির সংখ্যা রয়েছে, আমাদের শুধু চেক করতে হবে যে সব গননা সংখ্যা সমান কিনা।

উত্তর দেওয়া:
যদি সব গননা সংখ্যা সমান হয়, তবে স্ট্রিংটি "good" এবং আমরা true রিটার্ন করব। অন্যথায়, আমরা false রিটার্ন করব।

কোড ব্যাখ্যা:
cpp
Copy
Edit
#include<string>
#include<iostream>
#include<unordered_map>
#include<string>
#include<vector>
using namespace std;

class Solution {
public:
    bool areOccurrencesEqual(string s) {
        unordered_map<char, int> freq;  // প্রতিটি ক্যারেক্টারের গননা রাখবে
        bool isequal = true;  // শুরুতে আমরা ধরে নিচ্ছি সব সংখ্যা সমান

        // প্রথম লুপে স্ট্রিংয়ের প্রতিটি ক্যারেক্টারের গননা করা হচ্ছে
        for(int i = 0; i < s.size(); i++) {
            freq[s[i]]++;  // ক্যারেক্টারটির উপস্থিতি গননা বৃদ্ধি
        }

        vector<int> frequency;  // ক্যারেক্টারের উপস্থিতি গননার ভেক্টর

        // এখানে প্রতিটি ক্যারেক্টারের উপস্থিতি গননা ভেক্টরে রাখা হচ্ছে
        for(auto it : freq) {
            frequency.push_back(it.second);
        }

        int ref = frequency[0];  // প্রথম গননা সংখ্যাকে রেফারেন্স হিসেবে ধরলাম

        // এরপর, বাকি সব গননা সংখ্যা পরীক্ষা করা হচ্ছে
        for(int j = 1; j < frequency.size(); j++) {
            if(frequency[j] != ref) {  // যদি কোনো গননা প্রথমটির সমান না হয়
                isequal = false;  // স্ট্রিংটি "good" নয়
                break;  // আর যাচাইয়ের প্রয়োজন নেই
            }
        }

        return isequal;  // যদি সব গননা সমান হয়, তাহলে true, নাহলে false
    }
};
কোডের প্রতিটি অংশের ব্যাখ্যা:
unordered_map<char, int> freq: এখানে আমরা একটি unordered_map ব্যবহার করেছি যেটি ক্যারেক্টারের জন্য গননা রাখবে। যেমন 'a' যদি ২ বার আসে, তাহলে freq['a'] হবে ২।

for(int i = 0; i < s.size(); i++): এই লুপটি স্ট্রিংয়ের প্রতিটি ক্যারেক্টারের জন্য চলে এবং আমরা সেই ক্যারেক্টারের গননা বাড়িয়ে দিই।

vector<int> frequency: এখানে আমরা একটি ভেক্টর তৈরি করেছি যেখানে প্রতিটি ক্যারেক্টারের উপস্থিতির সংখ্যা গুলি রাখা হবে।

int ref = frequency[0]: প্রথম গননা মানটিকে আমরা রেফারেন্স হিসেবে নিয়েছি। অর্থাৎ, বাকি সব গননা এর সাথে মিলিয়ে দেখব।

if(frequency[j] != ref): এখানে আমরা যাচাই করছি যে, কোনো গননা মান প্রথমটির সমান না হলে, তখন স্ট্রিংটি "good" নয় এবং isequal কে false করে দেওয়া হবে।

return isequal: শেষে, যদি সব গননা সমান হয় তবে true রিটার্ন হবে, অন্যথায় false রিটার্ন হবে।

উদাহরণ:
ইনপুট: s = "abacbc"

ক্যারেক্টার গননা: 'a' → 2, 'b' → 2, 'c' → 2

সব গননা সমান, তাই আউটপুট হবে true।

ইনপুট: s = "aaabb"

ক্যারেক্টার গননা: 'a' → 3, 'b' → 2

গননা সমান নয়, তাই আউটপুট হবে false।

কোডে এই ধরণের সমাধান কেন গ্রহণযোগ্য:
Efficient Approach: এই পদ্ধতিটি স্ট্রিংয়ের দৈর্ঘ্য অনুযায়ী গননা করে এবং তারপর গননা গুলি যাচাই করে। এটি O(n) টাইম কমপ্লেক্সিটি সম্পন্ন যেখানে n হল স্ট্রিংয়ের দৈর্ঘ্য।

Space Complexity: গননা রাখা হয় unordered_map এবং vector তে, যার জন্য স্পেস কমপ্লেক্সিটি O(k), যেখানে k হল স্ট্রিংয়ের বিভিন্ন ক্যারেক্টারের সংখ্যা।

এই ধরনের সমাধানটি কার্যকরী এবং দ্রুত, যেহেতু স্ট্রিংয়ের ক্যারেক্টারের গননা একবারে করে পরে তুলনা করা হয়।
