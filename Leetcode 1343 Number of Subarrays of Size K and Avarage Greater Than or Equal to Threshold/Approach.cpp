সমস্যা (Problem) কী?
তোমাকে একটা ইন্টিজার অ্যারে arr, এবং দুইটি সংখ্যা k (sub-array size) ও threshold দেয়া হয়েছে। তোমার কাজ:

কতগুলো continuous সাব-অ্যারে আছেন যার দৈর্ঘ্য k এবং গড় (average) মান threshold এর চেয়ে বড় বা সমান?

উদাহরণ (Example):
arr = [2,2,2,2,5,5,5,8], k=3, threshold=4

সাব-অ্যারের গড় বের করো দৈর্ঘ্য ৩ এর। যেমন [2,2,2], [2,2,2], [2,2,5] ইত্যাদি।

তারপর দেখো কোন গড় ৪ বা তার বেশি।

সেই সাব-অ্যারের সংখ্যা রিটার্ন করো।

উপরের উদাহরণে ৩টি সাব-অ্যারে পাওয়া যায় যাদের গড় >= 4:

[2,5,5] গড় = (2+5+5)/3 = 4

[5,5,5] গড় = 5

[5,5,8] গড় = 6

সমাধানের ধরন (Approach):
Sliding Window technique

কেন sliding window?
আমাদের সাব-অ্যারে সবসময় দৈর্ঘ্য k।

আমরা প্রতিটি সাব-অ্যারে গড় বের করতে চাই।

সরাসরি প্রতিটি সাব-অ্যারে গড় বের করলে O(n*k) সময় লাগবে, যা ধীর।

তবে আমরা sliding window ব্যবহার করলে O(n) সময়ে পারব।

Sliding Window কী?
একটা fixed-size উইন্ডো (window) রাখা হবে অ্যারের ভেতরে, দৈর্ঘ্য k।

উইন্ডো গড়ানোর সময় উইন্ডোর বাম দিকের উপাদান বাদ দিয়ে ডান দিকে নতুন উপাদান যুক্ত করা হয়।

প্রতিবার উইন্ডোর গড় বের করার জন্য পুরো উইন্ডো যোগ করতে হবে না, আগের উইন্ডোর যোগফল থেকে শুধু বাদ দেয়া আর নতুন যোগ করা উপাদান যোগ করলেই হবে।

সমাধানের ধাপ:
প্রথমে প্রথম k উপাদানের যোগফল নাও (উইন্ডোর শুরু) — sum।

গড় বের করো: sum / k এবং তা threshold এর চেয়ে বড়/সমান কিনা দেখো।

তারপর, উইন্ডোকে এক এক করে ডান দিকে সরাও:

পুরনো উইন্ডোর প্রথম উপাদান বাদ দাও।

নতুন উপাদান যোগ করো।

নতুন উইন্ডোর যোগফল থেকে আবার গড় বের করো।

প্রত্যেকবার গড় যদি threshold এর চেয়ে বড়/সমান হয়, কাউন্টার বাড়াও।

সব শেষ পর্যন্ত গড়গুলো চেক করার পর কাউন্টার রিটার্ন করো।

তোমার দেওয়া কোডের ব্যাখ্যা:
cpp
Copy
Edit
class Solution {
public:
    int numOfSubarrays(vector<int>& arr, int k, int threshold) {
        int count = 0;
        int sum = 0;
        // প্রথম k উপাদানের যোগফল
        for(int i = 0; i < k; i++) {
            sum += arr[i];
        }
        // প্রথম উইন্ডোর গড় চেক করা
        if(sum / k >= threshold) {
            count++;
        }
        
        int windowsum = sum;
        // উইন্ডো গড়ানোর জন্য লুপ
        for(int j = k; j < arr.size(); j++) {
            windowsum = windowsum - arr[j - k] + arr[j];
            if((windowsum / k) >= threshold) {
                count++;
            }
        }
        return count;
    }
};
কোড বিশ্লেষণ:
sum প্রথম উইন্ডোর যোগফল হিসাব করে।

প্রথম উইন্ডোর গড় পরীক্ষা করে count++ করে যদি >= threshold হয়।

তারপর এক একটি উপাদান উইন্ডোর বাইরে চলে যাওয়ার সময় (বামদিকের), নতুন উপাদান যোগ হয় (ডানদিকের), উইন্ডোর যোগফল আপডেট হয় windowsum = windowsum - arr[j-k] + arr[j];

প্রতিবার গড় চেক করে যদি >= threshold হয় তাহলে কাউন্টার বাড়ানো হয়।

সবশেষে count রিটার্ন করা হয়।

Test Code:
-----------

  সমস্যার টেস্ট কেস দিয়ে পরীক্ষা:
উদাহরণ ১:
ini
Copy
Edit
arr = [2,2,2,2,5,5,5,8]
k = 3
threshold = 4
প্রথম উইন্ডো: [2,2,2], sum=6, গড়=2 < 4, count=0

দ্বিতীয় উইন্ডো: [2,2,5], sum=9, গড়=3 < 4, count=0

তৃতীয় উইন্ডো: [2,5,5], sum=12, গড়=4 >= 4, count=1

চতুর্থ উইন্ডো: [5,5,5], sum=15, গড়=5 >= 4, count=2

পঞ্চম উইন্ডো: [5,5,8], sum=18, গড়=6 >= 4, count=3

সুতরাং আউটপুট ৩, যা সঠিক।

সারমর্ম (Summary):
Sliding Window হলো সবচেয়ে কার্যকরী উপায় যখন সাব-অ্যারের সাইজ ফিক্সড।

প্রথম উইন্ডোর যোগফল বের করে রাখো, এরপর প্রতিবার উইন্ডো সরানোর সময় পুরানো উপাদান বাদ দিয়ে নতুন উপাদান যোগ করো।

গড় তুলনার জন্য গাণিতিকভাবে ভাগ না দিয়ে যোগফল তুলনা করাই বেশি নিরাপদ।

প্রতিটি উইন্ডোর গড় তুলনা করো threshold এর সাথে, যেগুলো পাস করবে সেগুলোর সংখ্যা গোনো।

  Full Code:
-------------

  class Solution 
{
public:
 
    int numOfSubarrays(vector<int>& arr, int k, int threshold) 
{
        int count=0;
        int sum=0;
        for(int i=0;i<k;i++)
        {
              sum+=arr[i];
        }
        if(sum/k>=threshold)
        {
            count++;
        }
        int suum=0;
        int windowsum=sum;
        vector<int>v;
        for(int j=k;j<arr.size();j++)
        {
           suum+=arr[j];
           windowsum=windowsum-arr[j-k]+arr[j];
           if((windowsum/k)>=threshold)
           {
            count++;
           }
        }
        return count;
    }
};
