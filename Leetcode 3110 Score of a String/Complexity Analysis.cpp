এই ফাংশনটি একটি স্ট্রিং ইনপুট নিয়ে স্ট্রিংয়ের প্রতিটি পরপর ক্যারেক্টারের ASCII মানের পার্থক্যের পরম মান (absolute difference) যোগ করে একটি স্কোর রিটার্ন করে।

সময় জটিলতা (Time Complexity)
O(n), যেখানে n হল স্ট্রিংয়ের দৈর্ঘ্য

কারণ:

একটি মাত্র for লুপ আছে যা s.size()-1 বার এক্সিকিউট হয়

প্রতিটি ইটারেশনে কনস্ট্যান্ট সময়ের (O(1)) অপারেশন হয় (abs() এবং বিয়োগ)

উদাহরণ:

"hello" (length 5) → লুপ 4 বার চলবে

"abc" (length 3) → লুপ 2 বার চলবে

স্পেস জটিলতা (Space Complexity)
O(1) (কনস্ট্যান্ট স্পেস)

কারণ:

শুধুমাত্র একটি sum ভেরিয়েবল ব্যবহার হচ্ছে

ইনপুট সাইজ যত বড়ই হোক না কেন, অতিরিক্ত মেমরি ব্যবহার হয় না

sum ভেরিয়েবল সবসময় একটি ইন্টিজার সাইজের (সাধারণত 4 বাইট) জায়গা নেয়

কোডের ধাপে ধাপে ব্যাখ্যা:
cpp
Copy
int scoreOfString(string s) {
    int sum = 0; // O(1) স্পেস
    for(int i = 0; i < s.size() - 1; i++) { // O(n) টাইম
        sum += abs(int(s[i]) - int(s[i+1])); // ASCII মানের পার্থক্য
    }
    return sum;
}
উদাহরণ দিয়ে ব্যাখ্যা:
ইনপুট: "abc"

ক্যালকুলেশন:

'a' (97) এবং 'b' (98) → abs(97-98) = 1

'b' (98) এবং 'c' (99) → abs(98-99) = 1

মোট স্কোর = 1 + 1 = 2

এখানে স্ট্রিংয়ের দৈর্ঘ্য 3, লুপ 2 বার ঘুরেছে (3-1 বার)।

কেন এটি এফিসিয়েন্ট?
এটি একটি অপ্টিমাল সলিউশন কারণ:

সমস্যাটি O(n) টাইমের চেয়ে ভালোভাবে সল্ভ করা সম্ভব না (কারণ সব ক্যারেক্টার দেখতেই হবে)

মেমরি ব্যবহার মিনিমাম রাখা হয়েছে (শুধুমাত্র একটি ভেরিয়েবল)

