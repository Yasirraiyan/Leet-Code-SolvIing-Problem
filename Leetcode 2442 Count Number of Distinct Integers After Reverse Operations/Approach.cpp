üß† Problem Summary (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡ßü):

‡¶§‡ßã‡¶Æ‡¶æ‡¶ï‡ßá ‡¶è‡¶ï‡¶ü‡¶ø nums array ‡¶¶‡ßá‡¶ì‡ßü‡¶æ ‡¶Ü‡¶õ‡ßá ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶∂‡ßÅ‡¶ß‡ßÅ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ positive integers ‡¶Ü‡¶õ‡ßá‡•§
‡¶§‡ßã‡¶Æ‡¶æ‡¶∞ ‡¶ï‡¶æ‡¶ú ‡¶π‡¶≤‡ßã:

1. ‡¶™‡ßç‡¶∞‡¶§‡ßç‡¶Ø‡ßá‡¶ï ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶∞ digit reverse ‡¶ï‡¶∞‡ßá ‡¶∏‡ßá‡¶á ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶ü‡¶ø array-‡¶è‡¶∞ ‡¶∂‡ßá‡¶∑‡ßá ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶æ‡•§


2. ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ ‡¶è‡¶á ‡¶®‡¶§‡ßÅ‡¶® array-‡¶è ‡¶ï‡¶§‡¶ó‡ßÅ‡¶≤‡ßã ‡¶≠‡¶ø‡¶®‡ßç‡¶® ‡¶≠‡¶ø‡¶®‡ßç‡¶® ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ (distinct integers) ‡¶Ü‡¶õ‡ßá, ‡¶∏‡ßá‡¶ü‡¶æ ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ‡•§




---

‚úÖ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£:

Input:

nums = [1,13,10,12,31]

Reverse ‡¶ó‡ßÅ‡¶≤‡ßã:

1 ‚Üí 1
13 ‚Üí 31
10 ‚Üí 01 ‚Üí 1
12 ‚Üí 21
31 ‚Üí 13

Final array:

[1, 13, 10, 12, 31, 1, 31, 1, 21, 13]

Distinct values:

{1, 10, 12, 13, 21, 31} ‚Üí total = 6


---

üß≠ ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®‡ßá‡¶∞ ‡¶ï‡ßå‡¶∂‡¶≤ (Approach):

‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶™‡ßú‡ßá ‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá ‡¶ö‡¶ø‡¶®‡ßç‡¶§‡¶æ ‡¶ï‡¶∞‡¶¨‡ßã?

1. ‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶ß‡¶æ‡¶™: ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶æ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶∞ reverse ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶¨‡ßã‡•§


2. ‡¶¶‡ßç‡¶¨‡¶ø‡¶§‡ßÄ‡ßü ‡¶ß‡¶æ‡¶™: ‡¶è‡¶á reverse ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶Æ‡ßÇ‡¶≤ array-‡¶è‡¶∞ ‡¶∂‡ßá‡¶∑‡ßá ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶¨‡ßã‡•§


3. ‡¶§‡ßÉ‡¶§‡ßÄ‡ßü ‡¶ß‡¶æ‡¶™: ‡¶™‡ßÅ‡¶∞‡¶æ array-‡¶§‡ßá ‡¶è‡¶ñ‡¶® ‡¶ï‡¶§‡¶ó‡ßÅ‡¶≤‡ßã ‡¶≠‡¶ø‡¶®‡ßç‡¶® ‡¶≠‡¶ø‡¶®‡ßç‡¶® (distinct) ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶Ü‡¶õ‡ßá, ‡¶∏‡ßá‡¶ü‡¶æ ‡¶ó‡ßÅ‡¶®‡¶¨‡ßã‡•§




---

üßÆ Line-by-line ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡ßü ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶∏‡¶π):

class Solution 
{
public:
    // ‡¶è‡¶ï‡¶ü‡¶ø helper function ‡¶Ø‡ßá‡¶ü‡¶æ ‡¶è‡¶ï‡¶ü‡¶æ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ reverse ‡¶ï‡¶∞‡ßá
    int findrev(int n)
    {
        int rev=0;
        while(n>0)  // ‡¶Ø‡¶§‡¶ï‡ßç‡¶∑‡¶£ ‡¶®‡¶æ n ‡¶∂‡ßá‡¶∑ ‡¶π‡¶ö‡ßç‡¶õ‡ßá
        {
            int digit=n%10;       // ‡¶∂‡ßá‡¶∑ digit ‡¶®‡ßá‡¶ì‡ßü‡¶æ
            rev=rev*10+digit;     // reverse-‡¶è ‡¶∏‡ßá‡¶ü‡¶ø ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶æ
            n=n/10;               // ‡¶™‡¶∞‡ßá‡¶∞ digit ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø n ‡¶õ‡ßã‡¶ü ‡¶ï‡¶∞‡¶æ
        }
        return rev;
    }

üëâ ‡¶è‡¶á findrev() function ‡¶ü‡¶æ ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶õ‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶ï‡ßá reverse ‡¶ï‡¶∞‡ßá return ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø‡•§
‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£:
findrev(13) ‚Üí 31
findrev(10) ‚Üí 1


---

int countDistinctIntegers(vector<int>& nums) 
    {
        int originalsize=nums.size();  // ‡¶Æ‡ßÇ‡¶≤ array-‡¶è‡¶∞ ‡¶Ü‡¶ï‡¶æ‡¶∞ ‡¶Æ‡¶®‡ßá ‡¶∞‡¶æ‡¶ñ‡¶æ

üëâ ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶Æ‡ßÇ‡¶≤ array-‡¶è‡¶∞ ‡¶â‡¶™‡¶∞‡ßá reverse apply ‡¶ï‡¶∞‡¶¨‡ßã, ‡¶§‡¶æ‡¶á size ‡¶Ü‡¶ó‡ßá ‡¶ß‡¶∞‡ßá ‡¶∞‡¶æ‡¶ñ‡¶ø‡•§


---

for(int i=0;i<originalsize;i++)
        {
            nums.push_back(findrev(nums[i]));  // reverse ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶∂‡ßá‡¶∑‡ßá‡¶∞ ‡¶¶‡¶ø‡¶ï‡ßá ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶õ‡¶ø
        }

üëâ ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶•‡ßá‡¶ï‡ßá originalsize ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ ‡¶ó‡¶ø‡ßü‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶∞ reverse ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡ßá nums ‡¶è append ‡¶ï‡¶∞‡¶õ‡¶ø‡•§


---

unordered_map<int,int>freq;
        for(int j=0;j<nums.size();j++)
        {
            freq[nums[j]]++;   // frequency ‡¶ó‡¶£‡¶®‡¶æ ‡¶ï‡¶∞‡¶õ‡¶ø, ‡¶è‡¶ï‡¶ü‡¶ø‡¶¨‡¶æ‡¶∞ ‡¶è‡¶≤‡ßá‡¶á map-‡¶è ‡¶•‡¶æ‡¶ï‡¶¨‡ßá
        }

üëâ unordered_map ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶ï‡ßá map ‡¶ï‡¶∞‡¶õ‡¶ø‡•§
‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶∂‡ßÅ‡¶ß‡ßÅ key ‡¶ó‡ßÅ‡¶≤‡ßã important ‚Äî key ‡¶Æ‡¶æ‡¶®‡ßá‡¶á unique/distinct ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡•§


---

vector<int>v;
        for(auto it:freq)
        {
            v.push_back(it.first);   // map ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶¨ unique ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶®‡¶ø‡¶ö‡ßç‡¶õ‡¶ø
        }

üëâ map-‡¶è‡¶∞ key ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶®‡¶ø‡ßü‡ßá ‡¶è‡¶ï‡¶ü‡¶æ vector ‡¶¨‡¶æ‡¶®‡¶æ‡¶≤‡¶æ‡¶Æ‡•§ ‡¶è‡¶ü‡¶ø ‡¶∂‡ßÅ‡¶ß‡ßÅ‡¶á distinct ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶ß‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø‡•§


---

int ans=v.size();   // total ‡¶ï‡¶§‡¶ü‡¶ø distinct ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ
        return ans;
    }
};

üëâ ‡¶Ö‡¶¨‡¶∂‡ßá‡¶∑‡ßá return ‡¶ï‡¶∞‡¶≤‡¶æ‡¶Æ ‡¶∏‡ßá‡¶á ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶Ø‡ßá‡¶ó‡ßÅ‡¶≤‡ßã distinct ‡¶õ‡¶ø‡¶≤‡•§


---

‚è≥ Time Complexity:

Reversing: O(n * D), ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá D ‡¶π‡¶ö‡ßç‡¶õ‡ßá ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ digit ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ (‡¶ï‡¶Æ‡¶¨‡ßá‡¶∂‡¶ø log‚ÇÅ‚ÇÄ(num))

Insertion into map: O(n)

Overall: O(n) ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≠‡¶æ‡¶∞‡ßá‡¶ú ‡¶ï‡ßá‡¶∏‡ßá‡•§



---

‚úÖ Accepted ‡¶ï‡ßá‡¶®?

‡¶ï‡¶æ‡¶∞‡¶£ ‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶ï‡ßá‡¶¨‡¶≤ original element ‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶â‡¶™‡¶∞‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶õ‡ßã‡•§

‡¶§‡ßÅ‡¶Æ‡¶ø reverse ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶∂‡ßÅ‡¶ß‡ßÅ once ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶õ‡ßã‡•§

‡¶§‡¶æ‡¶∞‡¶™‡¶∞ unordered_map ‡¶¶‡¶ø‡ßü‡ßá efficiently distinct ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶õ‡ßã‡•§



---

üîç Test Case ‡¶¶‡¶ø‡ßü‡ßá ‡¶Ø‡¶æ‡¶ö‡¶æ‡¶á:

Input:

nums = [2,2,2]

Reverse: 2 ‚Üí 2 ‚Üí 2
Final array: [2,2,2,2,2,2]
Distinct: {2}
Output: 1 ‚úÖ


---

üîö ‡¶â‡¶™‡¶∏‡¶Ç‡¶π‡¶æ‡¶∞ (Summary):

‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá original ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ reverse ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡ßá‡¶õ‡ßã‡•§

‡¶§‡¶æ‡¶∞‡¶™‡¶∞ ‡¶∏‡ßá‡¶ó‡ßÅ‡¶≤‡ßã array-‡¶§‡ßá ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßá‡¶õ‡ßã‡•§

‡¶∏‡¶¨‡¶∂‡ßá‡¶∑‡ßá, unordered_map ‡¶¶‡¶ø‡ßü‡ßá unique ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶ó‡ßÅ‡¶®‡ßá‡¶õ‡ßã‡•§

‡¶ï‡ßã‡¶°‡¶ü‡¶ø efficient ‡¶ï‡¶æ‡¶∞‡¶£ map-‡¶è‡¶∞ key ‡¶ó‡ßÅ‡¶≤‡ßã distinct ‡¶∞‡¶æ‡¶ñ‡ßá‡•§




Full Code:
--------------
class Solution 
{
public:
    int findrev(int n)
    {
        int rev=0;
        while(n>0)
            {
                int digit=n%10;
                rev=rev*10+digit;
                n=n/10;
            }
        return rev;
    }
    int countDistinctIntegers(vector<int>& nums) 
    {
        int originalsize=nums.size();
        for(int i=0;i<originalsize;i++)
            {
                nums.push_back(findrev(nums[i]));
            }
        unordered_map<int,int>freq;
        for(int j=0;j<nums.size();j++)
            {
                freq[nums[j]]++;
            }
        vector<int>v;
        for(auto it:freq)
            {
                v.push_back(it.first);
            }
        int ans=v.size();
        return ans;
    }
};  
