ЁЯФН ржЙржжрж╛рж╣рж░ржг ржУ рж▓ржХрзНрж╖рзНржп:
Input: nums = [1,2,3,4,5,4]
ЁЯСЙ ржПржЦрж╛ржирзЗ 4 ржжрзБржЗржмрж╛рж░ ржПрж╕рзЗржЫрзЗ, ржЖрж░ 2 рж╣рж▓рзЛ ржкрзНрж░рж╛ржЗржоред
тЬЕ So, output: true.

Input: nums = [1,2,3,4,5]
ЁЯСЙ рж╕ржм рж╕ржВржЦрзНржпрж╛рж░ ржлрзНрж░рж┐ржХрзЛрзЯрзЗржирзНрж╕рж┐ 1, ржХрж┐ржирзНрждрзБ 1 ржкрзНрж░рж╛ржЗржо ржирж╛ред
тЭМ So, output: false.

тЬЕ ржХрзЛржбрзЗрж░ ржкрзБрж░рзЛ ржзрж╛рж░рж╛ржмрж╛рж╣рж┐ржХ ржУ ржмрзНржпрж╛ржЦрзНржпрж╛:
cpp
Copy
Edit
class Solution {
public:
тЬЕ CheckPrime() ржлрж╛ржВрж╢ржи:
cpp
Copy
Edit
  bool CheckPrime(int n)
  {
    bool isprime=true;
ЁЯФ╣ isprime ржзрж░рзЗ ржирж┐ржЪрзНржЫрж┐ true тАФ ржкрж░рзЗ ржпржжрж┐ divisor ржкрж╛ржЗ рждрж╛рж╣рж▓рзЗ false ржХрж░ржмред

cpp
Copy
Edit
    if(n<=1) 
    {
      isprime=false;
    }
ЁЯФ╣ 1 ржмрж╛ рждрж╛рж░ ржХржо ржорж╛ржи ржХржЦржирзЛржЗ ржкрзНрж░рж╛ржЗржо ржирж╛ тАФ рждрж╛ржЗ рж╕рж░рж╛рж╕рж░рж┐ falseред

cpp
Copy
Edit
    for(int i=2;i*i<=n;i++)
    {
      if(n%i==0)
      {
        isprime=false;
        break;
      }
    }
ЁЯФ╣ Prime ржЪрзЗржХ ржХрж░рж╛рж░ рж╕рзНржЯрзНржпрж╛ржирзНржбрж╛рж░рзНржб рж▓ржЬрж┐ржХ тАФ 2 ржерзЗржХрзЗ sqrt(n) ржкрж░рзНржпржирзНржд ржЪрзЗржХ ржХрж░рж┐ред ржпржжрж┐ ржХрзЛржи ржнрж╛ржЧ рж╣рзЯ, рждрж╛рж╣рж▓рзЗ ржПржЯрж╛ ржкрзНрж░рж╛ржЗржо ржирж╛ред

cpp
Copy
Edit
    return isprime;
  }
ЁЯФ╣ рж╢рзЗрж╖рзЗ true/false рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рж┐ред

тЬЕ ржорзВрж▓ ржХрж╛ржЬрзЗрж░ ржлрж╛ржВрж╢ржи checkPrimeFrequency():
cpp
Copy
Edit
    bool checkPrimeFrequency(vector<int>& nums) 
    {
        bool check=false;
        unordered_map<int,int>freq;
ЁЯФ╣ ржПржХржЯрж╛ ржорзНржпрж╛ржк ржирж┐рзЯрзЗ ржкрзНрж░рждрж┐ржЯрж╛ рж╕ржВржЦрзНржпрж╛рж░ ржлрзНрж░рж┐ржХрзЛрзЯрзЗржирзНрж╕рж┐ ржЧрзБржиржЫрж┐ред

cpp
Copy
Edit
        for(int i=0;i<nums.size();i++)
        {
          freq[nums[i]]++;
        }
ЁЯФ╣ ржкрзБрж░рзЛ ржЕрзНржпрж╛рж░рзЗржЯрж╛ ржШрзБрж░рзЗ ржЧрж┐рзЯрзЗ ржорзНржпрж╛ржкрзЗ ржЗржиржкрзБржЯ рж╕ржВржЦрзНржпрж╛ржЧрзБрж▓рзЛрж░ ржлрзНрж░рж┐ржХрзЛрзЯрзЗржирзНрж╕рж┐ ржХрж╛ржЙржирзНржЯ ржХрж░рж▓рж╛ржоред

тЬЕ ржПржЦржи ржлрзНрж░рж┐ржХрзЛрзЯрзЗржирзНрж╕рж┐ржЧрзБрж▓рзЛ ржирж┐рзЯрзЗ ржкрзНрж░рж╛ржЗржо ржХрж┐ржирж╛ ржЪрзЗржХ ржХрж░ржм:
cpp
Copy
Edit
        for(auto it:freq)
        {
          if(CheckPrime(it.second))
          {
            check=true;
            break;
          }
        }
ЁЯФ╣ ржпрждржЧрзБрж▓рзЛ рж╕ржВржЦрзНржпрж╛рж░ frequency ржЖржЫрзЗ рж╕рзЗржЧрзБрж▓рзЛрж░ frequency (ржорж╛ржирзЗ it.second) ржкрзНрж░рж╛ржЗржо ржХрж┐ржирж╛ ржЪрзЗржХ ржХрж░ржмред
ЁЯФ╣ ржпржжрж┐ ржХрзЛржирзЛ ржПржХржЯрж╛ ржкрзНрж░рж╛ржЗржо ржкрж╛ржЗ, check = true ржХрж░рзЗ break ржХрж░рж┐ред

cpp
Copy
Edit
        return check;
    }
};
ЁЯФ╣ рж╢рзЗрж╖рзЗ true/false рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рж▓рж╛ржоред

ЁЯФв ржЙржжрж╛рж╣рж░ржг ржжрж┐рзЯрзЗ ржХрзЛржб ржПржХрзНрж╕рж┐ржХрж┐ржЙрж╢ржи ржмрж┐рж╢рзНрж▓рзЗрж╖ржг:
Input: nums = [2,2,2,4,4]
ЁЯФ╕ ржлрзНрж░рж┐ржХрзЛрзЯрзЗржирзНрж╕рж┐ ржорзНржпрж╛ржк рж╣ржмрзЗ:

rust
Copy
Edit
2 -> 3
4 -> 2
ЁЯФ╕ CheckPrime(3): тЬЕ ржкрзНрж░рж╛ржЗржо
ЁЯФ╕ CheckPrime(2): тЬЕ ржкрзНрж░рж╛ржЗржо

ЁЯФ╕ ржпрзЗрж╣рзЗрждрзБ ржХржоржкржХрзНрж╖рзЗ ржПржХржЯрж┐рж░ ржлрзНрж░рж┐ржХрзЛрзЯрзЗржирзНрж╕рж┐ ржкрзНрж░рж╛ржЗржо, return true

тЬЕ ржХрзЗржи Accepted рж╣ржЪрзНржЫрзЗ?
рж╕ржорзЯ рж╕рзАржорж╛: O(n) ржорзНржпрж╛ржк рждрзИрж░рж┐ + O(тИЪm) ржкрзНрж░рж╛ржЗржо ржЪрзЗржХ = efficient

ржЗржиржкрзБржЯ constraint ржЫрзЛржЯ (100 ржПрж░ ржоржзрзНржпрзЗ), рждрж╛ржЗ brute-force check prime acceptable

unordered_map ржПрж░ ржХрж╛рж░ржгрзЗ ржлрзНрж░рж┐ржХрзЛрзЯрзЗржирзНрж╕рж┐ ржЦрзБржм рж╕рж╣ржЬрзЗ ржмрзЗрж░ ржХрж░рждрзЗ ржкрж╛рж░рж┐

Full Code:
------------

  class Solution 
{
public:
  bool CheckPrime(int n)
  {
    bool isprime=true;
    if(n<=1) 
    {
      isprime=false;
    }
    for(int i=2;i*i<=n;i++)
    {
      if(n%i==0)
      {
        isprime=false;
        break;
      }
    }
    return isprime;
  }
    bool checkPrimeFrequency(vector<int>& nums) 
    {
        bool check=false;
        unordered_map<int,int>freq;
        for(int i=0;i<nums.size();i++)
        {
          freq[nums[i]]++;
        }
        for(auto it:freq)
        {
          if(CheckPrime(it.second))
          {
            check=true;
            break;
          }
        }
        return check;
    }
};
