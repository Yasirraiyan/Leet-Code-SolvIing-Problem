নিচের কোডটি একটি বৈধ সমাধান যার মাধ্যমে একটি পূর্ণসংখ্যার অ্যারে থেকে সর্বাধিক ঘনঘটিত Even (জোড়) উপাদানটি বের করা হয়। যদি Tie (সমান ফ্রিকোয়েন্সি) থাকে, তবে সবচেয়ে ছোট উপাদানটি প্রদান করে; আর যদি কোনো Even উপাদান না থাকে তবে -1 ফেরত দেয়। বিস্তারিত ব্যাখ্যা নিচে:

কোড বিশ্লেষণ (Bangla):
Even সংখ্যা ফিল্টার: কোডের শুরুতে একট একটি vector<int> reserve তৈরি করা হয়েছে, যা শুধুমাত্র Even উপাদানগুলো সংরক্ষণ করবে।

cpp
vector<int> reserve;
for(int i = 0; i < nums.size(); i++)
{
    if(nums[i] % 2 == 0)
    {
        reserve.push_back(nums[i]);
    }
}
এখানে, অ্যারের প্রতিটি উপাদানের জন্য, যদি সংখ্যাটি 2 দিয়ে ভাগ দিলে রেমাইন্ডার 0 হয় (অর্থাৎ Even হয়) তবে সেটি reserve ভেক্টরে যোগ করা হয়।

Even সংখ্যা না থাকলে Return -1: পরবর্তীতে চেক করা হয়, যদি reserve ভেক্টর খালি হয়, অর্থাৎ অ্যারে-তে কোনো Even সংখ্যা না থাকে, তাহলে সরাসরি -1 রিটার্ন করে।

cpp
if(reserve.empty())
{
    return -1;
}
Frequency Map তৈরী: এখন Even সংখ্যা গুলো কতবার এসেছে তা গণনা করার জন্য একটি unordered_map<int,int> freq ব্যবহার করা হয়।

cpp
unordered_map<int, int> freq;
for(int j = 0; j < reserve.size(); j++)
{
    freq[reserve[j]]++;
}
এখানে, reserve-এর প্রতিটি উপাদানকে কী হিসেবে ব্যবহার করে তার ফ্রিকোয়েন্সি (যে কতবার সংখ্যা এসেছে) বাড়ানো হয়।

সর্বোচ্চ Frequency নির্ণয়: এরপর reserve ভেক্টরে থাকা প্রতিটি উপাদানের ফ্রিকোয়েন্সি যাচাই করে সর্বোচ্চ ফ্রিকোয়েন্সি max_count বের করা হয়।

cpp
int max_count = 0;
for(int k = 0; k < reserve.size(); k++)
{
    max_count = max(max_count, freq[reserve[k]]);
}
এই ধাপে, max_count তে পাওয়া হয় উক্ত Even সংখ্যাগুলির মধ্যে সবচেয়ে বেশিবার উপস্থিতির সংখ্যা।

সর্বোচ্চ Frequency এর Among Smallest Element নির্ণয়: এরপর আবার reserve ভেক্টর traverse করে, যেসব সংখ্যার ফ্রিকোয়েন্সি max_count এর সমান তাদের মধ্যে সবচেয়ে ছোট উপাদানটি ans এ রাখার জন্য চেক করা হয়।

cpp
int ans = -1;
for(int m = 0; m < reserve.size(); m++)
{
    if(freq[reserve[m]] == max_count)
    {
        if(ans == -1 || reserve[m] < ans)
        {
            ans = reserve[m];
        }
    }
}
এখানে, প্রথমে ans রূপে -1 দেওয়া হয়েছে (যেহেতু যদি কোনো উত্তর না থাকে তা ঘটলে -1 রিটার্ন করবে)। তারপর, যদি কোনো সংখ্যার ফ্রিকোয়েন্সি max_count এর সমান হয়, এবং:

যদি ans এখনও -1 বা

বর্তমান সংখ্যা ans থেকে ছোট,

তবে সেটিকে ans এ আপডেট করা হয়।

ফলাফল Return: অবশেষে, ans রিটার্ন করা হয় যা হল সবচেয়ে ঘনঘটিত Even উপাদান (Tie থাকলে সবচেয়ে ছোটটি)।

কেন এটাই Accepted Solution?
সঠিকভাবে Even ফিল্টারকরণ: প্রথমেই শুধুমাত্র Even সংখ্যাগুলোকে আলাদা করে নেয়ার ফলে বাকি Odd সংখ্যাগুলোর ব্যাপারে চিন্তা করা হয় না।

ফ্রিকোয়েন্সি ম্যাপ ব্যবহার: unordered_map ব্যবহার করে প্রতিটি Even সংখ্যার ফ্রিকোয়েন্সি রাখা হয়েছে যা O(n) সময়েও করা যায়।

দুই ধাপে ফলাফল নির্ণয়: প্রথমে সর্বোচ্চ ফ্রিকোয়েন্সি বের করা হয়েছে এবং পরে Tie থাকলে সবচেয়ে ছোট উপাদানটি চয়ন করা হয়েছে।

Edge Case Handle: যদি কোনো Even উপাদান না থাকে, সেটাও সঠিকভাবে Handle করে -1 রিটার্ন করা হয়।

এভাবে কোডটি প্রত্যাশিত সমাধান প্রদান করে এবং প্রতিটি পয়েন্ট অনুযায়ী কাজ করে, যা সমস্যার শর্তাবলী অনুযায়ী Accepted Solution।
