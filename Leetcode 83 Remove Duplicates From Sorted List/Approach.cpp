ЁЯФН ржкрзНрж░ржмрж▓рзЗржо ржмрзЛржЭрж╛:

Problem:

рждрзЛржорж╛ржХрзЗ ржПржХржЯрж┐ sorted linked list ржжрзЗржУрзЯрж╛ ржЖржЫрзЗ (ржорж╛ржирзЗ рж╕ржм ржнрзНржпрж╛рж▓рзБ increasing order ржП ржерж╛ржХржмрзЗ)ред рждрзЛржорж╛рж░ ржХрж╛ржЬ рж╣рж▓рзЛ рж╕рзЗржЗ list ржерзЗржХрзЗ duplicate elements ржЧрзБрж▓рзЛ ржорзБржЫрзЗ ржлрзЗрж▓рж╛, ржпрзЗржи ржкрзНрж░рждрж┐ржЯрж┐ ржнрзНржпрж╛рж▓рзБ ржПржХржмрж╛рж░ржЗ ржЖрж╕рзЗред

ржЙржжрж╛рж╣рж░ржг:

Input: [1,1,2] тЖТ Output: [1,2]

Input: [1,1,2,3,3] тЖТ Output: [1,2,3]



---

тЬЕ рждрзБржорж┐ ржпрзЗржнрж╛ржмрзЗ ржЪрж┐ржирзНрждрж╛ ржХрж░рзЗржЫрзЛ:

1. ржпрзЗрж╣рзЗрждрзБ ржПржЯрж╛ sorted list, рждрж╛ржЗ ржпржжрж┐ ржПржХрзЗрж░ ржкрж░ ржПржХ ржПржХржЗ ржнрзНржпрж╛рж▓рзБ ржкрж╛ржЗ, рждрж╛рж╣рж▓рзЗ рж╕рзЗржЯрж╛ duplicateред


2. ржХрж┐ржирзНрждрзБ рждрзБржорж┐ ржПржЦрж╛ржирзЗ ржнрж┐ржирзНржиржнрж╛ржмрзЗ ржЪрж┐ржирзНрждрж╛ ржХрж░рзЗржЫрзЛ тАФ ржкрзБрж░рзЛ рж▓рж┐рж╕рзНржЯрзЗрж░ ржнрзНржпрж╛рж▓рзБржЧрзБрж▓рзЛ ржЖржЧрзЗ vector ржП ржирж┐рзЯрзЗ ржЧрзЗрж▓рзЗ рж╕рж╣ржЬрзЗ duplicate detect ржХрж░рж╛ ржпрж╛рзЯред


3. рждрж╛рж░ржкрж░ unordered_map ржжрж┐рзЯрзЗ ржХрзЯржмрж╛рж░ ржЖрж╕ржЫрзЗ рж╕рзЗржЯрж╛ ржжрзЗржЦрзЗржЫрзЛред


4. рждрж╛рж░ржкрж░ рж╕рзЗржЯрж╛ржХрзЗ ржЖржмрж╛рж░ unique ржХрж░рзЗ sorted ржХрж░рзЗ linked list ржмрж╛ржирж┐рзЯрзЗржЫрзЛред



> тЬЕ ржпрзЗрж╣рзЗрждрзБ list ржЫрзЛржЯ (рзжтАУрзйрзжрзж), рждрзЛржорж╛рж░ ржПржЗ ржкржжрзНржзрждрж┐ Accepted рж╣рзЯрзЗржЫрзЗред




---

ЁЯФО ржХрзЛржб ржмрзНржпрж╛ржЦрзНржпрж╛ (Line by Line):

class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {

ЁЯСЙ ржПржЦрж╛ржирзЗ deleteDuplicates ржлрж╛ржВрж╢ржи рж╢рзБрж░рзБ, ржпрж╛ ржПржХржЯрж┐ рж▓рж┐ржВржХржб рж▓рж┐рж╕рзНржЯрзЗрж░ рж╣рзЗржб ржирзЗржмрзЗ ржПржмржВ ржбрзБржкрзНрж▓рж┐ржХрзЗржЯ ржЫрж╛рзЬрж╛ ржирждрзБржи рж╣рзЗржб рж░рж┐ржЯрж╛рж░рзНржи ржХрж░ржмрзЗред

vector<int> v;
        unordered_map<int,int> map1;
        vector<int> vv;

ЁЯСЙ v: ржкрзНрж░ржержорзЗ рж▓рж┐рж╕рзНржЯрзЗрж░ рж╕ржм ржнрзНржпрж╛рж▓рзБ рж░рж╛ржЦржмрзЗред
ЁЯСЙ map1: frequency ржХрж╛ржЙржирзНржЯ рж░рж╛ржЦржмрзЗ (ржХрзЯржмрж╛рж░ ржПрж╕рзЗржЫрзЗ)ред
ЁЯСЙ vv: рж╢рзБржзрзБ unique ржнрзНржпрж╛рж▓рзБ рж░рж╛ржЦржмрзЗред

while(head != nullptr) {
            v.push_back(head->val);
            head = head->next;
        }

ЁЯСЙ ржПржЦрж╛ржирзЗ head ржерзЗржХрзЗ ржпрждржЧрзБрж▓рзЛ ржнрзНржпрж╛рж▓рзБ ржЖржЫрзЗ, рж╕ржм v рждрзЗ ржврзЛржХрж╛ржирзЛ рж╣рзЯрзЗржЫрзЗред

for(int i = 0; i < v.size(); i++) {
            map1[v[i]]++;
        }

ЁЯСЙ ржПржЦржи unordered_map ржП рж╕ржм ржнрзНржпрж╛рж▓рзБрж░ count рж░рж╛ржЦрж╛ рж╣рзЯрзЗржЫрзЗред

for(auto it: map1) {
            vv.push_back(it.first);
        }

ЁЯСЙ ржпрзЗрж╣рзЗрждрзБ ржЖржорж╛ржжрзЗрж░ ржжрж░ржХрж╛рж░ рж╢рзБржзрзБ unique ржЧрзБрж▓рж╛, map ржПрж░ key (ржнрзНржпрж╛рж▓рзБ) ржЧрзБрж▓рзЛ ржирж┐рзЯрзЗ vv рждрзЗ ржврзЛржХрж╛ржирзЛ рж╣рзЯрзЗржЫрзЗред

sort(vv.begin(), vv.end());

ЁЯСЙ ржпрзЗрж╣рзЗрждрзБ unordered_map ржП ржЕрж░рзНржбрж╛рж░ ржерж╛ржХрзЗ ржирж╛, ржЖржорж░рж╛ ржЖржмрж╛рж░ sort ржХрж░рзЗ ascending order ржарж┐ржХ ржХрж░рзЗ ржирж┐рзЯрзЗржЫрж┐ред

if(vv.size() == 0) {
            return nullptr;
        }

ЁЯСЙ ржпржжрж┐ рж▓рж┐рж╕рзНржЯ ржлрж╛ржБржХрж╛ ржерж╛ржХрзЗ, рждрж╛рж╣рж▓рзЗ рж╕рж░рж╛рж╕рж░рж┐ null рж░рж┐ржЯрж╛рж░рзНржи ржХрж░ржЫрж┐ред

ListNode* headd = new ListNode(vv[0]);
        ListNode* current = headd;

ЁЯСЙ ржирждрзБржи рж▓рж┐ржВржХржб рж▓рж┐рж╕рзНржЯ ржмрж╛ржирж╛ржЪрзНржЫрж┐ vv ржПрж░ ржкрзНрж░ржержо ржнрзНржпрж╛рж▓рзБ ржжрж┐рзЯрзЗред

for(int j = 1; j < vv.size(); j++) {
            current->next = new ListNode(vv[j]);
            current = current->next;
        }

ЁЯСЙ ржПржЦржи vv ржПрж░ ржмрж╛ржХрж┐ ржнрзНржпрж╛рж▓рзБржЧрзБрж▓рж╛ ржжрж┐рзЯрзЗ ржмрж╛ржХрж┐ рж▓рж┐рж╕рзНржЯ ржмрж╛ржирж╛ржирзЛ рж╣ржЪрзНржЫрзЗред

return headd;
    }
};

ЁЯСЙ рж╢рзЗрж╖рзЗ ржирждрзБржи рж▓рж┐рж╕рзНржЯрзЗрж░ head рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рж╛ рж╣ржЪрзНржЫрзЗред


---

ЁЯзк ржЯрзЗрж╕рзНржЯ ржХрзЗрж╕ ржжрж┐рзЯрзЗ ржзрж╛ржкрзЗ ржзрж╛ржкрзЗ ржмрзНржпрж╛ржЦрзНржпрж╛:

ржЙржжрж╛рж╣рж░ржг:

Input: head = [1,1,2,3,3]

Step 1: v = [1,1,2,3,3]

Step 2: map1 = {1:2, 2:1, 3:2}

Step 3: vv = [1,2,3]

Step 4: sort тЖТ vv = [1,2,3]

Step 5: ржирждрзБржи рж▓рж┐рж╕рзНржЯ тЖТ 1 -> 2 -> 3 тЬЕ



---

тЭУ ржХрзЗржи рждрзЛржорж╛рж░ ржХрзЛржб Accepted рж╣рж▓рзЛ?

рж▓ржЬрж┐ржХ ржарж┐ржХ ржЫрж┐рж▓рзЛред

ржЗржиржкрзБржЯ рж╕рж╛ржЗржЬ ржЫрзЛржЯ ржЫрж┐рж▓рзЛ (max 300), рждрж╛ржЗ ржЕрждрж┐рж░рж┐ржХрзНржд ржорзЗржорзЛрж░рж┐ ржмрж╛ ржЯрж╛ржЗржо ржХрзЛржирзЛ issue рж╣рзЯржирж┐ред

рждрзБржорж┐ ржХрж╛ржЬ ржХрж░рзЗржЫрзЛ simple data structure ржжрж┐рзЯрзЗ (vector, map), рждрж╛ржЗ ржХрзЛржб readable ржПржмржВ efficientред



---

тЬЕ ржнржмрж┐рж╖рзНржпрждрзЗ рждрзБржорж┐ ржХрж┐ржнрж╛ржмрзЗ ржПржЗ ржХрзЛржб ржоржирзЗ рж░рж╛ржЦржмрзЗ?

рж╕ржВржХрзНрж╖рзЗржкрзЗ ржоржирзЗ рж░рж╛ржЦрж╛рж░ ржЬржирзНржп ржзрж╛ржк:

1. рж▓рж┐рж╕рзНржЯ ржерзЗржХрзЗ ржнрзНржпрж╛рж▓рзБ ржЧрзБрж▓рзЛ vector-ржП ржирж╛ржУ


2. map ржжрж┐рзЯрзЗ unique ржмрзЗрж░ ржХрж░рзЛ


3. sort ржХрж░рзЗ ржирждрзБржи рж▓рж┐рж╕рзНржЯ ржмрж╛ржирж╛ржУ




---
Full Code:
---_-------

  class Solution 
{
public:
    ListNode* deleteDuplicates(ListNode* head) 
    {
        
    vector<int> v;
        unordered_map<int,int>map1;
        vector<int>vv;
        while(head!=nullptr)
            {
                v.push_back(head->val);
                head=head->next;
            }
        for(int i=0;i<v.size();i++)
            {
                map1[v[i]]++;
            }
        for(auto it:map1)
            {
                vv.push_back(it.first);
            }
      sort(vv.begin(),vv.end());
        if(vv.size()==0)
        {
            return nullptr;
        }
        ListNode* headd=new ListNode(vv[0]);
       ListNode* current=headd;
        for(int j=1;j<vv.size();j++)
            {
            current->next=new ListNode(vv[j]);
              current=current->next;
            }
        return headd;
    }
};

// Utility function to create a linked list from vector


// Utility function to print linked list
