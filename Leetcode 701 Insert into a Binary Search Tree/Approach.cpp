ЁЯФ╢ ржкрзНрж░рж╢рзНржи ржмрж┐рж╢рзНрж▓рзЗрж╖ржг (Understanding the Problem)
рждрзЛржорж╛ржХрзЗ ржПржХржЯрж┐ BST (Binary Search Tree) ржПрж░ root ржжрзЗржУрзЯрж╛ ржЖржЫрзЗ ржПржмржВ ржПржХржЯрж┐ ржирждрзБржи val ржжрзЗржУрзЯрж╛ ржЖржЫрзЗ ржпрзЗржЯрж╛ BST-рждрзЗ ржЗржирж╕рж╛рж░рзНржЯ ржХрж░рждрзЗ рж╣ржмрзЗред BST-рж░ ржкрзНрж░ржкрж╛рж░рзНржЯрж┐ рж╣ржЪрзНржЫрзЗ:

ржмрж╛ржо ржкрж╛рж╢рзЗ рж╕ржм ржирзЛржбрзЗрж░ ржнрзНржпрж╛рж▓рзБ ржЫрзЛржЯ рж╣рзЯред

ржбрж╛ржи ржкрж╛рж╢рзЗ рж╕ржм ржирзЛржбрзЗрж░ ржнрзНржпрж╛рж▓рзБ ржмрзЬ рж╣рзЯред

ЁЯСЙ ржЖржорж╛ржжрзЗрж░ ржХрж╛ржЬ рж╣рж▓рзЛ рж╕рзЗржЗ ржирждрзБржи ржнрзНржпрж╛рж▓рзБржЯрж╛ ржПржоржиржнрж╛ржмрзЗ ржЗржирж╕рж╛рж░рзНржЯ ржХрж░рж╛ ржпрж╛рждрзЗ BST ржПрж░ ржмрзИрж╢рж┐рж╖рзНржЯрзНржп ржарж┐ржХ ржерж╛ржХрзЗред

ЁЯФ╖ рж╕ржорж╛ржзрж╛ржи ржнрж╛ржмржирж╛ (Approach to Think the Solution)
ржкрзНрж░рж╢рзНржиржЯрж╛ ржкрзЬрзЗржЗ рждрзБржорж┐ ржнрж╛ржмрждрзЗ ржкрж╛рж░рзЛ:

BST-рждрзЗ ржирждрзБржи ржорж╛ржи ржврзЛржХрж╛рждрзЗ ржЧрзЗрж▓рзЗ ржХрзЛржерж╛рзЯ ржврзБржХржмрзЗ рж╕рзЗржЯрж╛ ржирж┐рж░рзНржзрж╛рж░ржг ржХрж░рждрзЗ рж╣рзЯред

ржпржжрж┐ val < root->val рж╣рзЯ, рждрж╛рж╣рж▓рзЗ ржмрж╛ржо ржжрж┐ржХрзЗ ржпрж╛ржмрзЗред

ржпржжрж┐ val > root->val рж╣рзЯ, рждрж╛рж╣рж▓рзЗ ржбрж╛ржи ржжрж┐ржХрзЗ ржпрж╛ржмрзЗред

ржпрждржХрзНрж╖ржг ржирж╛ null ржкрж╛ржмрзЗ, traversal ржХрж░рзЗ ржпрзЗрждрзЗ рж╣ржмрзЗред

null ржкрж╛ржУрзЯрж╛ ржорж╛рждрзНрж░, рж╕рзЗржЦрж╛ржирзЗржЗ ржирждрзБржи TreeNode(val) ржЗржирж╕рж╛рж░рзНржЯ ржХрж░ржмрзЗред

тЬЕ Recursion ржжрж┐рзЯрзЗ ржЦрзБржм рж╕рж╣ржЬрзЗ ржХрж░рж╛ ржпрж╛рзЯ, ржХрж╛рж░ржг ржкрзНрж░рждрж┐ржЯрж╛ рж╕рж╛ржмржЯрзНрж░рж┐ржУ рждрзЛ ржирж┐ржЬрзЗ ржПржХржЯрж╛ BSTред

тЬЕ ржХрзЛржб ржмрзНржпрж╛ржЦрзНржпрж╛ (Line-by-Line Explanation in Bangla)
cpp
Copy
Edit
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) 
    {
        // Step 1: ржпржжрж┐ рж░рзБржЯ ржлрж╛ржБржХрж╛ рж╣рзЯ, ржирждрзБржи ржирзЛржб ржмрж╛ржирж┐рзЯрзЗ рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рзЛ
        if (!root) return new TreeNode(val);

        // Step 2: ржпржжрж┐ ржнрзНржпрж╛рж▓рзБ ржмрзЬ рж╣рзЯ рж░рзБржЯ ржерзЗржХрзЗ, рждрж╛рж╣рж▓рзЗ ржбрж╛ржирзЗ ржпрж╛ржмрзЗ
        if (root->val < val)
        {
            // рж░рж┐ржХрж╛рж░рж╕рж┐ржнржнрж╛ржмрзЗ ржбрж╛ржирзЗ ржЗржирж╕рж╛рж░рзНржЯ ржХрж░рзЛ
            root->right = insertIntoBST(root->right, val);
        }

        // Step 3: ржпржжрж┐ ржнрзНржпрж╛рж▓рзБ ржЫрзЛржЯ рж╣рзЯ рж░рзБржЯ ржерзЗржХрзЗ, рждрж╛рж╣рж▓рзЗ ржмрж╛ржБрзЯрзЗ ржпрж╛ржмрзЗ
        else if (root->val > val)
        {
            // рж░рж┐ржХрж╛рж░рж╕рж┐ржнржнрж╛ржмрзЗ ржмрж╛ржБрзЯрзЗ ржЗржирж╕рж╛рж░рзНржЯ ржХрж░рзЛ
            root->left = insertIntoBST(root->left, val);
        }

        // Step 4: рж░рзБржЯ рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рзЛ ржпрж╛рждрзЗ parent subtree ржарж┐ржХ ржерж╛ржХрзЗ
        return root;
    }
};
ЁЯзк ржЯрзЗрж╕рзНржЯ ржХрзЗрж╕ ржзрж░рзЗ ржмрзНржпрж╛ржЦрзНржпрж╛ (Example Walkthrough)
тЮд Example 1:
sql
Copy
Edit
Input: root = [4,2,7,1,3], val = 5
BST tree:
       4
      / \
     2   7
    / \
   1   3
Insert 5 тЖТ Goes to right of 4 тЖТ left of 7 тЖТ Insert at left of 7

Output: [4,2,7,1,3,5]
Traversal:

5 > 4 тЖТ go right (7)

5 < 7 тЖТ go left тЖТ left child is null тЖТ insert new node(5)

тЬЕ ржХрзЗржи ржПржЗ ржХрзЛржб Accepted рж╣рж▓рзЛ? (Why is it Accepted?)
BST insertion-ржПрж░ рж░рж┐ржХрж╛рж░рж╕рж┐ржн рж░рзБрж▓ ржорзЗржирзЗ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред

nullptr ржкрзЗрж▓рзЗ ржирждрзБржи TreeNode(val) рждрзИрж░рж┐ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред

Time Complexity: O(log n) (average BST height)

Space Complexity: O(h), h = height of tree (due to recursion stack)

ЁЯУМ рждрзЛржорж╛рж░ ржирж┐ржЬрзЗрж░ ржЪрж┐ржирзНрждрж╛ ржХрж┐ржнрж╛ржмрзЗ ржЧржаржи ржХрж░ржмрзЗ? (How to Think This Yourself)
ржкрзНрж░рж╢рзНржирзЗ ржмрж▓рж╛ рж╣ржЪрзНржЫрзЗ BST, рждрж╛ржЗ ржЗржиржЕрж░рзНржбрж╛рж░ рж░рзБрж▓ ржоржирзЗ рж░рж╛ржЦрзЛред

рж░рж┐ржХрж╛рж░рж╕рж┐ржн ржнрж╛ржмрзЛ тАУ ржпрзЗ рж╕рж╛ржмржЯрзНрж░рж┐ ржЗржирж╕рж╛рж░рзНржЯ ржХрж░рж╛рж░ ржкрж░ ржЖржмрж╛рж░ ржорзВрж▓ ржЯрзНрж░рж┐ ржарж┐ржХржорждрзЛ ржЧрзЬржмрзЗред

Null ржкрзЗрж▓рзЗ ржирждрзБржи ржирзЛржб рждрзИрж░рж┐ ржХрж░рзЗ ржлрж┐рж░рзЗ ржЖрж╕ржмрзЗред

Insertion ржорж╛ржирзЗ ржПржХржжржо ржкрж╛рждрж╛ рж▓рзЗржнрзЗрж▓рзЗ ржврзБржХрж╛ржирзЛ, рждрж╛ржЗ recursion ржнрж╛рж▓рзЛржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░ржмрзЗред

ЁЯФБ ржЖрж░рзЛ ржПржХржЯрж┐ ржЙржжрж╛рж╣рж░ржг ржкрж░рзАржХрзНрж╖рж╛ ржХрж░рзЗ ржжрзЗржЦрж┐
тЮд Example 2:
sql
Copy
Edit
Input: root = [40,20,60,10,30,50,70], val = 25
BST:

        40
       /  \
     20    60
    / \    / \
  10  30  50 70

Insert 25:
тЖТ 25 < 40 тЖТ go left (20)
тЖТ 25 > 20 тЖТ go right (30)
тЖТ 25 < 30 тЖТ go left of 30 (null) тЖТ insert here

Final BST:
        40
       /  \
     20    60
    / \    / \
  10  30  50 70
      /
    25
ЁЯФЪ рж╢рзЗрж╖ ржХржерж╛ (Summary)
ржкрзНрж░рж╢рзНржи ржмрзБржЭрзЗ ржирж╛ржУ BST ржЗржирж╕рж╛рж░рзНржЯ ржХрж░рждрзЗ рж╣рж▓рзЗ ржХрзА ржХрж░рждрзЗ рж╣рзЯред

ржирждрзБржи ржнрзНржпрж╛рж▓рзБржЯрж╛ ржХрж┐рж╕рзЗрж░ ржерзЗржХрзЗ ржЫрзЛржЯ ржмрж╛ ржмрзЬ рж╕рзЗржЯрж╛ ржжрзЗржЦрзЗ рж░рж┐ржХрж╛рж░рж╕рж┐ржн traversal ржХрж░рзЛред

null ржкрзЗрж▓рзЗ insert ржХрж░рзЗ ржлрж┐рж░рзЗ ржЖрж╕рзЛред

ржкрзБрж░рзЛ ржХрзЛржб рж░рж┐ржХрж╛рж░рж╕рж┐ржнржнрж╛ржмрзЗ root ржарж┐ржХ рж░рзЗржЦрзЗ ржирждрзБржи рж╕рж╛ржмржЯрзНрж░рж┐рж░ pointer рж╕рзЗржЯ ржХрж░рзЗ ржжрзЗрзЯред

Full Code:
-----------


 * Definition for a binary tree node.
 * struct TreeNode
  {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };

class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) 
    {
      if(!root) return new TreeNode(val);
     
          if(root->val<val)
          {
           root->right= insertIntoBST(root->right,val);
          } 
          if(root->val>val)
          {
           root->left= insertIntoBST(root->left,val);
          }
          return root;
    }
};
