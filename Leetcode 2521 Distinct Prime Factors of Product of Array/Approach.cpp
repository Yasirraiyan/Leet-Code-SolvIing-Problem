‚úÖ üî∂‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ (Problem Analysis in Bangla)

üî∏ Problem:

‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶ï‡¶æ‡¶õ‡ßá ‡¶è‡¶ï‡¶ü‡¶ø nums array ‡¶Ü‡¶õ‡ßá, ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶ï‡¶ø‡¶õ‡ßÅ positive integer ‡¶Ü‡¶õ‡ßá‡•§ ‡¶è‡¶ñ‡¶® ‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶ï‡¶æ‡¶ú ‡¶π‡¶≤‡ßã,

> nums ‡¶è‡¶∞ ‡¶∏‡¶¨ ‡¶è‡¶≤‡¶ø‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∞ ‡¶ó‡ßÅ‡¶£‡¶´‡¶≤‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶ï‡¶§‡¶ó‡ßÅ‡¶≤‡ßã ‡¶≠‡¶ø‡¶®‡ßç‡¶® ‡¶≠‡¶ø‡¶®‡ßç‡¶® (distinct) ‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶Æ ‡¶´‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶ü‡¶∞ (prime factor) ‡¶Ü‡¶õ‡ßá ‡¶∏‡ßá‡¶ü‡¶æ ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ‡•§




---

‚úÖ üî∂Solution Approach Step-by-Step (Bangla + Math)

üîπ Step 1: Observation

‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶™‡ßÅ‡¶∞‡ßã array nums = [a1, a2, a3, ..., an] ‡¶è‡¶∞ product ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡ßã P = a1 √ó a2 √ó a3 √ó ... √ó an‡•§

‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶ú‡¶æ‡¶®‡¶ø, ‡¶Ø‡¶¶‡¶ø P ‡¶è‡¶∞ ‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶Æ ‡¶´‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶ü‡¶∞ ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶ø, ‡¶§‡¶æ‡¶π‡¶≤‡ßá ‡¶∏‡ßá‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá‡¶á ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶≤‡ßÅ‡¶ï‡¶ø‡ßü‡ßá ‡¶Ü‡¶õ‡ßá‡•§

‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶è‡¶ï‡¶ü‡¶æ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‡¶∞ ‡¶ï‡¶•‡¶æ ‡¶Æ‡¶æ‡¶•‡¶æ‡¶Ø‡¶º ‡¶∞‡¶æ‡¶ñ‡¶§‡ßá ‡¶π‡¶¨‡ßá:

> Constraint: 1 <= nums.length <= 10‚Å¥ ‡¶è‡¶¨‡¶Ç 2 <= nums[i] <= 1000



‡¶§‡¶æ‡¶π‡¶≤‡ßá ‡¶Ø‡¶¶‡¶ø ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶∏‡¶¨‡¶ó‡ßÅ‡¶≤‡ßã ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶∞ ‡¶ó‡ßÅ‡¶£‡¶´‡¶≤ ‡¶®‡ßá‡¶á, ‡¶∏‡ßá‡¶ü‡¶ø ‡¶π‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá ‡¶Ö‡¶®‡ßá‡¶ï ‡¶¨‡¶°‡¶º, ‡¶Ø‡ßá‡¶Æ‡¶® 1000^10000 = huge!
üëâ So we cannot compute the full product. ‡¶§‡¶æ‡¶á ‡¶∏‡¶∞‡¶æ‡¶∏‡¶∞‡¶ø product ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶≤‡ßá overflow ‡¶π‡¶¨‡ßá‡•§


---

üîπ Step 2: Clever Idea üí°

‡¶Ü‡¶Æ‡¶∞‡¶æ nums ‡¶è‡¶∞ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶∞ prime factor individually ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶¨‡ßã, ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ ‡¶Ø‡ßá‡¶ó‡ßÅ‡¶≤‡ßã unique ‡¶∏‡ßá‡¶ó‡ßÅ‡¶≤‡ßã count ‡¶ï‡¶∞‡¶¨‡ßã‡•§

üîë ‡¶è‡¶á‡¶≠‡¶æ‡¶¨‡ßá:

‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶æ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶∞ prime factor ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡ßã‡•§

‡¶è‡¶ï‡¶ü‡¶æ unordered_set<int>-‡¶è ‡¶∏‡ßá‡¶á ‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶Æ ‡¶´‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶ü‡¶∞ ‡¶∞‡¶æ‡¶ñ‡ßã ‡¶Ø‡¶æ‡¶§‡ßá ‡¶è‡¶ï‡¶á ‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶Æ ‡¶¨‡¶æ‡¶∞‡¶¨‡¶æ‡¶∞ ‡¶®‡¶æ ‡¶Ü‡¶∏‡ßá‡•§

‡¶∂‡ßá‡¶∑‡ßá ‡¶∏‡ßá‡¶ü‡¶æ‡¶∞ size ‡¶´‡ßá‡¶∞‡¶§ ‡¶¶‡¶æ‡¶ì (‡¶Æ‡¶æ‡¶®‡ßá ‡¶ï‡¶§‡¶ó‡ßÅ‡¶≤‡ßã unique prime factor ‡¶Ü‡¶õ‡ßá)‡•§



---

‚úÖ üî∂Mathematical Example:

Suppose: nums = [2, 4, 3, 7, 10, 6]

‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶æ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶Æ ‡¶´‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶ü‡¶∞:

2 => [2]
4 => [2]
3 => [3]
7 => [7]
10 => [2, 5]
6 => [2, 3]

Union of all prime factors = {2, 3, 5, 7} => total 4 distinct primes

So, output = 4 ‚úÖ


---

‚úÖ üî∂Line-by-line Code Explanation in Bangla:

class Solution 
{
public:


---

üî∏ Helper Function 1: Factors(int n)

vector<int>Factors(int n)
{
  vector<int>v;
  for(int i=1;i<=n;i++)
  {
    if(n%i==0)
    {
      v.push_back(i); // n ‡¶è‡¶∞ ‡¶Ø‡ßá‡¶∏‡¶¨ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡ßü ‡¶≠‡¶æ‡¶ó ‡¶Ø‡¶æ‡¶Ø‡¶º (‡¶Æ‡¶æ‡¶®‡ßá factor), ‡¶∏‡ßá‡¶ó‡ßÅ‡¶≤‡ßã ‡¶∏‡¶Ç‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡¶õ‡¶ø
    }
  }
  return v;
}

‚û°Ô∏è ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶è‡¶Æ‡¶® ‡¶∏‡¶¨ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶ï‡ßá ‡¶®‡¶ø‡¶ö‡ßç‡¶õ‡ßã ‡¶Ø‡ßá‡¶ó‡ßÅ‡¶≤‡ßã n ‡¶è‡¶∞ factor (‡¶≠‡¶æ‡¶ó ‡¶Ø‡¶æ‡¶Ø‡¶º)‡•§ ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶∂‡ßÅ‡¶ß‡ßÅ factor ‡¶ú‡¶æ‡¶®‡¶≤‡ßá ‡¶π‡¶¨‡ßá ‡¶®‡¶æ, ‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá prime factor‡•§


---

üî∏ Helper Function 2: TestPrime(int n)

bool TestPrime(int n)
{
  if(n<2) return false; // 0 ‡¶è‡¶¨‡¶Ç 1 ‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶Æ ‡¶®‡¶æ
  for(int j=2;j*j<=n;j++)
  {
    if(n%j==0)
    {
       return false;
    }
  }
  return true; // ‡¶ï‡ßã‡¶® ‡¶≠‡¶æ‡¶ó ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø ‡¶Æ‡¶æ‡¶®‡ßá ‡¶è‡¶ü‡¶æ ‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶Æ
}

‚û°Ô∏è ‡¶è‡¶ü‡¶æ ‡¶¶‡¶ø‡ßü‡ßá ‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶Ø‡¶æ‡¶ö‡¶æ‡¶á ‡¶ï‡¶∞‡¶õ‡ßã ‡¶è‡¶ï‡¶ü‡¶æ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶Æ ‡¶ï‡¶ø‡¶®‡¶æ‡•§


---

üî∏ Main Function: distinctPrimeFactors

int distinctPrimeFactors(vector<int>& nums) 
{
    unordered_set<int>set1; // unique factor ‡¶∞‡¶æ‡¶ñ‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø
    unordered_map<int,int>freq; // ‡¶ï‡ßã‡¶® ‡¶ï‡ßã‡¶® ‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶Æ ‡¶´‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶ü‡¶∞ ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶ó‡ßá‡¶õ‡ßá ‡¶∏‡ßá‡¶ü‡¶æ ‡¶Æ‡¶®‡ßá ‡¶∞‡¶æ‡¶ñ‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø

for(int k=0;k<nums.size();k++)
    {
        vector<int> vv=Factors(nums[k]); // nums[k] ‡¶è‡¶∞ ‡¶∏‡¶¨ factor ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶≤‡¶æ‡¶Æ
        for(int j=0;j<vv.size();j++)
        {
            set1.insert(vv[j]); // ‡¶∏‡¶¨ factor set-‡¶è ‡¶¢‡ßÅ‡¶ï‡¶ø‡¶Ø‡¶º‡ßá ‡¶¶‡¶ø‡¶≤‡¶æ‡¶Æ
        }
    }

‚û°Ô∏è ‡¶â‡¶™‡¶∞‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶æ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶∞ factor ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡ßá set1 ‡¶è ‡¶¢‡ßÅ‡¶ï‡¶ø‡¶Ø‡¶º‡ßá ‡¶¶‡¶ø‡¶≤‡¶æ‡¶Æ‡•§ ‡¶è‡¶ñ‡¶® set1 ‡¶è ‡¶∏‡¶¨ ‡¶∞‡¶ï‡¶Æ‡ßá‡¶∞ factor ‡¶Ü‡¶õ‡ßá, including non-primes.


---

vector<int>r;
    for(auto it:set1)
    {
        if(TestPrime(it))
        {
            freq[it]++; // ‡¶Ø‡¶¶‡¶ø ‡¶ï‡ßã‡¶®‡ßã factor ‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶Æ ‡¶π‡¶Ø‡¶º, ‡¶∏‡ßá‡¶ü‡¶æ‡¶∞ ‡¶ó‡¶®‡¶®‡¶æ ‡¶ï‡¶∞‡ßã
        }
    }

‚û°Ô∏è ‡¶è‡¶ñ‡¶æ‡¶®‡ßá set1 ‡¶•‡ßá‡¶ï‡ßá ‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶Æ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶õ‡¶æ‡¶Å‡¶ï‡¶õ‡¶ø, ‡¶è‡¶¨‡¶Ç freq map ‡¶è ‡¶∞‡¶æ‡¶ñ‡¶õ‡¶ø‡•§


---

for(auto it:freq)
    {
        r.push_back(it.first); // freq-‡¶è ‡¶Ø‡ßá‡¶∏‡¶¨ ‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶Æ ‡¶Ü‡¶õ‡ßá, ‡¶∏‡ßá‡¶ó‡ßÅ‡¶≤‡ßã r ‡¶§‡ßá ‡¶∞‡¶æ‡¶ñ‡¶õ‡¶ø
    }
    return r.size(); // ‡¶≠‡¶ø‡¶®‡ßç‡¶® ‡¶≠‡¶ø‡¶®‡ßç‡¶® ‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶Æ ‡¶´‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶ü‡¶∞ ‡¶è‡¶∞ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ
}


---

‚úÖ üî∂Output Explanation:

Example 1:

Input: [2,4,3,7,10,6]
Product = 2 √ó 4 √ó 3 √ó 7 √ó 10 √ó 6 = 10080
Prime Factors = {2, 3, 5, 7}
Output = 4

Example 2:

Input: [2,4,8,16]
Product = 1024 = 2^10
Prime Factors = {2}
Output = 1


---

Full Code:
------------

  class Solution 
{
public:
vector<int>Factors(int n)
{
  vector<int>v;
  for(int i=1;i<=n;i++)
  {
    if(n%i==0)
    {
      v.push_back(i);
    }
  }
  return v;
}
bool TestPrime(int n)
{
  if(n<2) return false;
  bool test=true;
  for(int j=2;j*j<=n;j++)
  {
    if(n%j==0)
    {
       test=false;
       break;
    }
  }
  return test;
}
    int distinctPrimeFactors(vector<int>& nums) 
{
        unordered_set<int>set1;
        unordered_map<int,int>freq;
        for(int k=0;k<nums.size();k++)
        {
   vector<int> vv=Factors(nums[k]);
            for(int j=0;j<vv.size();j++)
        {
            set1.insert(vv[j]);
        }
        }
        int count=0;
        vector<int>r;
        for(auto it:set1)
            {
                if(TestPrime(it))
                    {
                        freq[it]++;
                    }
            }
        for(auto it:freq)
            {
                r.push_back(it.first);
            }
        count=r.size();
        return count;
    }
}; 
 
