Amar একটি সংখ্যা অ্যারে (nums) দেওয়া থাকলে, নির্দিষ্ট left এবং right ইনডেক্সের মধ্যে থাকা সংখ্যাগুলোর যোগফল বের করতে হবে।

আপনার দেওয়া সমাধানটি একটি ব্রুট-ফোর্স অ্যাপ্রোচ, যেখানে প্রতিবার sumRange(left, right) ফাংশন কল করা হলে, left থেকে right পর্যন্ত লুপ চালিয়ে সংখ্যাগুলো যোগ করা হয়।

এই পদ্ধতির কাজের ধাপ:
NumArray ক্লাস তৈরি করা হয়েছে যেখানে একটি vector<int> nums নামে ভেরিয়েবল আছে, যা ইনপুট অ্যারেটি সংরক্ষণ করে।

sumRange(left, right) ফাংশন:

প্রথমে sum নামে একটি ভেরিয়েবল নেওয়া হয়েছে, যার প্রাথমিক মান ০।

left থেকে right পর্যন্ত লুপ চালিয়ে nums[i] গুলো যোগ করা হচ্ছে।

শেষে sum ফেরত দেওয়া হচ্ছে।

সমস্যার বিশ্লেষণ:
এই অ্যাপ্রোচটি O(n) টাইম কমপ্লেক্সিটি রাখে, যেহেতু প্রতিবার লুপ চালিয়ে নতুন করে যোগফল নির্ধারণ করা হচ্ছে।

এটি ছোট ইনপুটের জন্য ভালো কাজ করবে, কিন্তু যদি প্রচুর sumRange(left, right) কল থাকে, তাহলে এটি ধীর গতির হতে পারে।


  Why Brute Force:
------------------
  Brute Force বলতে বুঝানো হয় সরাসরি, সকল সম্ভাব্য উপায়ে সমস্যার সমাধান খোঁজার একটি পদ্ধতি। এটি সহজেই বোঝা যায়, তবে অনেক সময় অপ্টিমাইজড নয় এবং ধীরগতির হতে পারে।

Brute Force পদ্ধতি কীভাবে কাজ করে?
Brute Force সাধারণত সমস্ত সম্ভাব্য সমাধান পরীক্ষা করে এবং সঠিক উত্তর বের করে। এটি কোনো স্মার্ট কৌশল ব্যবহার না করে সরাসরি লুপ চালিয়ে বা সমস্ত উপায় চেষ্টা করে উত্তর বের করে।

NumArray ক্লাসে Brute Force কেন?
আপনার দেওয়া sumRange(left, right) ফাংশনটি প্রতিবার লুপ চালিয়ে left থেকে right পর্যন্ত সকল সংখ্যা যোগ করছে। অর্থাৎ:

প্রতিবার sumRange(left, right) কল হলে, নতুন করে পুরো লুপ চালিয়ে যোগফল বের করা হচ্ছে।

যদি অনেকবার sumRange কল করা হয় (১০,০০০ বার পর্যন্ত অনুমতি আছে), তবে এটি ধীরগতি হয়ে যাবে।

যেহেতু আমরা প্রতিবার নতুন করে গুণ-যোগ করছি, তাই এটি Brute Force অ্যাপ্রোচ।
