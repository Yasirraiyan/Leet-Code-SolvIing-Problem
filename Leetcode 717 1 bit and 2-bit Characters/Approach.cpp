প্রশ্নের বিশ্লেষণ (Problem Understanding)

আমাদের দুই ধরনের চর আছে:

এক-বিট চর → 0

দুই-বিট চর → 10 বা 11

আমাদের একটি বাইনারি অ্যারে bits দেওয়া আছে যা শেষে 0 দিয়ে শেষ হয়।

আমাদের ফলাফল বের করতে হবে:

শেষ চরটি এক-বিট চর কি না।

উদাহরণ:

[1,0,0] → প্রথম দুইটা 10 (দুই-বিট), শেষটা 0 → সত্য।

[1,1,1,0] → প্রথম দুইটা 11 (দুই-বিট), শেষটা আরেকটা 10 (দুই-বিট) → মিথ্যা।

এখানে মূল ধারণা: যদি শেষ 0 কোন দুই-বিট চর এর অংশ হয়, তাহলে এটি এক-বিট চর নয়।

কোডের লজিক (Solution Approach)
int slow=0;
int fast=0;
bool one=false;


আমরা slow দিয়ে অ্যারেতে চলব।

fast এখানে ব্যবহার করা হয়েছে কিন্তু আসলে কোডে কাজ করছে না → এটি অপ্রয়োজনীয়।

one → শেষ চর এক-বিট কিনা ট্র্যাক করার জন্য।

while(slow < bits.size() && fast < bits.size())


আমরা অ্যারের শেষ পর্যন্ত যাচ্ছি।

fast ব্যবহার না করলেও সমস্যা নেই। মূল কাজ হচ্ছে slow দিয়ে ট্রাভার্স করা।

if(bits[slow]==1)
{
    slow+=2;
}


যদি 1 হয় → এটি দুই-বিট চর এর শুরু, তাই আমরা দুই ধাপ এগাই।

উদাহরণ: [1,0,...] → একসাথে 10 ধরি, slow+=2।

else if(bits[slow]==0 && slow < bits.size()-1)
{
    slow++;
}


যদি 0 হয় → এটি এক-বিট চর।

আমরা শুধুমাত্র তখনই 1 ধাপ এগাই যখন এটি শেষ নয়, কারণ শেষ 0 আমরা আলাদা চেক করব।

if(slow == bits.size()-1 && bits[slow]==0)
{
    one=true;
    break;
}


যদি slow পৌঁছায় শেষ ইন্ডেক্সে এবং এটি 0 → আমাদের শেষ চর নিশ্চিতভাবে এক-বিট।

তাই one = true এবং লুপ ব্রেক।

return one;


লুপ শেষে one রিটার্ন করা → শেষ চর এক-বিট কি না।

কোড লেখার চিন্তার ধারা (How to think this solution)

প্রথমে প্রশ্নটি বুঝো:

শেষ চর এক-বিট কি না?

শেষ চর 0 দিয়ে শেষ হচ্ছে।

ধাপ-ধাপে চিন্তা করো:

1 হলে → দুই-বিট → দুই ধাপ এগাও।

0 হলে → এক-বিট → এক ধাপ এগাও।

লুপে শেষটা চেক করো:

যদি শেষ 0 পৌঁছায় এবং এটি দুই-বিট এর অংশ নয় → সত্য।

টেকনিক যা ব্যবহার করেছ:

Greedy traversal (লিনিয়ার স্ক্যান) → অ্যারেতে একবার ভিজিট।

Pointer manipulation → slow pointer দিয়ে অ্যারে ট্রাভার্স।

কেন Accepted:

কারণ সব ধরণের ইনপুট কভার করে:

এক-বিট বা দুই-বিট ধারা।

শেষের 0 ঠিকভাবে চেক করা।

টেস্ট কেসে চিন্তা (Walkthrough)

Case 1: [1,0,0]

slow=0 → bits[0]=1 → slow+=2 → slow=2

slow==2 == bits.size()-1 → bits[2]=0 → one=true → return true ✅

Case 2: [1,1,1,0]

slow=0 → bits[0]=1 → slow+=2 → slow=2

slow=2 → bits[2]=1 → slow+=2 → slow=4

slow==4 → লুপ শেষ → one=false → return false ❌

ভাল কাজ করছে।

সংক্ষিপ্ত Bangla Summary

প্রশ্নটি পড়ে: শেষ চর কি এক-বিট? → শেষ 0 কি দুই-বিট অংশ?

লজিক: একবার অ্যারে থেকে শুরু →

1 হলে দুই ধাপ (দুই-বিট)

0 হলে এক ধাপ (এক-বিট)

শেষ চেক: যদি last 0 পৌঁছায় এবং এটি দুই-বিট অংশ নয় → return true

টেকনিক: Greedy traversal, pointer manipulation, linear scan

Accepted কারণ: সব ইনপুটের edge cases কভার।

1️⃣ টেকনিকের নাম:

Greedy Linear Traversal বা Greedy Pointer Approach

অর্থাৎ আমরা অ্যারেকে একবার বাম থেকে ডান দিকে স্ক্যান করি এবং প্রতি ধাপে স্থানীয় সর্বোত্তম সিদ্ধান্ত নিই।

2️⃣ কেন এই টেকনিক ব্যবহার করা হলো:

প্রশ্নে বলা আছে:

0 → এক-বিট

10 বা 11 → দুই-বিট

আমাদের শুধু শেষ চর এক-বিট কিনা জানার দরকার।

তাই প্রতিটি পজিশনে চেক করে দ্রুত ঠিক সিদ্ধান্ত নেওয়া যায়:

যদি 1 → দুই-বিট চর ধরে দুই ধাপ এগো

যদি 0 → এক-বিট ধরে এক ধাপ এগো

এখানে কম্প্লেক্সিটি কমানোর জন্য কোনো ব্যাকট্র্যাক বা recursive search দরকার নেই।

অর্থাৎ আমরা Greedy principle ব্যবহার করছি: "লোকাল লজিক অনুযায়ী প্রতিটি পজিশনে দ্রুত সিদ্ধান্ত নাও"।

3️⃣ কেন efficient:

সময় জটিলতা (Time Complexity): O(n)

প্রতিটি এলিমেন্ট একবারই ভিজিট করা হয়।

স্পেস জটিলতা (Space Complexity): O(1)

কোনো অতিরিক্ত array বা stack ব্যবহার হয়নি।

কারণ:

আমরা শুধু slow pointer দিয়ে এগো।

আর কোনো recursive call, nested loop বা extra data structure নেই।

তাই খুব দ্রুত এবং memory-efficient।

4️⃣ সংক্ষেপে টেকনিকের মূল কারণ:

Greedy: প্রতিটি step-এ স্থানীয় সিদ্ধান্ত: 1 → দুই ধাপ, 0 → এক ধাপ

Linear traversal: অ্যারেকে একবার scan করলেই শেষের চর চেক করা যায়

Efficient: O(n) time + O(1) space → competitive programming & interviews-এ প্রায় সর্বোত্তম

যদি চাও, আমি ছোট্ট একটা diagram বানিয়ে দেখাতে পারি কিভাবে slow pointer greedyভাবে traverse করে [1,0,0] এবং [1,1,1,0] তে decision নেয়।


Full Code:
----------

  class Solution 
{
public:
    bool isOneBitCharacter(vector<int>& bits)
     {
        int slow=0;
        int fast=0;
        bool one=false;
        while(slow<bits.size()&&fast<bits.size())
        {
            if(bits[slow]==1)
            {
                slow+=2;
            }
        else if(bits[slow]==0&&slow<bits.size()-1)
            {
                slow++;
            }
            if(slow==bits.size()-1&&bits[slow]==0)
            {
                one=true;
                break;
            }
           
        }
        return one;
    }
};
