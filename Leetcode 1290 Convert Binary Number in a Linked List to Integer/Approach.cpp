তুমি যে সমস্যার সমাধান করেছো সেটি হলো একটি singly linked list দেওয়া আছে যেখানে প্রতিটি node-এর মান 0 অথবা 1, অর্থাৎ এটি একটি binary number। লিংকড লিস্টের সাবচেই গুরুত্বপূর্ণ বিট (MSB) হচ্ছে হেডে। আমাদের কাজ হলো এই বাইনারি সংখ্যাটিকে decimal (base 10) সংখ্যায় কনভার্ট করে রিটার্ন করা।

✅ সমস্যা বোঝার কৌশল (Bangla):
প্রশ্নে যা বলা হয়েছে:

head একটি লিংকড লিস্টের রেফারেন্স যা বাইনারি সংখ্যার প্রতিনিধিত্ব করে।

প্রতিটি node এর ভ্যালু 0 অথবা 1।

আমাদের সেই বাইনারি নাম্বারটা কে দশমিক (decimal) নাম্বারে কনভার্ট করতে হবে।

উদাহরণ:
makefile
Copy
Edit
Input:  [1, 0, 1]  
Binary:      1   0   1  
             ↑   ↑   ↑  
           (2^2)(2^1)(2^0)

Decimal = 1×2² + 0×2¹ + 1×2⁰ = 4 + 0 + 1 = 5
✅ কিভাবে সমাধান ভাববে?
তুমি যদি প্রশ্নটা পড়ো, তাহলে এটা মাথায় আসবে:

যেহেতু বাইনারি সংখ্যার প্রতিটি ডিজিট একটা node হিসাবে দেওয়া আছে, তাই পুরো লিস্টটা একবার ট্রাভার্স করতে হবে।

প্রতিটি বিটকে তার পজিশনের উপর ভিত্তি করে 2^power দিয়ে গুণ করে যোগ করতে হবে।

সবচেয়ে বামদিকের বিট (head) সবচেয়ে বড় পাওয়ার, ডানদিকের বিট (tail) সবচেয়ে ছোট পাওয়ার — যেটা হলো 2^0।

✅ কোড এক্সপ্লেইনেশন (Line by Line in Bangla):
cpp
Copy
Edit
int getDecimalValue(ListNode* head) 
{
    int ans=0;                      // Final result রাখার জন্য
    vector<int> vec;               // Linked list এর বিটগুলো রাখার জন্য

    // Step 1: Linked list traverse করে সব ভ্যালু নিয়ে নিচ্ছি
    while(head!=nullptr)
    {
        vec.push_back(head->val);  // প্রতিটি বিট vector-এ রাখছি
        head=head->next;           // পরের নোডে যাচ্ছি
    }

    // Step 2: Binary থেকে Decimal কনভার্ট
    for(int i=0; i<vec.size(); i++)
    {
        ans += vec[i] * pow(2, vec.size()-i-1);  // 2^position * value যোগ করছি
    }

    return ans;
}
✅ কেন Accepted হয়েছে?
Time Complexity: O(n) → আমরা পুরো লিংকড লিস্ট একবার ট্রাভার্স করছি।

Space Complexity: O(n) → আমরা একটি vector ব্যবহার করছি সব বিট রাখার জন্য।

প্রতি বিটের পজিশনের উপর ভিত্তি করে সঠিকভাবে গুণ করে যোগ করছি, তাই আউটপুট সঠিক আসছে।

