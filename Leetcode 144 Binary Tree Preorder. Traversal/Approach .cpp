1я╕ПтГг ржкрзНрж░рж╢рзНржи ржкржбрж╝рзЗ ржХрзАржнрж╛ржмрзЗ ржЪрж┐ржирзНрждрж╛ ржХрж░рждрзЗ рж╣ржмрзЗ

ржкрзНрж░рж╢рзНржи ржмрж▓ржЫрзЗ:

> "Given the root of a binary tree, return the preorder traversal of its nodesтАЩ values."



ржорж╛ржирзЗ ржЖржорж╛ржжрзЗрж░ Binary Tree-ржПрж░ Preorder Traversal ржмрзЗрж░ ржХрж░рждрзЗ рж╣ржмрзЗред

Preorder Traversal ржПрж░ рж░рзБрж▓:

1. Root node first (visit root)
2. Traverse left subtree
3. Traverse right subtree

(ржПржЯрж╛ржХрзЗ ржЖржорж░рж╛ тАЬRoot тЖТ Left тЖТ RightтАЭ ржмрж▓рзЗ ржоржирзЗ рж░рж╛ржЦрж┐)

ЁЯУМ ржЙржжрж╛рж╣рж░ржг:
ржзрж░рзЛ ржПржЗ ржЯрзНрж░рж┐ тАФ

1
     \
      2
     /
    3

Preorder ржХрж░рж▓рзЗ рж╣ржмрзЗ:

ржкрзНрж░ржержорзЗ Root 1

рждрж╛рж░ржкрж░ Left ржирзЗржЗ тЖТ Skip

рждрж╛рж░ржкрж░ Right тЖТ 2, рждрж╛рж░ржкрж░ 2-ржПрж░ Left тЖТ 3
ржлрж╛ржЗржирж╛рж▓ ржЖржЙржЯржкрзБржЯ: [1, 2, 3]



---

2я╕ПтГг ржХрзМрж╢рж▓ (Approach)

ржкрзНрж░рж╢рзНржирзЗ ржпрзЗрж╣рзЗрждрзБ ржЯрзНрж░рж┐ ржжрзЗржУржпрж╝рж╛ ржЖржЫрзЗ ржПржмржВ ржЖржорж░рж╛ рж╕ржм ржирзЛржб ржПржХржмрж╛рж░ ржХрж░рзЗ ржжрзЗржЦрждрзЗ ржЪрж╛ржЗ, DFS (Depth First Search) ржПржмржВ Recursive Preorder Traversal ржЗ рж╕ржмржЪрзЗржпрж╝рзЗ рж╕рж╣ржЬ ржкржжрзНржзрждрж┐ред

ржЖржорж╛ржжрзЗрж░ ржХрж░рждрзЗ рж╣ржмрзЗ:

1. ржпржжрж┐ root nullptr рж╣ржпрж╝ тЖТ ржХрж┐ржЫрзБржЗ рж░рж┐ржЯрж╛рж░рзНржи ржХрж░ржм ржирж╛ (base case)


2. root-ржПрж░ value рж░рзЗржХрж░рзНржб ржХрж░ржм (visit)


3. ржмрж╛ржо ржжрж┐ржХрзЗ recursive call ржХрж░ржм


4. ржбрж╛ржи ржжрж┐ржХрзЗ recursive call ржХрж░ржм




---

3я╕ПтГг ржХрзЗржи ржнрзЗржХрзНржЯрж░ v ржХрзНрж▓рж╛рж╕рзЗрж░ ржмрж╛ржЗрж░рзЗ (ржЧрзНрж▓рзЛржмрж╛рж▓ ржорзЗржорзНржмрж╛рж░)

ржпрзЗрж╣рзЗрждрзБ recursive function Preorder ржПрж░ ржоржзрзНржпрзЗ vector ржлрзЗрж░ржд ржжрзЗржУржпрж╝рж╛рж░ ржжрж░ржХрж╛рж░ ржирзЗржЗ, ржЖржорж░рж╛ ржХрзНрж▓рж╛рж╕рзЗрж░ ржнрзЗрждрж░рзЗ ржПржХржмрж╛рж░ vector ржбрж┐ржлрж╛ржЗржи ржХрж░рзЗ рж╕рзЗржЯрж╛рждрзЗ рж╕ржм value push ржХрж░ржмред

preorderTraversal() ржлрж╛ржВрж╢ржирзЗ v.clear() ржХрж░рж╛ рж╣ржпрж╝ ржпрж╛рждрзЗ ржЖржЧрзЗрж░ ржЯрзЗрж╕рзНржЯ ржХрзЗрж╕рзЗрж░ ржбрзЗржЯрж╛ ржорзБржЫрзЗ ржпрж╛ржпрж╝ред



---

4я╕ПтГг ржХрзЛржб ржмрзНржпрж╛ржЦрзНржпрж╛ (Line by Line)

class Solution
{
public:
    vector<int> v; // Output рж░рж╛ржЦрж╛рж░ ржЬржирзНржп ржЧрзНрж▓рзЛржмрж╛рж▓ ржорзЗржорзНржмрж╛рж░ ржнрзЗржХрзНржЯрж░

    void Preorder(TreeNode* root)
    {
        if(root == nullptr) return; // Base case: ржирзЛржб ржирзЗржЗ

        v.push_back(root->val); // ржзрж╛ржк 1: root visit ржХрж░рж▓рж╛ржо

        if(root->left != nullptr) Preorder(root->left); // ржзрж╛ржк 2: ржмрж╛ржо ржжрж┐ржХрзЗ ржЧрзЗрж▓рж╛ржо
        if(root->right != nullptr) Preorder(root->right); // ржзрж╛ржк 3: ржбрж╛ржи ржжрж┐ржХрзЗ ржЧрзЗрж▓рж╛ржо
    }

    vector<int> preorderTraversal(TreeNode* root)
    {
        v.clear(); // ржЖржЧрзЗрж░ ржХрзЗрж╕рзЗрж░ ржбрзЗржЯрж╛ ржорзБржЫрзЗ ржлрзЗрж▓рж┐
        Preorder(root); // рж░рж┐ржХрж╛рж░рж╢ржи ржЪрж╛рж▓рзБ
        return v; // рж░рзЗржЬрж╛рж▓рзНржЯ ржлрзЗрж░ржд
    }
};


---

5я╕ПтГг ржЯрзЗрж╕рзНржЯ ржХрзЗрж╕ ржЕржирзБржпрж╛ржпрж╝рзА ржмрзНржпрж╛ржЦрзНржпрж╛

Example 1:

root = [1,null,2,3]
Tree:
    1
     \
      2
     /
    3

ржзрж╛ржкрзЗ ржзрж╛ржкрзЗ:

Visit 1 тЖТ v = [1]

Left ржирзЗржЗ

Right тЖТ 2 тЖТ v = [1, 2]

2 ржПрж░ Left тЖТ 3 тЖТ v = [1, 2, 3]
тЬЕ Output: [1, 2, 3]



---

Example 2:

root = [1,2,3,4,5,null,8,null,null,6,7,9]

        1
      /   \
     2     3
    / \     \
   4   5     8
      / \     \
     6   7     9

ржзрж╛ржкрзЗ ржзрж╛ржкрзЗ:

Visit 1 тЖТ [1]

Go Left тЖТ Visit 2 тЖТ [1, 2]

Left тЖТ Visit 4 тЖТ [1, 2, 4]

Back, Right тЖТ Visit 5 тЖТ [1, 2, 4, 5]

Left тЖТ Visit 6 тЖТ [1, 2, 4, 5, 6]

Right тЖТ Visit 7 тЖТ [1, 2, 4, 5, 6, 7]

Back to root, Right тЖТ Visit 3 тЖТ [1, 2, 4, 5, 6, 7, 3]

Right тЖТ Visit 8 тЖТ [1, 2, 4, 5, 6, 7, 3, 8]

Right тЖТ Visit 9 тЖТ [1, 2, 4, 5, 6, 7, 3, 8, 9]
тЬЕ Output: [1, 2, 4, 5, 6, 7, 3, 8, 9]



---

Example 3:

root = [] тЖТ ржХрж┐ржЫрзБ ржирзЗржЗ тЖТ Output: []

Example 4:

root = [1] тЖТ рж╢рзБржзрзБ root тЖТ Output: [1]


---

6я╕ПтГг ржЧрж╛ржгрж┐рждрж┐ржХржнрж╛ржмрзЗ (Complexity Analysis)

ржкрзНрж░рждрж┐ржЯрж┐ ржирзЛржб ржПржХржмрж╛рж░ржЗ ржнрж┐ржЬрж┐ржЯ рж╣ржЪрзНржЫрзЗ тЖТ Time Complexity = O(n)

рж░рж┐ржХрж╛рж░рж╢ржи рж╕рзНржЯрзНржпрж╛ржХ рж╕рж░рзНржмрзЛржЪрзНржЪ O(h) (h = height of tree) тЖТ Space Complexity = O(h)



---

7я╕ПтГг ржХрзЗржи Accepted

рж╕ржм Edge case handle рж╣ржпрж╝рзЗржЫрзЗ (nullptr, ржПржХ ржирзЛржб, skewed tree, ржкрзВрж░рзНржг binary tree)

рж╕ржарж┐ржХ Preorder рж░рзБрж▓ (Root тЖТ Left тЖТ Right) ржЕржирзБрж╕рж░ржг ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗ

ржкрзНрж░рждрж┐ржЯрж┐ ржирзЛржб ржПржХржмрж╛рж░ ржнрж┐ржЬрж┐ржЯ ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗ тЖТ Efficient (O(n))

ржкрзНрж░рждрж┐ржЯрж┐ ржЯрзЗрж╕рзНржЯ ржХрзЗрж╕рзЗ ржарж┐ржХ ржЖржЙржЯржкрзБржЯ ржПрж╕рзЗржЫрзЗ


Full Code:
------------

class Solution
{
public:
    vector<int>v;
    void Preorder(TreeNode* root)
    {
        if(root==nullptr) return;
        v.push_back(root->val);
        if(root->left!=nullptr) Preorder(root->left);
        if(root->right!=nullptr) Preorder(root->right);
        
    }
    vector<int> preorderTraversal(TreeNode* root)
    {
        v.clear();
        Preorder(root);
        return v;
    }
};
