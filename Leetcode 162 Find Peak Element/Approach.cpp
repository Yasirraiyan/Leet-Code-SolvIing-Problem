рждрзБржорж┐ ржпрзЗ ржХрзЛржбржЯрж╛ ржжрж┐рзЯрзЗржЫрзЛ findPeakElementтАФ ржПржЯрж┐ ржПржХржЯрж┐ Binary Search ржнрж┐рждрзНрждрж┐ржХ O(log n) рж╕ржорж╛ржзрж╛ржи, ржпрзЗржЯрж╛ ржЦрзБржмржЗ ржХрж╛рж░рзНржпржХрж░ ржПржмржВ ржкрзНрж░рж╢рзНржи ржЕржирзБржпрж╛рзЯрзА ржкрзБрж░рзЛржкрзБрж░рж┐ рж╕ржарж┐ржХред ржирж┐ржЪрзЗ ржЖржорж░рж╛ ржПржЗ рж╕ржорж╕рзНржпрж╛рж░ ржкрзВрж░рзНржг ржмрзНржпрж╛ржЦрзНржпрж╛, ржХрзЛржб рж▓рж╛ржЗржирзЗ рж▓рж╛ржЗржирзЗ ржмрж┐рж╢рзНрж▓рзЗрж╖ржг, ржорзНржпрж╛ржержорзЗржЯрж┐ржХрзНржпрж╛рж▓ ржмрзНржпрж╛ржЦрзНржпрж╛, ржЙржжрж╛рж╣рж░ржгрж╕рж╣ ржмрж╛ржВрж▓рж╛рзЯ ржЖрж▓рзЛржЪржирж╛ ржХрж░ржмред


---

ЁЯФН ржкрзНрж░рж╢рзНржи ржмрзЛржЭрж╛ (Bangla Explanation)

ржЖржорж╛ржжрзЗрж░ржХрзЗ ржПржХржЯрж┐ peak element ржЦрзБржБржЬрзЗ ржмрзЗрж░ ржХрж░рждрзЗ рж╣ржмрзЗред

ЁЯУМ Peak element: ржПржоржи ржПржХржЯрж┐ ржЙржкрж╛ржжрж╛ржи ржпрж╛ рждрж╛рж░ ржжрзБржЗ ржкрж╛рж╢рзЗрж░ ржЙржкрж╛ржжрж╛ржирзЗрж░ ржЪрзЗрзЯрзЗ ржмрзЬред ржЕрж░рзНржерж╛рзО,

nums[i] > nums[i-1] && nums[i] > nums[i+1]

Extra Rule:

nums[-1] = nums[n] = -тИЮ (ржорж╛ржирзЗ array ржПрж░ ржмрж╛ржЗрж░рзЗ рж╕ржм -infinity ржзрж░рж╛ рж╣ржмрзЗ)

nums[i] тЙа nums[i+1] тЖТ adjacent elements never equal


ЁЯОп ржЖржорж╛ржжрзЗрж░ ржЯрж╛рж░рзНржЧрзЗржЯ: O(log n) ржЯрж╛ржЗржорзЗ ржПржХржЯрж┐ ржпрзЗржХрзЛржирзЛ peak element-ржПрж░ index return ржХрж░рждрзЗ рж╣ржмрзЗред


---

тЬЕ ржзрж╛ржкрзЗ ржзрж╛ржкрзЗ рж╕ржорж╛ржзрж╛ржи ржнрж╛ржмржирж╛

ржЖржорж░рж╛ binary search ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржм ржХрж╛рж░ржг ржЖржорж╛ржжрзЗрж░ ржЯрж╛ржЗржо ржХржоржкрзНрж▓рзЗржХрзНрж╕рж┐ржЯрж┐ O(log n) ржЪрж╛ржЗред

Binary search ржжрж┐рзЯрзЗ ржХрзАржнрж╛ржмрзЗ ржнрж╛ржмржмрзЛ?

1. ржЖржорж░рж╛ mid index ржмрзЗрж░ ржХрж░ржмрзЛред


2. рждрж╛рж░ржкрж░ ржЪрзЗржХ ржХрж░ржмрзЛ, mid рж╣рж▓рзЛ ржХрж┐ ржирж╛ ржПржХржЯрж┐ peak?


3. ржпржжрж┐ mid рждрж╛рж░ ржЖрж╢рзЗржкрж╛рж╢рзЗрж░ ржЪрж╛ржЗрждрзЗ ржмрзЬ рж╣рзЯ, рждрж╛рж╣рж▓рзЗ mid is a peak тАФ тЬЕ return mid.


4. ржирж╛ рж╣рж▓рзЗ, ржпржжрж┐ nums[mid] < nums[mid + 1], рждрж╛рж╣рж▓рзЗ ржбрж╛ржи ржкрж╛рж╢рзЗ ржЕржмрж╢рзНржпржЗ ржПржХржЯрж╛ peak ржерж╛ржХржмрзЗред ржХрж╛рж░ржг strictly increasing рж╣рж▓рзЗ рж╢рзЗрж╖рзЗ ржПржХржЯрж╛ peak рж╣ржмрзЗржЗред


5. ржирж╛ рж╣рж▓рзЗ, ржмрж╛ржо ржкрж╛рж╢рзЗ ржЦрзБржБржЬржмрзЛред




---

ЁЯФН ржЙржжрж╛рж╣рж░ржг ржжрж┐рзЯрзЗ ржмрзНржпрж╛ржЦрзНржпрж╛ (nums = [1,2,1,3,5,6,4])

index:     0  1  2  3  4  5  6
nums  =   [1, 2, 1, 3, 5, 6, 4]

Step 1:

low = 0, high = 6

mid = (0+6)/2 = 3 тЖТ nums[3] = 3


Check:

nums[3] = 3

nums[2] = 1 тЖТ OK

nums[4] = 5 тЖТ 3 < 5 тЖТ Not peak


ЁЯСЙ рждрж╛ржЗ ржЖржорж░рж╛ low = mid + 1 = 4 ржирж┐ржЗ

Step 2:

low = 4, high = 6

mid = (4+6)/2 = 5 тЖТ nums[5] = 6


Check:

nums[5-1] = 5 < 6

nums[5+1] = 4 < 6 тЖТ тЬЕ Peak


Return index 5


---

ЁЯза ржХрзЛржб ржмрзНржпрж╛ржЦрзНржпрж╛ ржмрж╛ржВрж▓рж╛рзЯ (Line by Line)

int findPeakElement(vector<int>& nums) {
    int low=0;
    int high=nums.size()-1;
    int mid;

low ржУ high ржжрж┐рзЯрзЗ binary search рж╢рзБрж░рзБ ржХрж░ржЫрж┐

mid index рж╣рж┐рж╕рж╛ржм ржХрж░рж╛рж░ ржЬржирзНржп variable



---

while(low<=high)

ржпрждржХрзНрж╖ржг low <= high,
ЁЯФ╣ рж╕ржорж╕рзНржпрж╛:

ржПржоржи ржПржХржЯрж┐ index ржЦрзБржБржЬрзЗ ржмрзЗрж░ ржХрж░рждрзЗ рж╣ржмрзЗ ржпрзЗржЯрж╛ peak elementред

ржЕрж░рзНржерж╛рзО, nums[i] > nums[i-1] && nums[i] > nums[i+1]

nums[-1] = nums[n] = -тИЮ ржзрж░рж╛ ржЖржЫрзЗ

nums[i] тЙа nums[i+1] тЖТ adjacent elements ржХржЦржиржУ рж╕ржорж╛ржи ржирзЯ

ржЯрж╛ржЗржо ржХржоржкрзНрж▓рзЗржХрзНрж╕рж┐ржЯрж┐: O(log n)



---

ЁЯФ╣ ржХрзЛржб ржмрзНржпрж╛ржЦрзНржпрж╛:

int findPeakElement(vector<int>& nums) {
    int low = 0;
    int high = nums.size() - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if ((mid == 0 || nums[mid] > nums[mid - 1]) &&
            (mid == nums.size() - 1 || nums[mid] > nums[mid + 1])) {
            return mid;
        }
        else if (nums[mid] < nums[mid + 1]) {
            low = mid + 1;
        }
        else {
            high = mid;
        }
    }
    return low;
}


---

ЁЯФ╣ ржзрж╛ржкрзЗ ржзрж╛ржкрзЗ ржЪрж▓рж╛ржлрзЗрж░рж╛ (Example: [1, 2, 1, 3, 5, 6, 4])

Step 1:

low = 0, high = 6
mid = 3 тЖТ nums[3] = 3
nums[3] < nums[4] тЖТ ржбрж╛ржи ржкрж╛рж╢рзЗ ржЦрзБржБржЬржмрзЛ
low = mid + 1 = 4

Step 2:

low = 4, high = 6
mid = 5 тЖТ nums[5] = 6
nums[4] < 6 && 6 > nums[6] тЖТ тЬЕ Peak тЖТ return 5


---

ЁЯФ╣ ржорзНржпрж╛рже ржмрзНржпрж╛ржЦрзНржпрж╛:

ржзрж░рзЛ nums[mid] < nums[mid+1]

тЖТ ржорж╛ржирзЗ ascending path тЖТ ржПржХржЯрж╛ ржмрзЬ ржнрзНржпрж╛рж▓рзБ ржЖржЫрзЗ тЖТ ржЕржирзНрждржд ржПржХржЯрж╛ peak ржерж╛ржХржмрзЗ ржбрж╛ржи ржкрж╛рж╢рзЗ

nums[mid] > nums[mid+1]

тЖТ descending path тЖТ рж╣рзЯ mid ржЗ рж╣рждрзЗ ржкрж╛рж░рзЗ, ржирзЯрждрзЛ ржмрж╛ржо ржкрж╛рж╢рзЗ peak ржЖржЫрзЗ


---

ЁЯФ╣ Time & Space Complexity:

Complexity	Value

Time	O(log n)
Space	O(1)


Full Code:
-------------
class Solution
{
public:
    int findPeakElement(vector<int>& nums) 
    {
        int low=0;
        int high=nums.size()-1;
        int mid;
        while(low<=high)
            {
                mid=low+(high-low)/2;
                if((mid==nums.size()-1||nums[mid]>nums[mid+1])&&(mid==0||nums[mid]>nums[mid-1]))
                {
                    return mid;
                }
                if(mid<nums.size()-1&&nums[mid]<nums[mid+1])
                {
                    low=mid+1;
                }
                else
                {
                    high=mid;
                }
            }
        return low;
    }
};
  

