ЁЯФН ржкрзНрж░рж╢рзНржиржЯрж╛ ржкрзЬрзЗржЗ рждрзБржорж┐ ржпрж╛ ржнрж╛ржмржЫрзЛ (Thinking Process):
ржкрзНрж░ржержорзЗржЗ ржкрзНрж░рж╢рзНржиржЯрж╛ ржмрж▓ржЫрзЗ:

"рждрзБржорж┐ ржПржХржЯрж┐ Linked List ржкрж╛ржмрзЗ ржПржмржВ ржПржХржЯрж┐ val ржкрж╛ржмрзЗред рждрзЛржорж╛ржХрзЗ рж╕рзЗржЗ рж╕ржм node ржЧрзБрж▓рзЛ рж▓рж┐рж╕рзНржЯ ржерзЗржХрзЗ ржорзБржЫрзЗ ржлрзЗрж▓рждрзЗ рж╣ржмрзЗ ржпрзЗржЧрзБрж▓рзЛрж░ ржорж╛ржи val ржПрж░ рж╕ржорж╛ржиред"

рждрзБржорж┐ ржЪрж┐ржирзНрждрж╛ ржХрж░рж▓рзЗ:

OK! ржЖржорж┐ ржПржХржЯрж╛ ржПржХржЯрж╛ ржХрж░рзЗ Linked List ржПрж░ node ржжрзЗржЦржмред

ржпржжрж┐ node ржПрж░ ржорж╛ржи val ржирж╛ рж╣рзЯ рждрж╛рж╣рж▓рзЗ рж╕рзЗржЯрж╛ рж░рж╛ржЦрж╛ ржЙржЪрж┐рждред

ржпрзЗржЧрзБрж▓рж╛ val ржПрж░ рж╕ржорж╛ржи рж╕рзЗржЧрзБрж▓рж╛ ржмрж╛ржж ржжрж┐ржмред

ржПржмржВ ржпрзЗржЧрзБрж▓рж╛ рж░рж╛ржЦрждрзЗ ржЪрж╛ржЗ, рж╕рзЗржЧрзБрж▓рж╛ ржжрж┐рзЯрзЗ ржПржХржЯрж╛ ржирждрзБржи рж▓рж┐рж╕рзНржЯ ржмрж╛ржирж╛ржмред

тЬЕ рждрзБржорж┐ ржХрзЛржи ржЯрзБрж▓ ржмрж╛ ржбрж╛ржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░ ржмрзЗржЫрзЗ ржирж┐рзЯрзЗржЫрзЛ?
рждрзБржорж┐ Stack ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗржЫрзЛ!
рждрзЛржорж╛рж░ ржЪрж┐ржирзНрждрж╛ ржЫрж┐рж▓ржГ

"ржЖржорж┐ ржпрзЗржЧрзБрж▓рж╛ рж░рж╛ржЦрждрзЗ ржЪрж╛ржЗ, рж╕рзЗржЧрзБрж▓рж╛ ржПржХржЯрж╛ Stack-ржП рж░рзЗржЦрзЗ ржжрж┐ржЗред рж╢рзЗрж╖рзЗ Stack ржерзЗржХрзЗ ржПржХрзЗ ржПржХрзЗ ржмрзЗрж░ ржХрж░рзЗ ржЙрж▓рзНржЯрзЛ ржХрж░рзЗ ржЖржмрж╛рж░ рж▓рж┐рж╕рзНржЯ ржмрж╛ржирж┐рзЯрзЗ ржлрзЗрж▓рж┐ред рждрж╛рж╣рж▓рзЗ ржЕрж░рзНржбрж╛рж░ ржарж┐ржХ ржерж╛ржХржмрзЗред"

ржПржЗржЯрж╛ ржЦрзБржм ржЪрждрзБрж░ ржПржХржЯрж╛ ржЪрж┐ржирзНрждрж╛, ржХрж╛рж░ржг Stack LIFO (Last-In-First-Out), ржЖрж░ Linked List ржмрж╛ржирж╛ржирзЛрж░ рж╕ржорзЯ ржЖржорж░рж╛ node->next = ржЖржЧрзЗрж░Node ржХрж░рзЗ ржХрж░рж▓рзЗ ржкрзБрж░ржирзЛ ржЕрж░рзНржбрж╛рж░ ржлрзЗрж░ржд ржкрж╛ржУрзЯрж╛ рж╕ржорзНржнржмред

ЁЯза рждрзЛржорж╛рж░ рж╕ржорж╛ржзрж╛ржирзЗрж░ ржзрж╛ржк (Step by Step Thought Process):
ржПржХржЯрж╛ Stack ржирж┐ржЗред ржпрзЗржЗ node ржЧрзБрж▓рж╛ val ржирж╛, рж╕рзЗржЧрзБрж▓рж╛ Stack ржП рж░рж╛ржЦрж┐ред

рж▓рж┐рж╕рзНржЯрзЗрж░ рж╕ржм node ржШрзБрж░рзЗ ржжрзЗржЦрж┐ред

рж╢рзЗрж╖рзЗ Stack ржерзЗржХрзЗ рж╕ржм node ржмрзЗрж░ ржХрж░рзЗ ржирждрзБржи рж▓рж┐рж╕рзНржЯ ржмрж╛ржирж╛ржЗред

ржпрзЗрж╣рзЗрждрзБ Stack ржЙрж▓рзНржЯрзЗ ржжрзЗрзЯ, рждрж╛ржЗ ржЖржмрж╛рж░ ржЙрж▓рзНржЯрзЗ ржжрж┐рж▓рзЗ ржЕрж░рзНржбрж╛рж░ ржарж┐ржХ рж╣рзЯрзЗ ржпрж╛ржмрзЗред

ЁЯУШ ржПржЦржи рждрзЛржорж╛рж░ ржХрзЛржб ржмрзНржпрж╛ржЦрзНржпрж╛ ржХрж░ржЫрж┐ рж▓рж╛ржЗржи ржмрж╛ржЗ рж▓рж╛ржЗржи ржмрж╛ржВрж▓рж╛рзЯ:
cpp
Copy
Edit
class Solution 
{
public:
    ListNode* removeElements(ListNode* head, int val)
ЁЯФ╣ рждрзБржорж┐ ржПржХржЯрж╛ ржХрзНрж▓рж╛рж╕ рж▓рж┐ржЦрзЗржЫрзЛ ржПржмржВ public ржлрж╛ржВрж╢ржи removeElements ржбрж┐ржлрж╛ржЗржи ржХрж░рзЗржЫрзЛред
ЁЯФ╣ ржПржЯрж╛ ржПржХржЯрж╛ Linked List ржПрж░ head ржирзЗржмрзЗ ржПржмржВ val (ржпрзЗржЯрж╛ ржорзБржЫрждрзЗ рж╣ржмрзЗ)ред

cpp
Copy
Edit
    stack<ListNode*> st1;
ЁЯФ╣ рждрзБржорж┐ Stack ржбрж┐ржХрзНрж▓рзЗрзЯрж╛рж░ ржХрж░рзЗржЫрзЛ тАФ ржХрж╛рж░ржг рждрзБржорж┐ ржпрзЗржЧрзБрж▓рзЛ рж░рж╛ржЦрждрзЗ ржЪрж╛ржУ рж╕рзЗржЧрзБрж▓рзЛржХрзЗ рж╕рзНржЯрзЛрж░ ржХрж░ржмрзЗред

cpp
Copy
Edit
    while(head != nullptr)
    {
        if(head->val != val)
        {
            st1.push(head);  // val ржирж╛ рж╣рж▓рзЗ Stack-ржП рж░рж╛ржЦ
        }
        head = head->next;   // ржкрж░ржмрж░рзНрждрзА node-ржП ржпрж╛ржУ
    }
ЁЯФ╣ рждрзБржорж┐ ржкрзБрж░рзЛ Linked List ржП рж▓рзБржк ржЪрж╛рж▓рж┐рзЯрзЗ ржпрж╛ржЪрзНржЫрзЛред
ЁЯФ╣ head->val != val рж╣рж▓рзЗ, ржЕрж░рзНржерж╛рзО ржпрзЗржЗ node ржЧрзБрж▓рж╛ рж░рж╛ржЦрж╛ ржЙржЪрж┐ржд, рж╕рзЗржЧрзБрж▓рж╛ Stack-ржП push ржХрж░ржЫрзЛред
ЁЯФ╣ рждрж╛рж░ржкрж░ head ржХрзЗ ржкрж░рзЗрж░ node ржП ржкрж╛ржарж╛ржЪрзНржЫрзЛред

ЁЯСЙ Stack ржП ржПржЦржи val ржмрж╛ржжрзЗ ржмрж╛ржХрж┐ рж╕ржм node ржЖржЫрзЗ, рждржмрзЗ ржЙрж▓рзНржЯрзЛ ржЕрж░рзНржбрж╛рж░рзЗред

cpp
Copy
Edit
    ListNode* newHead = nullptr;
ЁЯФ╣ ржирждрзБржи рж▓рж┐рж╕рзНржЯрзЗрж░ ржЬржирзНржп Head ржирж┐ржЪрзНржЫрзЛ тАФ рж╢рзБрж░рзБрждрзЗ ржПржЯрж╛ null ржерж╛ржХржмрзЗред

cpp
Copy
Edit
    while(!st1.empty())
    {
        ListNode* head = st1.top();  // Stack ржерзЗржХрзЗ ржЙржкрж░рзЗрж░ node ржирж┐ржУ
        st1.pop();                   // Stack ржерзЗржХрзЗ рж╕рж░рж┐рзЯрзЗ ржлрзЗрж▓рзЛ

        head->next = newHead;       // ржкрзБрж░ржирзЛ рж▓рж┐рж╕рзНржЯрзЗ newHead ржХрзЗ next рж╣рж┐рж╕рж╛ржмрзЗ ржмрж╕рж╛ржУ
        newHead = head;             // newHead ржЖржкржбрзЗржЯ ржХрж░рзЗ head ржмрж╛ржирж╛ржУ
    }
ЁЯФ╣ Stack ржерзЗржХрзЗ ржПржХрзЗ ржПржХрзЗ node ржмрзЗрж░ ржХрж░ржЫрзЛ ржПржмржВ newHead ржПрж░ рж╕рж╛ржерзЗ ржпрзБржХрзНржд ржХрж░рзЗ ржирждрзБржи рж▓рж┐рж╕рзНржЯ ржмрж╛ржирж╛ржЪрзНржЫрзЛред

ЁЯСЙ ржпрзЗрж╣рзЗрждрзБ Stack LIFO, рждрж╛ржЗ ржПржЦрж╛ржирзЗ рждрзБржорж┐ head->next = newHead ржХрж░рж▓рзЗ ржЖржмрж╛рж░ ржЖржЧрзЗрж░ ржЕрж░рзНржбрж╛рж░рзЗ ржлрж┐рж░рзЗ ржЖрж╕рзЛред

cpp
Copy
Edit
    return newHead;
ЁЯФ╣ рж╕ржмрж╢рзЗрж╖рзЗ ржирждрзБржи рж▓рж┐рж╕рзНржЯрзЗрж░ head рж░рж┐ржЯрж╛рж░рзНржи ржХрж░ржЫрзЛред

ЁЯзк ржЯрзЗрж╕рзНржЯ ржХрзЗрж╕рзЗ ржХрж┐ржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ?
тЮд ржЙржжрж╛рж╣рж░ржг 1:
Input: [1,2,6,3,4,5,6], val = 6
ЁЯСЙ Stack-ржП ржпрж╛ржмрзЗ: 1,2,3,4,5
ЁЯСЙ Stack ржерзЗржХрзЗ ржмрзЗрж░ ржХрж░рзЗ: 5 -> 4 -> 3 -> 2 -> 1 тЖТ ржЙрж▓рзНржЯрзЛ
ЁЯСЙ ржЖржмрж╛рж░ head->next = newHead ржХрж░рзЗ: 1 -> 2 -> 3 -> 4 -> 5

Output: [1,2,3,4,5]

тЮд ржЙржжрж╛рж╣рж░ржг 2:
Input: [], val = 1
ЁЯСЙ рж▓рж┐рж╕рзНржЯ ржЦрж╛рж▓рж┐, ржХрж┐ржЫрзБ ржХрж░рж╛рж░ ржирзЗржЗ
Output: []

тЮд ржЙржжрж╛рж╣рж░ржг 3:
Input: [7,7,7,7], val = 7
ЁЯСЙ рж╕ржм node-ржЗ 7 тЖТ Stack-ржП ржХрж┐ржЫрзБржЗ ржпрж╛ржмрзЗ ржирж╛
ЁЯСЙ newHead = nullptr тЖТ рж▓рж┐рж╕рзНржЯ ржЦрж╛рж▓рж┐
Output: []

ЁЯзо Time Complexity:
O(n) тАФ Linked List traversal ржПрж░ ржЬржирзНржп

O(n) тАФ Stack ржПрж░ ржЬржирзНржп extra space

ЁЯУМ ржнржмрж┐рж╖рзНржпрждрзЗрж░ ржЬржирзНржп ржоржирзЗ рж░рж╛ржЦрж╛рж░ ржмрж┐рж╖рзЯ:
рждрзБржорж┐ Stack ржжрж┐рзЯрзЗ рж╕ржарж┐ржХржнрж╛ржмрзЗ linked list reconstruct ржХрж░рзЗржЫрзЛред

ржПржЯрж╛ ржПржХржЯрж╛ ржнрж╛рж▓рзЛ approach тАФ ржмрж┐рж╢рзЗрж╖ ржХрж░рзЗ ржпржЦржи рждрзБржорж┐ ржмрж╛рж░ржмрж╛рж░ ржХрж┐ржЫрзБ ржлрж┐рж▓рзНржЯрж╛рж░ ржХрж░рзЗ ржкрж░рзЗ reconstruct ржХрж░рждрзЗ ржЪрж╛ржУред

ржХрж┐ржирзНрждрзБ Production-level solution ржЪрж╛ржЗрж▓рзЗ dummy node approach ржЖрж░ржУ efficient рж╣рзЯ ржХрж╛рж░ржг рж╕рзЗржЯрж╛рждрзЗ extra space рж▓рж╛ржЧрзЗ ржирж╛ред

ЁЯФЪ ржЙржкрж╕ржВрж╣рж╛рж░:
ЁЯФ╣ рждрзБржорж┐ ржкрзНрж░рж╢рзНржиржЯрж╛ ржнрж╛рж▓рзЛржнрж╛ржмрзЗ ржмрзБржЭрзЗ ржЫрж┐рж▓рзЗред
ЁЯФ╣ рждрзБржорж┐ Stack ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ thinking-based solution ржжрж┐рзЯрзЗржЫрзЛред
ЁЯФ╣ рждрзБржорж┐ ржпрзЗржЯрж╛ ржХрж░рждрзЗ ржЪрзЗрзЯрзЗржЫрзЛ рж╕рзЗржЯрж╛ржЗ рж╣рзЯрзЗржЫрзЗ тАФ рж╕ржарж┐ржХржнрж╛ржмрзЗ filter ржХрж░рзЗ ржирждрзБржи рж▓рж┐рж╕рзНржЯ рждрзИрж░рж┐ред
ЁЯФ╣ рж╕ржорж╛ржзрж╛ржи accepted рж╣рзЯрзЗржЫрзЗ тАФ ржХрж╛рж░ржг рж▓ржЬрж┐ржХally рж╕ржм ржарж┐ржХ ржЖржЫрзЗред

Full Code:
----------

  /**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution 
{
public:
    ListNode* removeElements(ListNode* head, int val) 
    {
     stack<ListNode*> st1;
     while(head!=nullptr)
     {
      if(head->val!=val)
      {

      
      st1.push(head);
      }
      head=head->next;     
      }
      ListNode* newHead=nullptr;
      while(!st1.empty())
      {
        ListNode* head=st1.top();

       /* if(st1.top()->val!=val)
        {

        
         newHead=st1.top();
        }
        */
         st1.pop();
           head->next=newHead;
      newHead=head;
      }
      return newHead;
    }
};

