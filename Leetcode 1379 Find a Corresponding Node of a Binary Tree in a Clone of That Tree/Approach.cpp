тЬЕ ржкрзНрж░рж╢рзНржи ржмрж┐рж╢рзНрж▓рзЗрж╖ржг (Problem Understanding)

ржкрзНрж░рж╢рзНржиржЯрж╛ ржмрж▓ржЫрзЗ:

рждрзЛржорж╛рж░ ржХрж╛ржЫрзЗ ржжрзБржЗржЯрж╛ ржмрж╛ржЗржирж╛рж░рж┐ ржЯрзНрж░рж┐ ржЖржЫрзЗ:

original (ржорзВрж▓ ржЧрж╛ржЫ)

cloned (ржПржХржЗ original ржЧрж╛ржЫрзЗрж░ ржХржкрж┐, ржорж╛ржирзЗ ржПржХржжржо ржПржХржЗ structure, ржорж╛ржи same, ржХрж┐ржирзНрждрзБ reference ржЖрж▓рж╛ржжрж╛)


ржЖрж░ ржПржХржЯрж╛ ржирзЛржб target ржжрзЗржУрзЯрж╛ ржЖржЫрзЗ ржпрзЗржЯрж╛ original ржЧрж╛ржЫрзЗрж░ ржнрж┐рждрж░рзЗрж░ ржПржХржЯрж┐ ржирзЛржбрзЗрж░ рж░рзЗржлрж╛рж░рзЗржирзНрж╕ред


ЁЯФН рждрзЛржорж╛рж░ ржХрж╛ржЬ: cloned ржЧрж╛ржЫрзЗрж░ рж╕рзЗржЗ ржирзЛржбржЯрж╛ рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рж╛ ржпрзЗржЯрж╛ target ржирзЛржбрзЗрж░ ржЕржмрж╕рзНржерж╛ржи ржЕржирзБржпрж╛рзЯрзА ржХрзНрж▓рзЛржиред

> ржорж╛ржирзЗ target ржЧрж╛ржЫрзЗрж░ ржпрзЗржЗ ржкржЬрж┐рж╢ржирзЗ ржЖржЫрзЗ, cloned ржЧрж╛ржЫрзЗржУ ржарж┐ржХ рж╕рзЗржЗ ржкржЬрж┐рж╢ржирзЗрж░ ржирзЛржб return ржХрж░рждрзЗ рж╣ржмрзЗред




---

тЬЕ ржХрж┐ ржХрж┐ constraint ржмрж╛ ржирж┐рзЯржо ржжрзЗржУрзЯрж╛ ржЖржЫрзЗ?

ржжрзБржЗржЯрж╛ ржЯрзНрж░рж┐ structure ржПржХржжржо ржПржХржЗ (value ржУ ржПржХржЗ), ржХрж┐ржирзНрждрзБ reference ржЖрж▓рж╛ржжрж╛ред

ржХрзЛржирзЛ ржЧрж╛ржЫ ржмрж╛ ржирзЛржб modify ржХрж░рж╛ ржпрж╛ржмрзЗ ржирж╛ред

ржкрзНрж░рждрж┐ ржЧрж╛ржЫрзЗ node рж╕ржВржЦрзНржпрж╛ [1, 10тБ┤] ржкрж░рзНржпржирзНржд рж╣рждрзЗ ржкрж╛рж░рзЗ (ржорж╛ржирзЗ O(n) ржЪрж▓ржмрзЗ)ред

Target ржХржЦржирзЛ null ржирж╛ред



---

тЬЕ рж╕ржорж╛ржзрж╛ржи ржнрж╛ржмрж╛рж░ ржкржжрзНржзрждрж┐ (Approach Thinking):

1. target node ржПрж░ value рждрзЛржорж╛рж░ ржХрж╛ржЫрзЗ ржЖржЫрзЗ, ржХрж┐ржирзНрждрзБ рждрзБржорж┐ original ржПрж░ рж░рзЗржлрж╛рж░рзЗржирзНрж╕ ржкрж╛ржмрзЗ ржирж╛, рждрж╛ржЗ value match ржжрж┐рзЯрзЗ ржХрж╛ржЬ ржХрж░рждрзЗ ржкрж╛рж░рзЛред


2. ржпрзЗрж╣рзЗрждрзБ original ржЖрж░ cloned structurally same, рждрж╛ржЗ ржпржжрж┐ рждрзБржорж┐ original ржЯрзНрж░рж┐рждрзЗ BFS ржХрж░рзЛ, рж╕рзЗржЗ рж╕рж╛ржерзЗ cloned ржЯрзНрж░рж┐рждрзЗржУ ржПржХрж╕рж╛ржерзЗ BFS ржХрж░рзЛ, рждрж╛рж╣рж▓рзЗ target ржирзЛржб ржпрзЗржЦрж╛ржи ржерзЗржХрзЗ ржкрж╛ржмрзЗ original ржП, ржУржЗ ржЕржмрж╕рзНржерж╛ржирзЗ cloned ржПрж░ ржирзЛржб-ржЯрж╛ рж╣ржмрзЗ рждрзЛржорж╛рж░ ржЙрждрзНрждрж░ред




---

тЬЕ ржХрзЛржб ржмрзНржпрж╛ржЦрзНржпрж╛ (Code Explanation Line by Line)

class Solution 
{
public:
    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) 
    {

тЮд ржПржХржЯрж╛ ржлрж╛ржВрж╢ржи, ржпрзЗржЯрж╛ original, cloned, ржПржмржВ target ржирзЛржб ржирзЗрзЯред ржЖржорж╛ржжрзЗрж░ ржХрж╛ржЬ cloned ржЧрж╛ржЫ ржерзЗржХрзЗ рж╕рзЗржЗ ржирзЛржб ржЦрзБржБржЬрзЗ ржмрзЗрж░ ржХрж░рж╛ ржпрзЗржЯрж╛ target ржПрж░ ржХрзНрж▓рзЛржиред

queue<TreeNode*> q1;
        queue<TreeNode*> q2;

тЮд ржжрзБржЗржЯрж╛ Queue ржирж┐ржЪрзНржЫрж┐ BFS ржХрж░рж╛рж░ ржЬржирзНржп тАУ ржПржХржЯрж╛рждрзЗ original ржЧрж╛ржЫ BFS ржХрж░ржмрзЛ ржЖрж░рзЗржХржЯрж╛рждрзЗ cloned ржЧрж╛ржЫред

q1.push(original);
        q2.push(cloned);

тЮд ржжрзБржЯрзЛ ржЧрж╛ржЫрзЗржЗ root ржерзЗржХрзЗ BFS рж╢рзБрж░рзБ ржХрж░ржЫрж┐ред

TreeNode* ans;

тЮд ржЙрждрзНрждрж░ рж░рж╛ржЦрж╛рж░ ржЬржирзНржп ржПржХржЯрж╛ ржкрзЯрзЗржирзНржЯрж╛рж░ ржирж┐ржЪрзНржЫрж┐ред

while(!q1.empty() && !q2.empty())
        {

тЮд ржпрждржХрзНрж╖ржг ржирж╛ ржкрж░рзНржпржирзНржд ржжрзБржЗржЯрж╛ queue ржлрж╛ржБржХрж╛ рж╣ржЪрзНржЫрзЗ, ржЖржорж░рж╛ level by level BFS ржЪрж╛рж▓рж┐рзЯрзЗ ржпрж╛ржмрзЛред

TreeNode* front1 = q1.front();
            TreeNode* front2 = q2.front();

тЮд original ржЧрж╛ржЫ ржерзЗржХрзЗ ржПржХржЯрж┐ ржирзЛржб, ржПржмржВ рждрж╛рж░ ржПржХржЗ ржкржЬрж┐рж╢ржирзЗрж░ cloned ржЧрж╛ржЫ ржерзЗржХрзЗ ржПржХржЯрж┐ ржирзЛржб ржирж┐ржЪрзНржЫрж┐ред

if(front1->val == target->val)
            {
                ans = front2;
                break;
            }

тЮд ржпржжрж┐ original ржЧрж╛ржЫрзЗрж░ ржирзЛржбржЯрж╛ target ржПрж░ рж╕ржорж╛ржи рж╣рзЯ (ржорж╛ржирзЗ value-wise match рж╣рзЯ), рждрж╛рж╣рж▓рзЗ ржУржЗ ржкржЬрж┐рж╢ржирзЗрж░ cloned ржЧрж╛ржЫрзЗрж░ ржирзЛржб-ржЯрж╛ржЗ ржЖржорж╛ржжрзЗрж░ ржЙрждрзНрждрж░ред

ЁЯУМ Note: ржЖржорж░рж╛ value ржжрж┐рзЯрзЗ ржЪрзЗржХ ржХрж░ржЫрж┐ ржХрж╛рж░ржг target node ржПрж░ reference ржЕржирзНржп, рждржмрзЗ ржпрзЗрж╣рзЗрждрзБ values unique, рждрж╛ржЗ value ржжрж┐рзЯрзЗржЗ identify ржХрж░рж╛ ржирж┐рж░рж╛ржкржжред

q1.pop();
            q2.pop();

тЮд ржпрзЗрж╣рзЗрждрзБ ржЖржорж░рж╛ ржирзЛржбржЧрзБрж▓рзЛ ржЪрзЗржХ ржХрж░рзЗржЫрж┐, рждрж╛ржЗ ржПржЦржи queue ржерзЗржХрзЗ ржмрзЗрж░ ржХрж░рзЗ ржжрж┐ржЪрзНржЫрж┐ред

if (front1->left && front2->left) 
            {
                q1.push(front1->left);
                q2.push(front2->left);
            }

тЮд ржпржжрж┐ ржмрж╛ржо рж╕ржирзНрждрж╛ржи ржерж╛ржХрзЗ, рждрж╛рж╣рж▓рзЗ рждрж╛ржХрзЗ queue-рждрзЗ ржпрзЛржЧ ржХрж░ржмрзЛред

if (front1->right && front2->right) 
            {
                q1.push(front1->right);
                q2.push(front2->right);
            }

тЮд ржбрж╛ржи рж╕ржирзНрждрж╛ржи ржерж╛ржХрж▓рзЗ рж╕рзЗржЯрж╛ржХрзЗржУ queue рждрзЗ ржкрзБрж╢ ржХрж░ржмрзЛред

}
        return ans;
    }
};


---

тЬЕ ржЧрж╛ржгрж┐рждрж┐ржХ ржмрж┐рж╢рзНрж▓рзЗрж╖ржг (Mathematical Analysis)

Time Complexity: O(n) тАФ рж╕ржм ржирзЛржб traverse ржХрж░рждрзЗ рж╣рждрзЗ ржкрж╛рж░рзЗ, ржХрж╛рж░ржг worst case ржП target рж╢рзЗрж╖ leaf ржП ржерж╛ржХрждрзЗ ржкрж╛рж░рзЗред

Space Complexity: O(n) тАФ Queue рждрзЗ ржПржХрж╕рж╛ржерзЗ level ржПрж░ рж╕ржм ржирзЛржб ржерж╛ржХрждрзЗ ржкрж╛рж░рзЗред



---

тЬЕ Test Case ржЙржжрж╛рж╣рж░ржг ржжрж┐рзЯрзЗ ржмрзНржпрж╛ржЦрзНржпрж╛

Input:

original = [7,4,3,null,null,6,19]
cloned   = [7,4,3,null,null,6,19]
target = node with value 3

Visualization:

Original:
      7
     / \
    4   3
       / \
      6   19

Target = node 3

Cloned Tree is exactly same, only pointer is different.

Step-by-step BFS:

1. Queue1 = [7], Queue2 = [7] тЖТ not match


2. Queue1 = [4,3], Queue2 = [4,3] тЖТ 3 matches


3. Return corresponding cloned 3 node тЬЕ




---

тЬЕ Follow-up: ржпржжрж┐ Tree-рждрзЗ repeated values ржерж╛ржХрзЗ?

рждрж╛рж╣рж▓рзЗ value ржжрж┐рзЯрзЗ ржЪрзЗржирж╛ ржпрж╛ржмрзЗ ржирж╛, ржХрж╛рж░ржг ржПржХрж╛ржзрж┐ржХ ржирзЛржбрзЗ same value ржерж╛ржХрждрзЗ ржкрж╛рж░рзЗред

тЮбя╕П рждржЦржи value ржжрж┐рзЯрзЗ ржирж╛ ржЪрзЗржХ ржХрж░рзЗ pointer comparison ржХрж░рждрзЗ рж╣ржмрзЗ:

if (front1 == target)
{
    return front2;
}


---

ЁЯФЪ рж╕ржВржХрзНрж╖рзЗржкрзЗ (Summary):

ржкрзНрж░рж╢рзНржи ржмрзЛржЭрж╛: Cloned ржЧрж╛ржЫ ржерзЗржХрзЗ target ржПрж░ рж╕ржорж╛ржи reference ржЦрзБржБржЬрзЗ ржмрзЗрж░ ржХрж░рж╛ред

рж╕ржорж╛ржзрж╛ржи ржнрж╛ржмрж╛: BFS ржХрж░рзЗ ржжрзБржЯрзЛ ржЧрж╛ржЫ ржПржХрж╕рж╛ржерзЗ traverse ржХрж░рзЗ value match ржкрзЗрж▓рзЗ рж╕рзЗржЗ ржкржЬрж┐рж╢ржирзЗрж░ cloned node return ржХрж░рж╛ред

Time: O(n), Space: O(n)

ржпржжрж┐ repeated value ржерж╛ржХрзЗ: pointer ржжрж┐рзЯрзЗ compare ржХрж░рждрзЗ рж╣ржмрзЗред


Full Code:
-------------

  class Solution
{
public:

TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target)   
{  
    queue<TreeNode*>q1;  
    queue<TreeNode*>q2;  
    q1.push(original);  
    q2.push(cloned);  
    TreeNode* ans;  
    while(!q1.empty()&&!q2.empty())  
    {  
      TreeNode* front1=q1.front();  
      TreeNode* front2=q2.front();  
      if(front1->val==target->val)//&&front2->val==target->val)  
      {  
          ans=front2;  
          break;  
      }  
      q1.pop();  
      q2.pop();  
      if (front1->left && front2->left)   
      {  
            q1.push(front1->left);  
            q2.push(front2->left);  
        }  

        if (front1->right && front2->right)   
        {  
            q1.push(front1->right);  
            q2.push(front2->right);  
        }  
    }  
    return ans;  
}

};
