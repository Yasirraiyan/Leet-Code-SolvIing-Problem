ЁЯФН Problem Understanding (ржкрзНрж░рж╢рзНржи ржмрж┐рж╢рзНрж▓рзЗрж╖ржг)

рждрзЛржорж╛ржХрзЗ ржПржХржЯрж┐ 0-indexed integer array ржжрзЗржУрзЯрж╛ рж╣ржмрзЗ nums ржирж╛ржорзЗред ржПржЦржи рждрзЛржорж╛ржХрзЗ ржмрзЗрж░ ржХрж░рждрзЗ рж╣ржмрзЗ:

ржР ржЕрзНржпрж╛рж░рзЗрждрзЗ length 2 ржПрж░ ржжрзБржЯрж┐ ржнрж┐ржирзНржи рж╕рж╛ржмржЕрзНржпрж╛рж░рзЗ (subarray) ржЖржЫрзЗ ржХрж┐ ржирж╛ ржпрж╛ржжрзЗрж░ sum ржПржХржЗред

рж╕рж╛ржмржЕрзНржпрж╛рж░рзЗ ржорж╛ржирзЗ ржПржХржЯрж╛ржирж╛ рзиржЯрж┐ ржЙржкрж╛ржжрж╛ржиред

ржжрзБржЗ рж╕рж╛ржмржЕрзНржпрж╛рж░рзЗ ржПржХржЗ ржЗржиржбрзЗржХрзНрж╕ ржерзЗржХрзЗ рж╢рзБрж░рзБ ржХрж░рждрзЗ ржкрж╛рж░ржмрзЗ ржирж╛, рждржмрзЗ рждрж╛ржжрзЗрж░ ржорж╛ржи ржПржХ рж╣рждрзЗ ржкрж╛рж░рзЗред



---

ЁЯза Thought Process (рж╕ржорж╕рзНржпрж╛ ржмрзБржЭрзЗ ржХрзАржнрж╛ржмрзЗ ржЪрж┐ржирзНрждрж╛ ржХрж░ржм)

1. ржпрзЗрж╣рзЗрждрзБ рж╕рж╛ржмржЕрзНржпрж╛рж░рзЗ-рж░ ржжрзИрж░рзНржШрзНржп ржирж┐рж░рзНржжрж┐рж╖рзНржЯ (рзи), рждрж╛ржЗ ржЖржорж░рж╛ рж╢рзБржзрзБржорж╛рждрзНрж░ рж╕ржм ржзрж╛рж░рж╛ржмрж╛рж╣рж┐ржХ ржЬрзЛрзЬрж╛ ржжрзЗржЦрждрзЗ ржкрж╛рж░рж┐:

nums[0], nums[1]

nums[1], nums[2]

nums[2], nums[3]

... ржПржнрж╛ржмрзЗ n-2 ржЗржиржбрзЗржХрзНрж╕ ржкрж░рзНржпржирзНрждред



2. ржкрзНрж░рждрзНржпрзЗржХ ржЬрзЛрзЬрж╛ nums[i] + nums[i+1] ржПржЗ ржлрж░рзНржорзЗ ржерж╛ржХржмрзЗред ржпржжрж┐ ржЖржЧрзЗ ржжрзЗржЦрж╛ ржХрзЛржирзЛ рж╕рж╛ржмржЕрзНржпрж╛рж░рзЗ-ржПрж░ sum ржЖржмрж╛рж░ ржЖрж╕рзЗ, рждрж╛рж╣рж▓рзЗ ржЙрждрзНрждрж░ trueред


3. ржПржЬржирзНржп ржЖржорж░рж╛ ржПржХржЯрж╛ hash set/map ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржм ржпрзЗржЯрж╛рждрзЗ ржЖржорж░рж╛ ржкрзНрж░рждрж┐ржЯрж┐ sum рж╕рзЗржн ржХрж░ржмред ржпржжрж┐ ржХрзЛржирзЛ sum ржПрж░ ржЖржЧрзЗ ржерзЗржХрзЗ ржЕрж╕рзНрждрж┐рждрзНржм ржерж╛ржХрзЗ, рждрж╛рж╣рж▓рзЗ ржЖржорж░рж╛ ржзрж░рзЗ ржирзЗржм ржпрзЗ рж╕ржорж╛ржи ржжрзБржЯрж┐ рж╕рж╛ржмржЕрзНржпрж╛рж░рзЗ ржкрж╛ржУрзЯрж╛ ржЧрзЗржЫрзЗред

ЁЯФО Line-by-line Code Explanation (рждрзЛржорж╛рж░ ржХрзЛржб ржмрж┐рж╢рзНрж▓рзЗрж╖ржг)

class Solution {
public:
    // ржПржХржЯрж┐ ржлрж╛ржВрж╢ржи ржпрж╛ ржПржХржЯрж┐ ржнрзЗржХрзНржЯрж░рзЗрж░ рж╕ржм ржЙржкрж╛ржжрж╛ржи ржпрзЛржЧржлрж▓ ржХрж░рзЗ
    int CalculateSum(vector<int>&v)
    {
        int sum=0;
        for(int i=0;i<v.size();i++)
        {
            sum+=v[i];
        }
        return sum;
    }

ЁЯФ╣ ржПржЦрж╛ржирзЗ CalculateSum ржлрж╛ржВрж╢ржиржЯрж╛ ржЕрждрж┐рж░рж┐ржХрзНржд ржХрж╛рж░ржг рждрзБржорж┐ рж╢рзБржзрзБ ржжрзБржЗржЯрж╛ ржЙржкрж╛ржжрж╛ржи ржпрзЛржЧ ржХрж░ржЫрзЛред рж╕рж░рж╛рж╕рж░рж┐ nums[i]+nums[j] рж▓рж┐ржЦрж▓рзЗ рж╕рзЗржЯрж╛ ржЖрж░ржУ рж╕рж╣ржЬ рж╣рждрзЛред


---

bool findSubarrays(vector<int>& nums)
    {
        unordered_map<int,int>freq; // sum ржЧрзБрж▓рзЛ ржЧржгржирж╛ рж░рж╛ржЦржмрзЗ

ЁЯФ╣ ржЖржорж░рж╛ map ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржЫрж┐ ржпрж╛рждрзЗ ржПржХржЗ sum ржХрзЯржмрж╛рж░ ржЖрж╕ржЫрзЗ рждрж╛ ржЧржгржирж╛ ржХрж░рждрзЗ ржкрж╛рж░рж┐ред


---

for(int i=0;i<nums.size();i++)
        {
            for(int j=i;j<nums.size();j++)
            {
                int subarraysize=j-i+1;
                if(subarraysize==2)
                {
                    vector<int>sub={nums[i],nums[j]};
                    freq[CalculateSum(sub)]++;
                }
            }
        }

ЁЯФ╣ рждрзБржорж┐ ржкрзНрж░рждрзНржпрзЗржХ i ржерзЗржХрзЗ j ржкрж░рзНржпржирзНржд рж╕ржм pair ржирж┐ржЪрзНржЫрзЛ ржПржмржВ ржпржЦржи j-i+1 == 2, рждржЦржи рж╕рзЗржЗ ржжрзБржЗржЯрж╛ ржЙржкрж╛ржжрж╛ржи ржирж┐рзЯрзЗ рж╕рж╛ржмржЕрзНржпрж╛рж░рзЗ рждрзИрж░рж┐ ржХрж░ржЫрзЛред

ЁЯЯб ржПржЗ ржЬрж╛рзЯржЧрж╛рзЯ ржжрзБржЗржЯрж┐ optimization ржХрж░рж╛ ржпрзЗржд:

рждрзБржорж┐ рж╢рзБржзрзБ adjacent i ржПржмржВ i+1 ржЗржиржбрзЗржХрзНрж╕ ржжрзЗржЦрждрзЗ ржкрж╛рж░рзЛ ржХрж╛рж░ржг ржжрзБржЗ ржЙржкрж╛ржжрж╛ржирзЗрж░ рж╕рж╛ржмржЕрзНржпрж╛рж░рзЗ adjacent рж╣рждрзЗ рж╣ржмрзЗред

ржПржЦржиржХрж╛рж░ ржХрзЛржб O(n^2) ржЯрж╛ржЗржо ржирж┐ржЪрзНржЫрзЗред ржЫрзЛржЯ ржЗржиржкрзБржЯрзЗ Accepted рж╣ржмрзЗ, ржХрж┐ржирзНрждрзБ ржмрзЬ ржЗржиржкрзБржЯрзЗ рж╕ржорж╕рзНржпрж╛ рж╣рждрзЛред



---

bool find=false;
        for(auto it:freq)
        {
            if(it.second>1)
            {
                find=true;
                break;
            }
        }
        return find;
    }
};

ЁЯФ╣ map-ржПрж░ ржоржзрзНржпрзЗ ржпржжрж┐ ржХрзЛржирзЛ sum ржПржХрж╛ржзрж┐ржХржмрж╛рж░ ржЖрж╕рзЗ (value > 1), рждрж╛рж╣рж▓рзЗ рж╕рзЗржЗ рж╕рж╛ржмржЕрзНржпрж╛рж░рзЗ ржПржХрж╛ржзрж┐ржХржмрж╛рж░ ржкрж╛ржУрзЯрж╛ ржЧрзЗржЫрзЗред


---

ЁЯФв Mathematical Logic

Suppose array = [a, b, c, d]

All subarrays of size 2:

[a, b] тЖТ sum = a + b

[b, c] тЖТ sum = b + c

[c, d] тЖТ sum = c + d


We just check if any two of these sums are equal.


---

ЁЯзк Test Cases with Trace

Example 1:

nums = [4,2,4]
Sums: 
[4,2] = 6
[2,4] = 6 тЖТ already seen тЖТ return true

Example 2:

nums = [1,2,3,4,5]
Sums:
[1,2] = 3
[2,3] = 5
[3,4] = 7
[4,5] = 9 тЖТ all unique тЖТ return false

Example 3:

nums = [0,0,0]
Sums:
[0,0] = 0
[0,0] = 0 тЖТ already seen тЖТ return true


---

ЁЯУЪ Summary

ржмрж┐рж╖рзЯ	ржмрзНржпрж╛ржЦрзНржпрж╛

ржкрзНрж░рж╢рзНржи	ржжрзБржЗржЯрж┐ ржнрж┐ржирзНржи ржЗржиржбрзЗржХрзНрж╕рзЗ рж╢рзБрж░рзБ рж╣ржУрзЯрж╛ рзи рж╕рж╛ржЗржЬрзЗрж░ рж╕рж╛ржмржЕрзНржпрж╛рж░рзЗ-ржПрж░ sum ржХрж┐ рж╕ржорж╛ржи?
ржХрзМрж╢рж▓	ржкрзНрж░рждрзНржпрзЗржХ i рждрзЗ nums[i]+nums[i+1] ржмрзЗрж░ ржХрж░рзЗ ржЖржЧрзЗрж░ ржжрзЗржЦрж╛ sum ржЧрзБрж▓рзЛ рж╕рж╛ржерзЗ ржорзЗрж▓рж╛ржирзЛ
ржЯрж╛ржЗржо ржХржоржкрзНрж▓рзЗржХрзНрж╕рж┐ржЯрж┐	рждрзЛржорж╛рж░ ржХрзЛржбрзЗ O(n^2), ржХрж┐ржирзНрждрзБ efficient рж╣рж▓рзЗ O(n)
ржбрзЗржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░	unordered_map ржмрж╛ unordered_set


Full Code:
-----------

  class Solution
{
public:
    int CalculateSum(vector<int>&v)
    {
        int sum=0;
        for(int i=0;i<v.size();i++)
            {
                sum+=v[i];
            }
        return sum;
    }
    bool findSubarrays(vector<int>& nums)
    {
        unordered_map<int,int>freq;
        for(int i=0;i<nums.size();i++)
            {
                for(int j=i;j<nums.size();j++)
                    {
                        int subarraysize=j-i+1;
                                if(subarraysize==2)
                               {
                                vector<int>sub={nums[i],nums[j]};
                                {
                                    freq[CalculateSum(sub)]++;         
                                }
                            }
                    }
                    }
        bool find=false;
        for(auto it:freq)
            {
                if(it.second>1)
                {
                    find=true;
                    break;
                }
            }
        return find;
    }
};
