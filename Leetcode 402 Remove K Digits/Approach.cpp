সমস্যা (Problem) কি?
তোমাকে একটা স্ট্রিং num দেওয়া আছে, যা একটা বড় সংখ্যা হিসেবে দেয়া হয়েছে, এবং একটা সংখ্যা k যা নির্দেশ করে তোমাকে num থেকে মোট kটা ডিজিট মুছে সবচেয়ে ছোট সংখ্যা তৈরি করতে হবে।

উদাহরণ:

num = "1432219", k = 3
সবচেয়ে ছোট সংখ্যা: "1219"
(4, 3, 2 এই ৩ ডিজিট মুছে)

num = "10200", k = 1
সবচেয়ে ছোট সংখ্যা: "200"
(শুরুয়ের 1 মুছে)

num = "10", k = 2
সব ডিজিট মুছে গেলে সংখ্যা থাকে "0"

সমস্যার বোধগম্যতা (How to think about the problem):
তোমাকে কেবল k টি ডিজিট মুছে সবচেয়ে ছোট সংখ্যা করতে হবে।

সংখ্যার ডিজিটের অর্ডার বদলানো যাবে না।

লিডিং জিরো (leading zero) থাকা যাবে না, অর্থাৎ শেষে "0" ছাড়া অন্য কোনো ফাঁকা স্ট্রিং দিলে "0" রিটার্ন করতে হবে।

কৌশল (Approach):
যখন সংখ্যা থেকে ডিজিট মুছতে হবে, তখন ছোট ডিজিটগুলো আগে রাখা ভালো যাতে সংখ্যাটা ছোট হয়।

এর মানে, যদি কোনো বড় ডিজিটের পর ছোট ডিজিট আসে, তাহলে বড় ডিজিটটাকে মুছে ফেলা উচিত।

স্ট্যাক ব্যবহার করে এই কাজটা করা হয়:

এক একটা ডিজিট ধরে স্ট্যাকের সাথে তুলনা করো।

যদি স্ট্যাকের টপ ডিজিট বড় হয় এবং তুমি এখন যে ডিজিট দেখছ সেটা ছোট হয়, তাহলে স্ট্যাক থেকে বড় ডিজিট মুছে ফেলো (যতক্ষণ তুমি k ডিজিট মুছতে পারো)।

এরপর নতুন ডিজিট স্ট্যাকে পুশ করো।

এইভাবে সংখ্যা থেকে বড় ডিজিটগুলো সরাতে পারো যেগুলো পরে ছোট ডিজিটের আগমন ঘটছে, ফলে ছোট সংখ্যার দিকে অগ্রসর হওয়া সম্ভব।

কোডের ব্যাখ্যা লাইন বাই লাইন:
cpp
Copy
Edit
class Solution {
public:
    string removeKdigits(string num, int k) {
        stack<char> st;
        
        if (num.empty()) return "0";  // যদি সংখ্যাটা ফাঁকা হয়, রিটার্ন 0
প্রথমেই চেক করো num ফাঁকা কিনা, যদি ফাঁকা হয়, সরাসরি "0" রিটার্ন।

cpp
Copy
Edit
        st.push(num[0]);  // প্রথম ডিজিট স্ট্যাকে রাখো
        for(int i = 1; i < num.size(); i++) {
            while(!st.empty() && k > 0 && st.top() > num[i]) {
                st.pop();
                k--;
            }
            st.push(num[i]);
        }
প্রথম ডিজিটটা স্ট্যাকে রাখো।

এরপর num এর বাকি ডিজিটগুলোর জন্য লুপ শুরু করো।

ভিতরে while লুপ:

যতক্ষণ স্ট্যাক ফাঁকা নয়,

এবং k > 0 অর্থাৎ ডিজিট মুছে ফেলার সুযোগ আছে,

এবং স্ট্যাকের টপের ডিজিট নতুন ডিজিটের থেকে বড় (মানে বড় ডিজিট আগে),
তখন স্ট্যাক থেকে বড় ডিজিট পপ করো এবং k কমাও।

শেষ পর্যন্ত বর্তমান ডিজিট স্ট্যাকে ঢুকাও।

cpp
Copy
Edit
        // যদি এখনও k > 0 থাকে, তাহলে স্ট্যাকের শেষ থেকে k ডিজিট পপ করো
        while(k > 0 && !st.empty()) {
            st.pop();
            k--;
        }
যদি লুপ শেষে k ডিজিট পুরো মুছে না ফেলতে পারো, তাহলে স্ট্যাকের শেষে বড় ডিজিটগুলো সরাতে থাকবে।

cpp
Copy
Edit
        string s = "";
        while(!st.empty()) {
            s += st.top();
            st.pop();
        }
এখন স্ট্যাকের সব ডিজিট নিচের দিকে লুপ করে s তে যোগ করো।

স্ট্যাক হলো LIFO, তাই সংখ্যাটা উল্টো অবস্থায় এসেছে।

cpp
Copy
Edit
        string ans = "";
        for(int j = s.size() - 1; j >= 0; j--) {
            ans += s[j];
        }
উপরের s স্ট্রিংটা উল্টে ans এ রাখো যাতে ডিজিটগুলো সঠিক অর্ডারে থাকে।

cpp
Copy
Edit
        int pos = 0;
        while(pos < ans.size() && ans[pos] == '0') {
            pos++;
        }
        ans = ans.substr(pos);  // লিডিং জিরো কেটে ফেলো
লিডিং জিরো গুলো কেটে ফেলা হচ্ছে।

যতক্ষণ ans এর প্রথম অক্ষর 0 ততক্ষণ এগো।

cpp
Copy
Edit
        if(ans.empty()) return "0";  // যদি সব মুছে যায়, তাহলে 0 রিটার্ন করো
        return ans;
    }
};
সব ডিজিট মুছে গেলে ফাঁকা স্ট্রিং আসতে পারে, তাই "0" রিটার্ন।

অন্যথায়, পাওয়া সংখ্যাটি রিটার্ন করো।

কোডের কাজের পদ্ধতি টেস্ট কেস দিয়ে:
টেস্ট কেস ১: num = "1432219", k = 3
স্ট্যাক শুরু: 1

দেখা 4, স্ট্যাক টপ 1 < 4 → 4 ঢুকাও। স্ট্যাক: [1,4]

দেখা 3, স্ট্যাক টপ 4 > 3 এবং k=3 থাকায় 4 পপ, k=2
আবার স্ট্যাক টপ 1 < 3 → থেমে যাও
স্ট্যাক: [1], তারপর 3 ঢুকাও → [1,3]

দেখা 2, স্ট্যাক টপ 3 > 2, k=2 তাই 3 পপ, k=1
স্ট্যাক টপ এখন 1 < 2, থামো
ঢুকাও 2 → [1,2]

দেখা আরেক 2, স্ট্যাক টপ 2 == 2 তাই ঢুকাও → [1,2,2]

দেখা 1, স্ট্যাক টপ 2 > 1, k=1 → পপ 2, k=0
আর পপ করো না কারণ k=0
ঢুকাও 1 → [1,2,1]

দেখা 9, ঢুকাও → [1,2,1,9]

এখন k=0, শেষ।

স্ট্যাক থেকে নম্বর উল্টে নেওয়া হলো "9121" → উল্টালে "1219"

লিডিং জিরো নেই।

ফলাফল: "1219" — ঠিক আছে!

টেস্ট কেস ২: num = "10200", k = 1
স্ট্যাক: 1

দেখা 0, স্ট্যাক টপ 1 > 0, k=1 → পপ 1, k=0

ঢুকাও 0 → [0]

দেখা 2, ঢুকাও → [0,2]

দেখা 0, ঢুকাও → [0,2,0]

দেখা 0, ঢুকাও → [0,2,0,0]

k=0, শেষ।

স্ট্যাক থেকে পড়ো: "0020" → উল্টালে "0020"

লিডিং জিরো কেটে দিলে → "200"

ফলাফল: "200" — ঠিক আছে!

টেস্ট কেস ৩: num = "10", k = 2
স্ট্যাক: 1

দেখা 0, স্ট্যাক টপ 1 > 0, k=2 → পপ 1, k=1

ঢুকাও 0 → [0]

এখন লুপ শেষ, কিন্তু k=1 → পপ শেষ ডিজিট 0, k=0

স্ট্যাক খালি → মানে সংখ্যা ফাঁকা

তাই "0" রিটার্ন

ঠিক আছে!

সারসংক্ষেপ:
স্ট্যাক দিয়ে আমরা বড় ডিজিটগুলো পপ করি যখন পরবর্তী ডিজিট ছোট হয়।

k যতদিন থাকে, ডিজিট মুছে ফেলা হয়।

শেষে বাকি k থাকলে স্ট্যাকের শেষ থেকে পপ করা হয়।

শেষে লিডিং জিরো কেটে ছোট সংখ্যা তৈরি হয়।


  Full Code:
---------------

  class Solution 
{
public:
    string removeKdigits(string num, int k) 
    {
        stack<char>st;
          if (num.empty()) return "0";

        st.push(num[0]);
        int count=0;
        for(int i=1;i<num.size();i++)
        {
           while(!st.empty()&&k>0&&st.top()>num[i])
           {
            char top=st.top();
          /*  if(top-'0'<num[i]-'0')
            {
              st.pop();
            }
            */
            st.pop();
            
            k--;
           }
          
              st.push(num[i]);
            
        }
        string s="";
        while(k>0&&!st.empty())
        {
          char topp=st.top();
          //s+=topp;
          st.pop();
          k--;
        }
        while(!st.empty())
        {
          s+=st.top();
          st.pop();
        }
        string ans="";
        for(int j=s.size()-1;j>=0;j--)
       {
        ans+=s[j];
       }
       int pos = 0;
        while (pos < ans.size() && ans[pos] == '0') {
            pos++;
        }
        ans = ans.substr(pos);

        if (ans.empty()) return "0";

        return ans;
    }
      
    
};

ফাঁকা হলে "0" রিটার্ন করা হয়।
