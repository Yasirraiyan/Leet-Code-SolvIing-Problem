সমস্যা কি?
তোমাকে একটা integer array দেওয়া আছে।
তোমার কাজ:

প্রতিটি সংখ্যার বাইনারি রেপ্রেজেন্টেশনে কয়টা 1 আছে সেটা দেখে সেই সংখ্যা গুলো সাজাতে হবে।

যদি দুই বা ততোধিক সংখ্যার 1 এর সংখ্যা সমান হয়, তাহলে তাদের ছোট থেকে বড় ক্রমানুসারে সাজাবে।

কোডের মূল ধারণা
১. One(int n) ফাংশন:
এই ফাংশনের কাজ হলো, একটি integer n এর বাইনারি রেপ্রেজেন্টেশনে কতগুলো 1 আছে সেটা গোনা।

এটা করতে, তোমরা হয়তো ভাববে:

n কে বাইনারি ফর্মে ভাঙো।

প্রতিবার n % 2 করলে শেষ বিট (0 অথবা 1) পাবে।

যদি সেটা 1 হয়, তাহলে কাউন্টার বাড়াও।

এরপর n = n / 2 করো, যাতে পরের বিট পেতে পারো।

যতক্ষণ n > 0 থাকবে, এই কাজ করবে।

শেষে count রিটার্ন করবে — যেটা হলো 1 এর মোট সংখ্যা।

২. Compare(int a, int b) ফাংশন:
এইটা একটা static কম্প্যারেটর ফাংশন, যা sort এর জন্য ইউজ করা হবে।

এখানে তোমার কাজ হলো দুইটা ইনপুট a এবং b এর মধ্যে কোনটা আগে আসবে সেটা ঠিক করা।

প্রথমে দুইটার 1 এর সংখ্যা বের করবে (using One ফাংশন)।

যদি দুইটার 1 এর সংখ্যা সমান হয়, তাহলে ছোট সংখ্যাটাকে আগে আনবে।

আর যদি 1 এর সংখ্যা আলাদা হয়, তাহলে যেটার 1 বেশি, সেটা পরে আসবে।

৩. sortByBits(vector<int>& arr) ফাংশন:
এখানে sort ফাংশনে তোমার Compare ফাংশন ইউজ করছো।

sort ফাংশন arr কে তোমার দেওয়া শর্ত অনুযায়ী সাজিয়ে দেবে।

তারপর arr রিটার্ন করবে।

কিভাবে চিন্তা করে তুমি কোড লিখতে পারো?
প্রথমে, প্রশ্ন পড়ে বুঝতে হবে: সংখ্যাগুলোর বাইনারি রিপ্রেজেন্টেশনে 1 এর সংখ্যা অনুযায়ী সাজাতে হবে।

তাই 1 এর সংখ্যা গোনার একটা ফাংশন দরকার। সেটা হলো One().

এরপর sort এ তোমাকে কম্প্যারেটর দিতে হবে, যেখানে প্রথমে 1 এর সংখ্যা কম্পেয়ার করবে, আর যদি সমান হয়, তাহলে সংখ্যার মান কম্পেয়ার করবে।

সুতরাং, Compare ফাংশনে দুইটা সংখ্যার 1 এর সংখ্যা বের করে তুলনা করো, এবং শর্ত অনুসারে রিটার্ন করো।

শেষে sort ব্যবহার করো।

Test Case দিয়ে লাইন বাই লাইন ব্যাখ্যা (Example 1):
Input: arr = [0,1,2,3,4,5,6,7,8]

Step 1: One() ফাংশন দিয়ে 1 এর সংখ্যা বের করা
Number	Binary	Number of 1's
0	0	0
1	1	1
2	10	1
3	11	2
4	100	1
5	101	2
6	110	2
7	111	3
8	1000	1

Step 2: Sort comparison অনুসারে সাজানো হবে:
প্রথমে 1 এর সংখ্যা কম হওয়ার ভিত্তিতে।

যদি 1 এর সংখ্যা সমান হয়, তাহলে সংখ্যার ছোট থেকে বড় ক্রম।

Step 3: Sorted order:
0 (0 ones)

Among numbers with 1 one: 1, 2, 4, 8 → sorted ascending: 1, 2, 4, 8

Among numbers with 2 ones: 3, 5, 6 → sorted ascending: 3, 5, 6

7 (3 ones)

Final: [0, 1, 2, 4, 8, 3, 5, 6, 7]

কেন এই কোড Accepted হয়?
কারণ One() ফাংশন সঠিকভাবে বাইনারি রিপ্রেজেন্টেশনের 1 গুলো গুনে।

Compare() ফাংশন সঠিকভাবে তোমার প্রয়োজনীয় শর্ত মেনে তুলনা করে।

sort() STL ফাংশন সঠিকভাবে কম্প্যারেটর ব্যবহার করে তোমার array কে সাজিয়ে দেয়।

কোডের টাইম কমপ্লেক্সিটি O(n log n * k), যেখানে n=array size, k=bit length (maximum 14 bits for 10^4), যা constraints এর মধ্যে ভালো কাজ করে।

সংক্ষেপে বাংলায়:
তুমি প্রথমে বুঝবে, "কীভাবে গুনবো 1 গুলো?" → One() ফাংশন।

তারপর বুঝবে, "কীভাবে সাজাবো?" → Compare() ফাংশন, যেটা sort এ দিবে।

তারপর sort() কল করো।

প্রতিটি ধাপেই তুমি লজিকটা বুজে ধাপে ধাপে কাজ করো।

Full Code:
----------

  class Solution 
{
public:
int One(int n)
{
  int count=0;
  while(n>0)
  {
    int rem=n%2;
    if(rem==1)
    {
      count++;
    }
    n=n/2;
  }
  return count;
}
   static  bool Compare(int a,int b)
   {
     Solution sol;  
     int a1=sol.One(a);
     int b1=sol.One(b);
    if(a1==b1)
    {
      return a<b;
    }
     return a1<b1;
   }
    vector<int> sortByBits(vector<int>& arr)
     {
      sort(arr.begin(),arr.end(),Compare);
      return arr;
    }
};
