ЁЯза ржкрзНрж░рж╛ржержорж┐ржХ ржмрзЛржЭрж╛ржкрзЬрж╛ (Problem Understanding):

ржкрзНрж░рж╢рзНржирзЗ ржмрж▓рж╛ рж╣рзЯрзЗржЫрзЗ, ржжрзБржЗржЯрж┐ singly linked list ржжрзЗржУрзЯрж╛ ржерж╛ржХржмрзЗ тАФ headA ржПржмржВ headBред ржПржЧрзБрж▓рзЛ ржХрзЛржирзЛ ржПржХ ржЬрж╛рзЯржЧрж╛ ржерзЗржХрзЗ ржПржХрж╕рж╛ржерзЗ ржорж┐рж▓рзЗ ржпрзЗрждрзЗ ржкрж╛рж░рзЗ (intersect)ред ржЕрж░рзНржерж╛рзО, ржПржХржЯрж┐ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ node ржерзЗржХрзЗ рждрж╛рж░рж╛ ржПржХржЗ linked list рж╣рж┐рж╕рж╛ржмрзЗ ржЪрж▓рждрзЗ ржкрж╛рж░рзЗред

рждрзБржорж┐ ржУржЗ common intersection node ржЯрж╛ return ржХрж░ржмрзЗ, ржпржжрж┐ рждрж╛рж░рж╛ intersect ржХрж░рзЗред ржЖрж░ ржпржжрж┐ ржирж╛ ржХрж░рзЗ, рждрж╛рж╣рж▓рзЗ return ржХрж░ржмрзЗ nullptr ржмрж╛ nullред

Example:

ListA: 4 тЖТ 1 тЖТ 8 тЖТ 4 тЖТ 5  
ListB: 5 тЖТ 6 тЖТ 1 тЖШ  
                  8 тЖТ 4 тЖТ 5

ржПржЗржЦрж╛ржирзЗ 8 node ржерзЗржХрзЗ ржжрзБржЗржЯрж╛ list ржПржХрж╕рж╛ржерзЗ рж╣рзЯрзЗ ржЧрзЗржЫрзЗред рж╕рзБрждрж░рж╛ржВ ржЙрждрзНрждрж░ рж╣ржмрзЗ 8 ржПрж░ pointerред


---

тЬЕ ржХрзА ржЪрж╛ржЗ?

ржжрзБржЗржЯрж┐ linked list ржЖржЫрзЗред

ржпржжрж┐ рждрж╛рж░рж╛ ржХрзЛржирзЛ common node ржП intersect ржХрж░рзЗ, ржУржЗ node return ржХрж░рждрзЗ рж╣ржмрзЗред

ржирж╛ ржХрж░рж▓рзЗ, nullptr return ржХрж░рждрзЗ рж╣ржмрзЗред



---

ЁЯФН Approach ржмрзБржЭрж┐ (Set ржжрж┐рзЯрзЗ Solution)

рждрзБржорж┐ ржпрзЗ ржХрзЛржбржЯрж┐ ржХрж░рзЗржЫрзЛ, рж╕рзЗржЯрж╛ рж╣рж▓рзЛ:

> Approach 1: HashSet / unordered_set ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ



тЮд Step-by-step:

1. ржкрзНрж░ржержорзЗ headA ржПрж░ рж╕ржм node ржЧрзБрж▓рзЛ ржПржХрзЗ ржПржХрзЗ ржПржХржЯрж┐ unordered_set ржП рж░рж╛ржЦрзЛред


2. ржПрж░ржкрж░ headB ржПрж░ ржкрзНрж░рждрж┐ржЯрж┐ node check ржХрж░рзЛ тАФ ржпржжрж┐ рж╕рзЗржЯрж╛рж░ pointer (address) set ржПрж░ ржоржзрзНржпрзЗ ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯ, рждрж╛рж╣рж▓рзЗ ржмрзБржЭржмрзЗ ржПржЯрж┐ржЗ intersection pointред


3. рждржЦржи рж╕рзЗржЗ node return ржХрж░рзЛред


4. ржпржжрж┐ ржПржХржЯрж╛ржУ ржирж╛ ржорж┐рж▓рзЗ, рждрж╛рж╣рж▓рзЗ return ржХрж░рзЛ nullptr.



тЬи Core Logic:

> рждрзБржорж┐ node ржПрж░ value ржирж╛ ржжрзЗржЦрзЗ pointer ржжрзЗржЦрзЗ check ржХрж░ржЫрзЛред
ржХрж╛рж░ржг ржжрзБржЗржЯрж┐ list ржПрж░ value ржПржХржЗ рж╣рж▓рзЗржУ ржпржжрж┐ pointer ржЖрж▓рж╛ржжрж╛ рж╣рзЯ, рждрж╛рж╣рж▓рзЗ рж╕рзЗржЧрзБрж▓рзЛ ржнрж┐ржирзНржи nodeред




---

тЬЕ Time & Space Complexity:

Time Complexity: O(m + n)
(m = listA ржПрж░ ржжрзИрж░рзНржШрзНржп, n = listB ржПрж░ ржжрзИрж░рзНржШрзНржп)

Space Complexity: O(m)
(рждрзБржорж┐ listA ржПрж░ mржЯрж┐ node set ржП рж░рж╛ржЦржЫрзЛ)



---

ЁЯзк Test Case Analysis:

тЬЕ Test Case 1:

listA = [4,1,8,4,5]
listB = [5,6,1,8,4,5]
skipA = 2, skipB = 3, intersectVal = 8

рждрзБржорж┐ ржкрзНрж░ржержорзЗ listA ржПрж░ рж╕ржм node set ржП рж░рж╛ржЦрж▓рзЗ: {4, 1, 8, 4, 5} тЖТ (but actually memory address)

рждрж╛рж░ржкрж░ listB traverse ржХрж░рзЛ:

5 тЖТ 6 тЖТ 1 тЖТ 8 тЖТ ржорзНржпрж╛ржЪ! ржХрж╛рж░ржг pointer match ржХрж░рзЗред


So, return 8.


тЬЕ Test Case 2:

listA = [1,9,1,2,4], skipA=3
listB = [3,2,4], skipB=1, intersectVal=2

рждрзЛржорж╛рж░ set: {1,9,1,2,4}

listB traverse:

3 тЖТ 2 тЖТ pointer match!


Return 2.


тЬЕ Test Case 3:

listA = [2,6,4], listB = [1,5], intersectVal = 0

Set: {2,6,4}

Traverse B: 1 тЖТ 5 тЖТ ржХрзЛржиржЯрж╛ match ржХрж░рж▓рзЛ ржирж╛ред

Return nullptr.



---

ЁЯФН рждрзБржорж┐ ржХрзАржнрж╛ржмрзЗ ржнрж╛ржмржмрзЗ рж╕ржорж╛ржзрж╛ржи ржХрж░рж╛рж░ рж╕ржорзЯ?

ржкрзНрж░рж╢рзНржиржЯрж╛ ржкрзЬрж╛рж░ рж╕ржорзЯ ржЪрж┐ржирзНрждрж╛ ржХрж░рзЛ:

ржжрзБржЗржЯрж┐ linked list ржПрж░ structure retain ржХрж░рждрзЗ рж╣ржмрзЗ (modify ржХрж░рж╛ ржпрж╛ржмрзЗ ржирж╛)

pointer comparison ржХрж░рждрзЗ рж╣ржмрзЗ (value ржирж╛)

рждрж╛ржЗ, ржПржХржЯрж╛рж░ рж╕ржм pointer ржЖржЧрзЗ collect ржХрж░рзЗ рж░рж╛ржЦрж┐ тЖТ ржЕржирзНржпржЯрж╛ ржкрж░рзЗ check ржХрж░рж┐ред


ржПржЗ ржнрж╛ржмржирж╛ ржерзЗржХрзЗ рждрзБржорж┐ naturally unordered_set ржмрж╛ HashSet ржПрж░ solution ржП ржЖрж╕рждрзЗ ржкрж╛рж░рзЛред


Full Code:
------------

  class Solution 
{
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) 
    {
        unordered_set<ListNode*> set1;
        ListNode* ans=nullptr;
        while(headA!=nullptr)
            {
                set1.insert(headA);
                headA=headA->next;
            }
       while(headB!=nullptr)
           {
               if(set1.find(headB)!=set1.end())
               {
                   ans=headB;
                   break;
               }
               headB=headB->next;
           }
        return ans;
    }
};
