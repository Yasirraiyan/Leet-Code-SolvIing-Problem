প্রশ্নটি বুঝে নেওয়া:

তোমাকে একটি সংখ্যা অ্যারে nums দেওয়া আছে এবং একটি সংখ্যা k.

তুমি এক অপারেশনে দুটি সংখ্যা বাছাই করতে পারবে যেগুলোর যোগফল k হয় এবং সেগুলো অ্যারেতে থেকে মুছে দেবে।

তোমার কাজ: সর্বোচ্চ কতটি অপারেশন করা যাবে, তা বের করা।

উদাহরণ 1:

nums = [1,2,3,4], k = 5
যুগল: (1,4) এবং (2,3) → 2 অপারেশন


উদাহরণ 2:

nums = [3,1,3,4,3], k = 6
যুগল: (3,3) → 1 অপারেশন

তুমি কিভাবে সমাধান ভাবতে পারবে (Problem-solving approach):

তুমি খুঁজছো এমন জোড় সংখ্যা যেখানে যোগফল = k.

সমস্যার ক্ষেত্রে পজিশন বা অর্ডার গুরুত্বপূর্ণ নয়, তাই তুমি অ্যারেকে সাজাতে পারো।

সাজানোর পরে তুমি সহজেই দুই প্রান্ত থেকে সংখ্যা বেছে নাও:

ছোটতম (low) + বড়তম (high) সংখ্যা → যদি যোগফল k হয়, অপসারণ করো।

যদি যোগফল ছোট হয় → ছোট সংখ্যা বড়াতে হবে → low++

যদি যোগফল বড় হয় → বড় সংখ্যা ছোটাতে হবে → high--

এই পদ্ধতি দুই-পয়েন্টার টেকনিক (Two-pointer technique) নামে পরিচিত।

কোড বিশ্লেষণ লাইন বাই লাইন:
sort(nums.begin(),nums.end());


অ্যারেটি ascending order এ সাজানো হয়েছে।

কারণ সাজালে দুই-পয়েন্টার পদ্ধতি সহজে ব্যবহার করা যায়।

int low=0;
int high=nums.size()-1;
int count=0;


low → প্রথম (ছোট) ইনডেক্স

high → শেষ (বড়) ইনডেক্স

count → অপারেশনের সংখ্যা

while(low<high)


যতক্ষণ low এবং high ক্রস করছে না, ততক্ষণ চেক করব।

if(nums[low]+nums[high]==k)
{
    low++;
    high--;
    count++;
}


যদি যোগফল k হয় → আমরা এটি অপসারণ করেছি → দুটো পয়েন্টার আপডেট + অপারেশন কাউন্ট।

if(nums[low]+nums[high]<k)
{
    low++;
}


যোগফল ছোট → বড় সংখ্যা দরকার → ছোট দিক বাড়াও।

if(nums[low]+nums[high]>k)
{
    high--;
}


যোগফল বড় → ছোট সংখ্যা দরকার → বড় দিক ছোটাও।

return count;


শেষ পর্যন্ত সর্বোচ্চ অপারেশন সংখ্যা রিটার্ন করি।

কেন কোড Accepted হলো:

দুই-পয়েন্টার টেকনিকের কারণে Efficient:

সময় জটিলতা: O(n log n) (সাজানো) + O(n) (লুপ) → মোট O(n log n)

স্থান জটিলতা: O(1) (কোনো extra array নয়)

Test case analysis:

nums = [1,2,3,4], k = 5

low=1, high=4 → যোগফল=5 → count=1 → remove (1,4)

low=2, high=3 → যোগফল=5 → count=2 → remove (2,3) → done

nums = [3,1,3,4,3], k = 6

sort → [1,3,3,3,4]

low=1, high=4 → যোগফল=5<6 → low++

low=2, high=4 → যোগফল=7>6 → high--

low=2, high=3 → যোগফল=6 → count=1 → remove (3,3)

শিখার পয়েন্ট (Bangla):

প্রশ্ন পড়লে বোঝা দরকার কোনো জোড় সংখ্যা খুঁজতে হবে যেখানে যোগফল k।

যদি অ্যারের অর্ডার গুরুত্বপূর্ণ না হয় → সাজানো + দুই-পয়েন্টার পদ্ধতি ব্যবহার।

দুই-পয়েন্টার টেকনিক:

ছোট দিক থেকে এক পয়েন্টার (low)

বড় দিক থেকে এক পয়েন্টার (high)

যোগফল অনুযায়ী পয়েন্টার adjust করা

Efficiency এর কারণে বড় ইনপুটের ক্ষেত্রেও Accepted।

✅ Summary in one line:

দুই-পয়েন্টার টেকনিক ব্যবহার করে সাজানো অ্যারে থেকে সর্বোচ্চ সংখ্যক k যোগফল জোড়া বের করে অপসারণ করি।

  Full CodE:
  ------------

    class Solution {
public:
    int maxOperations(vector<int>& nums, int k) {
     sort(nums.begin(),nums.end());
     int low=0;
     int high=nums.size()-1;
     int count=0;
     while(low<high)
  {
    if(nums[low]+nums[high]==k)
    {
        low++;
        high--;
        count++;
    }
      if(nums[low]+nums[high]<k)
      {
        low++;
      }
       if(nums[low]+nums[high]>k)
      {
       high--;
      }
    
  }
  return count;

    }
};
