ЁЯФ╢ ржкрзНрж░рж╢рзНржиржЯрж╛ ржХрзА ржмрж▓ржЫрзЗ?

рждрзЛржорж╛ржХрзЗ ржПржХржЯрж┐ рж▓рж┐ржЩрзНржХржб рж▓рж┐рж╕рзНржЯрзЗрж░ head ржжрзЗржУрзЯрж╛ ржЖржЫрзЗред
рждрзЛржорж╛ржХрзЗ ржХрж░рждрзЗ рж╣ржмрзЗ:

рж▓рж┐рж╕рзНржЯрзЗрж░ ржоржзрзНржпрзЗрж░ (middle) ржирзЛржбржЯрж╛ ржбрж┐рж▓рж┐ржЯ ржХрж░рждрзЗ рж╣ржмрзЗред

рждрж╛рж░ржкрж░ ржкрж░рж┐ржмрж░рзНрждрж┐ржд рж▓рж┐рж╕рзНржЯржЯрж╛ рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рждрзЗ рж╣ржмрзЗред


ЁЯФ╕ "Middle Node" ржорж╛ржирзЗ ржХрзА?

ржорзЛржЯ n рж╕ржВржЦрзНржпржХ ржирзЛржб ржерж╛ржХрж▓рзЗ,

Middle index = тМКn / 2тМЛ (0-based index)

ржЕрж░рзНржерж╛рзО:

n = 1 тЖТ index 0

n = 2 тЖТ index 1

n = 3 тЖТ index 1

n = 4 тЖТ index 2

n = 5 тЖТ index 2




---

ЁЯФ╢ рждрзБржорж┐ ржХрзАржнрж╛ржмрзЗ ржЪрж┐ржирзНрждрж╛ ржХрж░ржЫрзЛ?

ржкрзНрж░ржержорзЗ рждрзБржорж┐ ржнрзЗржмрзЗржЫрзЛ:

1. рж▓рж┐рж╕рзНржЯржЯрж╛ржХрзЗ array/vector рждрзЗ ржХржиржнрж╛рж░рзНржЯ ржХрж░рзЗ ржирзЗржЗ тАФ ржпрж╛рждрзЗ index ржжрж┐рзЯрзЗ рж╕рж╣ржЬрзЗ middle ржмрзЗрж░ ржХрж░рж╛ ржпрж╛рзЯред


2. рждрж╛рж░ржкрж░ рж╕рзЗржЗ index ржмрж╛ржж ржжрж┐рзЯрзЗ ржирждрзБржи ржнрзЗржХрзНржЯрж░ ржмрж╛ржирж╛ржУ (middle ржЫрж╛рзЬрж╛ ржмрж╛ржХрж┐ рж╕ржм item рж░рж╛ржЦрзЛ)ред


3. ржПрж░ржкрж░ рж╕рзЗржЗ ржнрзЗржХрзНржЯрж░ ржерзЗржХрзЗ ржирждрзБржи рж▓рж┐ржЩрзНржХржб рж▓рж┐рж╕рзНржЯ ржмрж╛ржирж╛ржУред


4. ржирждрзБржи рж╣рзЗржб рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рзЛред




---

ЁЯФ╢ ржзрж╛ржкрзЗ ржзрж╛ржкрзЗ ржмрзНржпрж╛ржЦрзНржпрж╛ (Bangla):

тЬЕ Step 1: Base Case Check

if(head == nullptr || head->next == nullptr)
    return nullptr;

ржпржжрж┐ рж▓рж┐рж╕рзНржЯ ржПржХржжржо ржЦрж╛рж▓рж┐ рж╣рзЯ ржЕржержмрж╛ рж╢рзБржзрзБ рззржЯрж┐ ржирзЛржб ржерж╛ржХрзЗ,
рждрж╛рж╣рж▓рзЗ рж╕рзЗржЯрж╛ ржоржзрзНржпрзЗрж░ ржирзЛржбржЗ тАФ рждрж╛ржЗ return nullptr (ржорж╛ржирзЗ: ржкрзБрж░рзЛ рж▓рж┐рж╕рзНржЯ ржбрж┐рж▓рж┐ржЯ)ред



---

тЬЕ Step 2: Linked List тЖТ Vector

vector<int> v;
while(head != nullptr) {
    v.push_back(head->val);
    head = head->next;
}

ржкрзНрж░рждрж┐ржЯрж┐ ржирзЛржбрзЗрж░ ржнрзНржпрж╛рж▓рзБ v рждрзЗ рж░рж╛ржЦржЫрзЛред

ржПржЦржи рждрзБржорж┐ ржкрзБрж░рзЛ рж▓рж┐рж╕рзНржЯржХрзЗ ржнрзЗржХрзНржЯрж░рзЗ ржХржиржнрж╛рж░рзНржЯ ржХрж░рзЗржЫрзЛред



---

тЬЕ Step 3: Mid index ржмрзЗрж░ ржХрж░рзЛ

int mid = (0 + v.size()) / 2;

ржПржЦрж╛ржирзЗ рждрзБржорж┐ тМКn / 2тМЛ рж╣рж┐рж╕рзЗржм ржХрж░ржЫрзЛред

ржзрж░рзЛ v.size() = 7 тЖТ mid = 3 тЖТ ржПржЯрж╛ рзж-based indexing ржЕржирзБржпрж╛рзЯрзА рзкрж░рзНрже ржирзЛржбред



---

тЬЕ Step 4: Middle ржмрж╛ржж ржжрж┐рзЯрзЗ ржирждрзБржи vector ржмрж╛ржирж╛ржУ

vector<int> choose;
for(int i = 0; i < v.size(); i++) {
    if(i != mid)
        choose.push_back(v[i]);
}

ржпрзЗржЗ index mid тАФ рж╕рзЗржЯрж╛ ржмрж╛ржж ржжрж┐рзЯрзЗ ржмрж╛ржХрж┐ рж╕ржм ржнрзНржпрж╛рж▓рзБ ржирждрзБржи vector choose ржП рж░рж╛ржЦрзЛред



---

тЬЕ Step 5: Vector тЖТ ржирждрзБржи Linked List

ListNode* headd = new ListNode(choose[0]);
ListNode* curr = headd;
for(int j = 1; j < choose.size(); j++) {
    curr->next = new ListNode(choose[j]);
    curr = curr->next;
}

ржирждрзБржи рж▓рж┐рж╕рзНржЯ ржмрж╛ржирж╛ржЪрзНржЫрзЛ choose[] ржнрзНржпрж╛рж▓рзБржЧрзБрж▓рзЛрж░ ржЙржкрж░ ржнрж┐рждрзНрждрж┐ ржХрж░рзЗред



---

тЬЕ Step 6: Return Result

return headd;


---

ЁЯФ╢ рждрзБржорж┐ ржХрзЗржи Accepted ржкрзЗрзЯрзЗржЫрзЛ?

тЬЕ рждрзБржорж┐ рж╕ржм edge case (1 node, multiple nodes) рж╣рзНржпрж╛ржирзНржбрж▓ ржХрж░рзЗржЫрзЛред

тЬЕ Correct mid index ржмрзЗрж░ ржХрж░рзЗржЫрзЛред

тЬЕ рж▓рж┐рж╕рзНржЯ ржерзЗржХрзЗ mid ржмрж╛ржж ржжрж┐рзЯрзЗ ржирждрзБржи рж▓рж┐рж╕рзНржЯ ржмрж╛ржирж┐рзЯрзЗржЫрзЛред

тЬЕ Time Complexity O(n), Memory O(n) тАФ ржпрж╛ constraints (1 тЙд n тЙд 10тБ╡) ржПрж░ ржоржзрзНржпрзЗ acceptableред



---

тЬЕ ржЙржжрж╛рж╣рж░ржг ржжрж┐рзЯрзЗ ржмрзЛржЭрж╛ржЗ (Example 1)

Input: [1,3,4,7,1,2,6]
n = 7, mid index = тМК7/2тМЛ = 3

тЖТ remove index 3 тЖТ 7 ржмрж╛ржж тЖТ
Output = [1,3,4,1,2,6] тЬЕ

Full Code:
-----------

  class Solution
{
public:
ListNode* deleteMiddle(ListNode* head)
{
vector<int>v;
if(head==nullptr||head->next==nullptr)
{
return nullptr;
}
while(head!=nullptr)
{
v.push_back(head->val);
head=head->next;
}
int low=0;
//int high=v.size()-1;
int mid=(low+v.size())/2;
vector<int>choose;
for(int i=0;i<v.size();i++)
{
if(i!=mid)
{
choose.push_back(v[i]);
}
}
ListNode* headd=new ListNode(choose[0]);
ListNode* curr=headd;
for(int j=1;j<choose.size();j++)
{
curr->next=new ListNode(choose[j]);
curr=curr->next;
}
return headd;
}
}; 
