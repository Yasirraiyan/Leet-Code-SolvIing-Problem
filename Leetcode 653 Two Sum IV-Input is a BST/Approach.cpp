আমাদের একটি Binary Search Tree (BST) দেয়া আছে, আর একটা সংখ্যা k দেয়া আছে। আমাদের কাজ হলো খুঁজে বের করা যে, BST এর মধ্যে এমন দুইটা নোডের মান আছে কিনা যেগুলোর যোগফল k এর সমান।


---

প্রশ্নের কন্ডিশন বুঝা:

BST মানে একটা বাইনারি সার্চ ট্রি যেখানে:

বাম পাশের নোডের মান সবসময় পেরেন্ট নোডের থেকে ছোট।

ডান পাশের নোডের মান সবসময় পেরেন্ট নোডের থেকে বড় বা সমান।


আমাদের দুই নোডের মান যোগ করলে k এর সমান হবে কিনা দেখতে হবে।

যদি থাকে, true রিটার্ন করো, না হলে false।



---

কিভাবে চিন্তা করব?

1. বুঝতে হবে দুইটি ভ্যালুর যোগফল k এর সমান কিনা।


2. একটা সহজ উপায় হলো — গাছ থেকে সব নোডের মান নিয়ে একটা লিস্ট বানানো।


3. তারপর ওই লিস্টের মধ্যে দুইটি সংখ্যা খুঁজে বের করা যাদের যোগফল k।


4. এটা ব্রুটফোর্স পদ্ধতিতে করা যেতে পারে (দুটি লুপ চালিয়ে)।




---

কোডের ধাপ ব্যাখ্যা (বাংলায়):

১. Target ফাংশন:

bool Target(int a,int b,int target)
{
    bool find=false;
    int sum=a+b;
    if(sum==target)
    {
        find=true;
    }
    return find;
}

এখানে আমরা দুটি সংখ্যা a এবং b নিয়ে তাদের যোগফল sum বের করছি।

যদি sum আমাদের লক্ষ্য মান target এর সমান হয়, তাহলে true রিটার্ন করব।

অন্যথায় false।

অর্থাৎ, দুই সংখ্যার যোগফল কি target এর সমান কিনা চেক করার জন্য।



---

২. BFS ফাংশন (Breadth First Search):

vector<int> BFS(TreeNode* root)
{
    vector<int>v;
    if(root==nullptr) return v;  // খালি গাছ হলে খালি লিস্ট রিটার্ন করো
    queue<TreeNode*>q;
    q.push(root);

    while(!q.empty())
    {
        TreeNode* f=q.front();  // কিউ থেকে প্রথম নোড বের করো
        v.push_back(f->val);    // ঐ নোডের মান লিস্টে রাখো
        q.pop();

        if(f->left!=nullptr)    // যদি বাম পাশের নোড থাকে, সেটাকে কিউতে যোগ করো
        {
            q.push(f->left);
        }
        if(f->right!=nullptr)   // ডান পাশের নোড থাকলে সেটাও কিউতে যোগ করো
        {
            q.push(f->right);
        }
    }
    return v;  // সব নোডের মানের লিস্ট রিটার্ন করো
}

এখানে গাছের নোডগুলো লেভেল ওয়াইজ (Breadth First) ট্রাভার্সাল করছি।

প্রতিটি নোডের মান একটা ভেক্টরে যোগ করছি।

শেষ পর্যন্ত আমরা সব নোডের মান পাওয়া যায়।



---

৩. findTarget ফাংশন:

bool findTarget(TreeNode* root, int k) 
{
    vector<int>v=BFS(root);  // প্রথমে গাছ থেকে সব নোডের মান নিয়ে আসো

    for(int i=0;i<v.size();i++)   // দুইটি লুপ চালাও
    {
        for(int j=i+1;j<v.size();j++)
        {
            if(Target(v[i],v[j],k))   // যদি দুই মানের যোগফল k হয়
            {
                return true;          // তখন true রিটার্ন করো
            }
        }
    }

    return false;    // সব জোড়া চেষ্টা করার পর না পেলে false রিটার্ন করো
}

এখানে আমরা দু'টি লুপ চালিয়ে প্রতিটি সম্ভাব্য জোড়া (pair) পরীক্ষা করছি।

যদি দুই নোডের মানের যোগফল k হয়, তখনই true রিটার্ন করছি।

শেষ পর্যন্ত কোন জোড়া না পেলে false রিটার্ন করি।



---

কেন এই সমাধান কাজ করে?

গাছের সব মান পেয়ে গেলে, আমরা একটা সংখ্যার জোড়া k এর সমান কিনা খুঁজছি।

এটা সাধারণ সংখ্যা খোঁজার সমস্যার মতো — লিস্ট থেকে দুই সংখ্যার যোগফল নির্ণয়।

এই পদ্ধতিতে সব সম্ভাব্য জোড়া পরীক্ষা করা হয়, তাই ফলাফল সঠিক।



---

ম্যাথমেটিক্যাল ব্যাখ্যা (সংক্ষিপ্ত):

ধরো গাছের নোডের মানের সেট: 

আমাদের চেক করতে হবে:  যেখানে 

BFS দিয়ে আমরা  কে লিস্টে রূপান্তর করছি।

তারপর দুটি লুপ দিয়ে  কিনা চেক করছি।

যদি পাওয়া যায়, তাহলে true রিটার্ন।



---

কোডের কমপ্লেক্সিটি:

গাছ থেকে নোডগুলো সংগ্রহ করতে: O(n)

দুই লুপের মাধ্যমে দুই সংখ্যা পরীক্ষা: O(n²)

মেমরি লাগবে  কারণ সব নোডের মান ভেক্টরে রাখতে হচ্ছে।



---

কোডের উন্নতি করার সম্ভাবনা:

যেহেতু BST এ ইন-অর্ডার ট্র্যাভার্সাল করলে sorted অ্যারে পাবো, তাহলে দুই পয়েন্টার পদ্ধতি ব্যবহার করে O(n) টাইমে সমাধান করা যায়।

এখানে ব্রুটফোর্স হওয়ায় O(n²), তবে কোডটা সহজ এবং টেস্ট কেসে মানানসই।

Full Code:
-------------

class Solution 
{
public:
    bool Target(int a,int b,int target)
    {
        bool find=false;
        int sum=a+b;
        if(sum==target)
        {
            find=true;
        }
        return find;
    }
    vector<int> BFS(TreeNode* root)
    {
        vector<int>v;
        if(root==nullptr) return v;
        queue<TreeNode*>q;
        q.push(root);
        //vector<int>v;
        while(!q.empty())
            {
                TreeNode* f=q.front();
                //int front=q.front()->val;
                v.push_back(f->val);
                q.pop();
                if(f->left!=nullptr)
                {
                    q.push(f->left);
                }
                if(f->right!=nullptr)
                {
                q.push(f->right);
            }
            }
        return v;
    }
    bool findTarget(TreeNode* root, int k) 
    {
        vector<int>v=BFS(root);
        for(int i=0;i<v.size();i++)
            {
                for(int j=i+1;j<v.size();j++)
                    {
                        if(Target(v[i],v[j],k))
                        {
                            return true;
                        }
                    }
            }
            
        return false;
    }
};
