ЁЯФО ржХрзАржнрж╛ржмрзЗ ржкрзНрж░рж╢рзНржиржЯрж╛ ржкрзЬрзЗ ржмрзБржЭржм ржПржмржВ рж╕рзЗржЗ ржЕржирзБржпрж╛рзЯрзА рж╕ржорж╛ржзрж╛ржи ржнрж╛ржмржм?
ЁЯза Step-by-step Problem Analysis:
ЁЯФ╣ ржкрзНрж░рж╢рзНржирзЗ ржХрзА ржмрж▓рзЗржЫрзЗ?
рждрзЛржорж╛ржХрзЗ ржПржХржЯрж┐ string s ржжрзЗржУрзЯрж╛ ржЖржЫрзЗ ржпрзЗржЯрж╛рждрзЗ рж╢рзБржзрзБ ржПржЗ рзмржЯрж┐ ржХрзНржпрж╛рж░рзЗржХрзНржЯрж╛рж░ ржерж╛ржХржмрзЗ:
ЁЯСЙ '(', ')', '{', '}', '[', ']'

рждрзЛржорж╛рж░ ржХрж╛ржЬ рж╣рж▓рзЛ ржжрзЗржЦрждрзЗ тАФ
ржПржЗ ржмрзНрж░рзНржпрж╛ржХрзЗржЯржЧрзБрж▓рзЛ рж╕ржарж┐ржХржнрж╛ржмрзЗ match ржПржмржВ nest (ржЕрж░рзНржерж╛рзО ржнрж┐рждрж░рзЗ ржнрж┐рждрж░рзЗ) рж╣рзЯрзЗржЫрзЗ ржХрж┐ржирж╛ред

тЬЕ Valid рж╣рж▓рзЗ ржХржЦржи рж╣ржмрзЗ?
ржкрзНрж░рждрж┐ржЯрж╛ open bracket-ржПрж░ ржПржХржЯрж╛ matching close bracket ржерж╛ржХрждрзЗ рж╣ржмрзЗред

matching ржЯрж╛ same type рж╣рждрзЗ рж╣ржмрзЗ (ржпрзЗржоржи ( ржПрж░ рж╕рж╛ржерзЗ )).

Brackets ржПрж░ ржЕрж░рзНржбрж╛рж░ ржарж┐ржХ ржерж╛ржХрждрзЗ рж╣ржмрзЗред
ржпрзЗржоржи:
ЁЯСЙ ([]) тАФ Valid
тЭМ ([)] тАФ Invalid (ржХрж╛рж░ржг nesting ржнрзБрж▓)

ЁЯза ржПржЦржи ржнрж╛ржмрж┐, ржХрзЛржи Data Structure ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржм?
ржПржЗ ржзрж░ржирзЗрж░ matching ржмрж╛ nesting problem ржП рж╕ржмрж╕ржорзЯ stack ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ рж╣рзЯред ржХрж╛рж░ржг stack:

LIFO (Last In First Out) ржкржжрзНржзрждрж┐рждрзЗ ржХрж╛ржЬ ржХрж░рзЗ

ржкрзНрж░ржержорзЗ ржпрзЗржЯрж╛ ржЦрзЛрж▓рж╛ рж╣рзЯрзЗржЫрж┐рж▓ рж╕рзЗржЯрж╛ рж╢рзЗрж╖рзЗ ржмржирзНржз рж╣ржмрзЗ тАФ ржарж┐ржХ ржмрзНрж░рзНржпрж╛ржХрзЗржЯрзЗрж░ ржорждрзЛред

ЁЯФз ржПржЦржи ржХрзЛржбржЯрж╛ line by line ржмрзБржЭрж┐ (Bangla рждрзЗ):
cpp
Copy
Edit
#include<stack>
class Solution 
{
public:
    bool isValid(string s) 
    {
        stack<char>st;  // ржмрзНрж░рзНржпрж╛ржХрзЗржЯ ржорзЗрж▓рж╛ржирзЛрж░ ржЬржирзНржп ржПржХржЯрж╛ stack рждрзИрж░рж┐ ржХрж░рж▓рж╛ржо
        bool isvalid=true; // рж╢рзБрж░рзБрждрзЗ ржзрж░рзЗ ржирж┐ржЪрзНржЫрж┐ рж╕ржмржХрж┐ржЫрзБ valid

        for(int i=0;i<s.size();i++)  // рж╕рзНржЯрзНрж░рж┐ржВрзЯрзЗрж░ ржкрзНрж░рждрж┐ржЯрж╛ ржХрзНржпрж╛рж░рзЗржХрзНржЯрж╛рж░ ржШрзБрж░рзЗ ржжрзЗржЦржм
        {
            if(s[i]=='('||(s[i]=='{')||(s[i]=='[')) // ржпржжрж┐ ржХрзЛржирзЛ open bracket ржкрж╛ржЗ
            {
                st.push(s[i]); // рждрж╛рж╣рж▓рзЗ stack ржП рж░рж╛ржЦрж┐
            }

            // ржпржжрж┐ ржмржирзНржз ржмрзНрж░рзНржпрж╛ржХрзЗржЯ ржкрж╛ржЗ ржПржмржВ stack ржЦрж╛рж▓рж┐ ржирж╛ ржерж╛ржХрзЗ ржПржмржВ top-ржП ржорж┐рж▓ ржкрж╛ржЗ
            else if (!st.empty()&&((s[i] == ')' && st.top() == '(') ||
                                   (s[i] == '}' && st.top() == '{') ||
                                   (s[i] == ']' && st.top() == '['))) 
            {
                st.pop(); // рждрж╛рж╣рж▓рзЗ top ржерзЗржХрзЗ open bracket ржЯрж╛ ржорзБржЫрзЗ ржлрзЗрж▓рж┐
            }

            else  // ржирж╛ ржорж┐рж▓рж▓рзЗ, ржмрж╛ stack ржЦрж╛рж▓рж┐ ржерж╛ржХрж▓рзЗ invalid
            {
                isvalid=false;
                break;  // ржЖрж░ ржЪрзЗржХ ржХрж░рж╛рж░ ржжрж░ржХрж╛рж░ ржирзЗржЗ
            }
        }

        // рж╕ржмржХрж┐ржЫрзБ ржжрзЗржЦрзЗ рж╢рзЗрж╖рзЗржУ ржпржжрж┐ ржХрж┐ржЫрзБ рж░рзЯрзЗ ржпрж╛рзЯ stack ржП, рждрж╛рж╣рж▓рзЗ invalid
        if(!st.empty())
        {
            isvalid=false;
        }

        return isvalid; // рж╢рзЗрж╖рзЗ valid ржХрж┐ржирж╛ рждрж╛ return ржХрж░рж┐
    }
};
ЁЯзк ржЙржжрж╛рж╣рж░ржг ржжрж┐рзЯрзЗ ржЪрж▓рзЛ ржмрзБржЭрж┐
Example 1:
text
Copy
Edit
Input: "()"
Stack:
push('(')
')' ржжрзЗржЦрзЗ '(' pop рж╣рзЯ тЬЕ
stack ржЦрж╛рж▓рж┐ тЬЕ
Result: true
Example 2:
text
Copy
Edit
Input: "()[]{}"
All open bracket тЖТ push  
Then matching close тЖТ pop  
рж╕ржм ржорж┐рж▓рзЗржЫрзЗ тЬЕ  
Result: true
Example 3:
text
Copy
Edit
Input: "(]"
push('(')  
']' ржжрзЗржЦрзЗ top = '(', ржорзЗрж▓рзЗ ржирж╛ тЭМ  
Result: false
Example 4:
text
Copy
Edit
Input: "([])"
push('(')  
push('[')  
']' ржжрзЗржЦрзЗ '[' ржорж┐рж▓рзЗ ржпрж╛рзЯ тЖТ pop  
')' ржжрзЗржЦрзЗ '(' ржорж┐рж▓рзЗ ржпрж╛рзЯ тЖТ pop  
stack ржЦрж╛рж▓рж┐ тЬЕ  
Result: true
ЁЯФБ ржнржмрж┐рж╖рзНржпрждрзЗ ржХрзАржнрж╛ржмрзЗ ржоржирзЗ рж░рж╛ржЦржмрзЗ?
ржпржЦржиржЗ ржмрзНрж░рзНржпрж╛ржХрзЗржЯ/ржЯрзНржпрж╛ржЧ/ржирзЗрж╕рзНржЯрж┐ржВ ржПрж░ problem ржкрж╛ржмрзЗ, stack use ржХрж░рзЛред

Open тЖТ push

Close тЖТ top ржжрзЗржЦрзЗ match рж╣рж▓рзЗ pop, ржирж╛ рж╣рж▓рзЗ invalid

рж╢рзЗрж╖рзЗ stack ржЦрж╛рж▓рж┐ тЖТ valid

тЬЕ рж╕ржВржХрзНрж╖рзЗржкрзЗ ржмрзБржЭрзЗ рж░рж╛ржЦрзЛ:
ржзрж╛ржк	ржмрзНржпрж╛ржЦрзНржпрж╛
Stack рждрзИрж░рж┐	рж╕ржм open bracket рж░рж╛ржЦрж╛рж░ ржЬржирзНржп
Traverse	ржПржХ ржПржХ ржХрж░рзЗ string ржПрж░ ржкрзНрж░рждрж┐ржЯрж┐ ржХрзНржпрж╛рж░рзЗржХрзНржЯрж╛рж░ ржЪрзЗржХ ржХрж░рзЛ
Push	ржпржжрж┐ open bracket рж╣рзЯ
Pop	ржпржжрж┐ close bracket рж╣рзЯ ржПржмржВ top ржП match ржерж╛ржХрзЗ
Invalid	ржпржжрж┐ mismatch рж╣рзЯ ржмрж╛ stack ржЦрж╛рж▓рж┐ рж╣рзЯрзЗ ржпрж╛рзЯ
рж╢рзЗрж╖ ржЪрзЗржХ	рж╕ржм рж╢рзЗрж╖рзЗ ржпржжрж┐ stack ржЦрж╛рж▓рж┐ ржирж╛ ржерж╛ржХрзЗ, invalid

  Full Code:
------------
  #include<stack>
class Solution 
{
public:
    bool isValid(string s) 
    {
        stack<char>st;
        bool isvalid=true;
         for(int i=0;i<s.size();i++)
        {
          if(s[i]=='('||(s[i]=='{')||(s[i]=='['))
          {
            st.push(s[i]);
          }
       else if (!st.empty()&&((s[i] == ')' && st.top() == '(') ||  (s[i] == '}' && st.top() == '{') ||(s[i] == ']' && st.top() == '['))) 
    {
     st.pop();
}
  else
  {
    isvalid=false;
    break;
  }
  }
  if(!st.empty())
  {
    isvalid=false;
  }
  return isvalid;
 }
};
