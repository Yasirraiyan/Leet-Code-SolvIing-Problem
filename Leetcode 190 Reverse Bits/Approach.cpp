তুমি কি করছো (Solution Approach):
তুমি একটি ৩২ বিটের ইন্টিজার (সংখ্যা) নিলো যেটার বাইনারি রেপ্রেজেন্টেশন আছে, আর সেটার বিটগুলো উল্টে দিতে চাও। অর্থাৎ, সবচেয়ে ডানদিকে থাকা বিটটা হয়ে যাবে সবচেয়ে বাঁদিকে, এবং সবচেয়ে বাঁদিকে থাকা বিটটা হয়ে যাবে সবচেয়ে ডানদিকে। এটা করেই তুমি নতুন সংখ্যা তৈরি করবে।

তোমার কোডের কাজ ধাপে ধাপে:
cpp
Copy
Edit
class Solution 
{
public:
    int reverseBits(int n)
    {
        vector<int> v(32, 0);
        int idx = 0;
        while(n > 0)
        {
            v[idx] = n % 2;
            n = n / 2;
            idx++;
        }
        reverse(v.begin(), v.end());
        int ans = 0;
        for(int i = 0; i < v.size(); i++)
        {
            ans += pow(2, i) * v[i];
        }
        return ans;
    }
};
লাইন বাই লাইন বিশ্লেষণ:
১. vector<int> v(32, 0);
তুমি ৩২ সাইজের একটি ভেক্টর (array) তৈরি করেছো, যা সবগুলো ইলিমেন্ট প্রথমে ০ দিয়ে ইনিশিয়ালাইজ করা।

কারণ, ৩২ বিট ইনপুট (ইন্টিজার) এর বাইনারি রিপ্রেজেন্টেশন ৩২ বিট লম্বা হয়।

তুমি প্রতিটা বিট আলাদা করে এখানে সংরক্ষণ করবে।

২. int idx = 0;
একটা ইন্ডেক্স ভ্যারিয়েবল তৈরি করেছো, যা তোমাকে বাইনারি বিটগুলো কোথায় সংরক্ষণ করতে হবে সেটা ট্র্যাক করবে।

৩. while(n > 0)
এখানে তুমি বাইনারি বিট বের করার জন্য একটা লুপ দিচ্ছো যতক্ষণ n পজিটিভ থাকে।

এই লুপে তোমার কাজ হবে সংখ্যাটার প্রতিটা বিট বের করে ভেক্টরে রাখা।

৪. v[idx] = n % 2;
n % 2 দ্বারা তুমি n এর সর্বশেষ বিট (least significant bit) বের করছো। কারণ, ২ দিয়ে ভাগ করলে রিমাইন্ডার হয় ০ বা ১, যা বাইনারি বিট নির্দেশ করে।

এই বিটটাকে তুমি ভেক্টরের idx পজিশনে রাখছো।

৫. n = n / 2;
সংখ্যাটাকে ২ দিয়ে ভাগ করছো (অর্থাৎ একবিট ডানে শিফট করছো)।

এর ফলে পরবর্তী লুপে তুমি পরের বিট পাবে।

৬. idx++;
ইন্ডেক্স এক বাড়াচ্ছো, যাতে পরবর্তী বিট ভেক্টরের পরের পজিশনে রাখা যায়।

৭. reverse(v.begin(), v.end());
লুপ শেষে, তুমি ভেক্টরকে রিভার্স করছো।

কারণ, তুমি বিটগুলো idx শুরু থেকে নিচ্ছো অর্থাৎ 0th পজিশনে সবচেয়ে ছোট (least significant) বিট রাখা হয়েছে, কিন্তু রিভার্স করতে গেলে সবচেয়ে বড় (most significant) বিট 0th পজিশনে আসবে।

বাইনারি সংখ্যার রিভার্স মানে, প্রথম বিটটি হবে শেষ বিট, তাই এখানে তুমি পুরো ভেক্টরটাকে উল্টে দিচ্ছো।

৮. int ans = 0;
এখন নতুন সংখ্যাটা হিসাব করার জন্য একটা ভেরিয়েবল তৈরি করছো।

৯. for(int i = 0; i < v.size(); i++)
ভেক্টরের প্রতিটা বিট দেখে, আমরা আবার সংখ্যায় রূপান্তর করব।

১০. ans += pow(2, i) * v[i];
প্রতিটা বিটের জায়গা অনুযায়ী তার মান বের করছো।

pow(2, i) দিয়ে ২ এর i তম ঘাত বের করো — অর্থাৎ বিটের ওজন।

তারপর ওই বিট (০ বা ১) দিয়ে গুণ করো এবং ফলাফল ans এ যোগ করো।

যেমন: যদি v[0] = 1, তাহলে 1 * 2^0 = 1 যোগ হবে, যদি v[1] = 1, তাহলে 1 * 2^1 = 2 যোগ হবে, ইত্যাদি।

১১. return ans;
সব বিট যোগ হয়ে নতুন সংখ্যাটি তৈরি হল, সেটি রিটার্ন করো।

তুমি কী ভাবছিলে এবং কী টেকনিক ব্যবহার করেছো?
বিট ম্যানিপুলেশন: তুমি সংখ্যাকে বাইনারিতে ভেঙে বিটগুলো আলাদা করেছো।

বিট রিভার্সাল: তোমার উদ্দেশ্য ছিল বিটগুলোর অর্ডার উল্টানো।

বাইনরি টু ডেসিমাল রূপান্তর: রিভার্সড বিটগুলো আবার ডেসিমাল নাম্বারে কনভার্ট করেছো।

তুমি vector দিয়ে বিটগুলো স্টোর করেছো, এটা space complexity একটু বেশি, কিন্তু কোডটা সহজ বোঝার জন্য ভাল।

কেন কোডটি সঠিকভাবে কাজ করে? (Test Case দিয়ে বোঝা)
উদাহরণ: n = 43261596

প্রথমে, তুমি 43261596 কে বাইনারিতে রূপান্তর করছো, যেমন:
00000010100101000001111010011100

তারপর এই বিটগুলো উল্টে নিচ্ছো:
00111001011110000010100101000000

উল্টানো বিট থেকে আবার ডেসিমাল মান বের করো, যা হলো 964176192

তাই আউটপুট সঠিক হচ্ছে।

অন্য উদাহরণ: n = 2147483644

তুমি একই প্রক্রিয়া অনুসরণ করছো এবং সঠিক আউটপুট দিচ্ছো।

তুমি কীভাবে এই টেকনিক চিন্তা করেছিলে?
প্রথমে বুঝেছিলে যে সংখ্যাকে বাইনারিতে ভাগ করে প্রতিটি বিট আলাদা করতে হবে।

কারণ বাইনারি সংখ্যাকে রিভার্স করতে হলে, সেই বিটগুলোকে আলাদাভাবে ধরা দরকার।

তারপর ভেক্টরে সেভ করে reverse() ফাংশন দিয়ে উল্টে দিলে কাজ সহজ হয়।

শেষে pow(2, i) করে নতুন সংখ্যায় রূপান্তর করলেই সমাধান।

তুমি এই টেকনিকটি বেসিক বাইনারি ম্যানিপুলেশন এবং অ্যারে রিভার্সাল এর সাথে যুক্ত করেছো।

Optimization এর কথা ভাবলে?
এই কোডে তুমি প্রতি বিটে pow() ফাংশন কল করছো, যা একটু ধীর হতে পারে।

তুমি বিট অপারেশন (shift and mask) ব্যবহার করলে দ্রুত হবে, যেমন:

cpp
Copy
Edit
unsigned int reverseBits(unsigned int n) {
    unsigned int result = 0;
    for(int i = 0; i < 32; i++) {
        result <<= 1;
        result |= (n & 1);
        n >>= 1;
    }
    return result;
}
এখানে প্রত্যেক বিট এক এক করে নিয়ে রেজাল্টে সোজা যোগ করা হয়, কোন ভেক্টর বা pow() দরকার হয় না।

সারাংশ:
তুমি প্রথমে বাইনারি বিটগুলো বের করেছো (modulo এবং division দিয়ে)

বিটগুলোকে একটি অ্যারেতে রেখে উল্টে দিয়েছো (reverse)

তারপর উল্টানো বিটগুলোর মান যোগ করে নতুন সংখ্যা তৈরি করেছো।

এটা ঠিকভাবে কাজ করেছে কারণ প্রতিটি ধাপে তোমার লজিক সঠিক এবং কোডের প্রতিটি অংশ সঠিক কাজ করছে।

যদি বাংলায় খুব সংক্ষেপে বলি:
সংখ্যাটাকে বাইনারিতে ভাগ করে ৩২ বিটে ভেঙে নিলাম।

বিটগুলোকে উল্টে দিলাম যাতে প্রথম বিট শেষ হয়, শেষ বিট প্রথম হয়।

উল্টানো বিটগুলো দিয়ে আবার নতুন সংখ্যা তৈরি করলাম।

এই পদ্ধতি কাজ করছে কারণ বাইনারি বিটগুলো ঠিকভাবে আলাদা করা ও পুনর্বিন্যাস করা হয়েছে।



Full Code:
----------

  class Solution 
{
public:
    int reverseBits(int n)
     {
        vector<int>v(32,0);
        int idx=0;
        while(n>0)
        {
          v[idx]=n%2;
         // v.push_back(rem);
          n=n/2;
          idx++;
          
        }
        reverse(v.begin(),v.end());
        int ans=0;
        for(int i=0;i<v.size();i++)
        {
          ans+=pow(2,i)*v[i];
        }
        return ans;
    }
};
