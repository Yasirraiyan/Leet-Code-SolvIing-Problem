à¦ªà§à¦°à¦¥à¦®à§‡ à¦ªà§à¦°à¦¶à§à¦¨à¦Ÿà¦¾ à¦¬à§‹à¦à¦¾

à¦ªà§à¦°à¦¶à§à¦¨ à¦¬à¦²à¦›à§‡:

à¦†à¦®à¦¾à¦¦à§‡à¦° à¦•à¦¾à¦›à§‡ à¦¦à§à¦Ÿà¦¿ binary tree à¦†à¦›à§‡ â€” root1 à¦†à¦° root2à¥¤

à¦à¦‡ à¦¦à§à¦Ÿà§‹ à¦—à¦¾à¦›à¦•à§‡ à¦®à¦¾à¦°à§à¦œ (merge) à¦•à¦°à¦¤à§‡ à¦¹à¦¬à§‡ à¦¨à¦¤à§à¦¨ à¦à¦•à¦Ÿà¦¾ à¦—à¦¾à¦› à¦¬à¦¾à¦¨à¦¿à¦¯à¦¼à§‡à¥¤

Merge Rule:

1. à¦¯à¦¦à¦¿ à¦¦à§à¦‡à¦Ÿà¦¾ à¦¨à§‹à¦¡ à¦à¦•à¦‡ à¦ªà¦œà¦¿à¦¶à¦¨à§‡ à¦¥à¦¾à¦•à§‡ (overlap à¦¹à¦¯à¦¼), à¦¤à¦¾à¦¹à¦²à§‡ value à¦¯à§‹à¦— à¦•à¦°à¦¤à§‡ à¦¹à¦¬à§‡à¥¤


2. à¦¯à¦¦à¦¿ à¦•à§‹à¦¨à§‹ à¦ªà¦œà¦¿à¦¶à¦¨à§‡ à¦à¦•à¦Ÿà¦¿à¦‡ à¦¨à§‹à¦¡ à¦¥à¦¾à¦•à§‡, à¦¤à¦¾à¦¹à¦²à§‡ à¦¸à§‡à¦‡ à¦¨à§‹à¦¡à¦Ÿà¦¾à¦‡ à¦°à§‡à¦–à§‡ à¦¦à¦¿à¦¤à§‡ à¦¹à¦¬à§‡à¥¤



à¦¶à§à¦°à§ à¦¹à¦¬à§‡ à¦¦à§à¦‡ à¦°à§à¦Ÿ (root) à¦¨à§‹à¦¡ à¦¥à§‡à¦•à§‡à¥¤



---

à¦­à¦¾à¦¬à¦¨à¦¾à¦° à¦§à¦¾à¦ª (Approach Thinking)

1. à¦°à¦¿à¦•à¦¾à¦°à§à¦¸à¦¿à¦­ à¦šà¦¿à¦¨à§à¦¤à¦¾ (Recursive Thinking)
à¦¦à§à¦‡à¦Ÿà¦¾ à¦—à¦¾à¦› à¦®à¦¾à¦°à§à¦œ à¦•à¦°à¦¤à§‡ à¦—à§‡à¦²à§‡ à¦ªà§à¦°à¦¥à¦®à§‡à¦‡ à¦°à§à¦Ÿ à¦¨à§‹à¦¡ à¦¥à§‡à¦•à§‡ à¦¶à§à¦°à§ à¦•à¦°à¦¤à§‡ à¦¹à¦¬à§‡à¥¤
à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¾ à¦¨à§‹à¦¡à§‡à¦° à¦•à§à¦·à§‡à¦¤à§à¦°à§‡ à¦¤à¦¿à¦¨à¦Ÿà¦¾ à¦…à¦¬à¦¸à§à¦¥à¦¾ à¦¹à¦¤à§‡ à¦ªà¦¾à¦°à§‡:

Case 1: à¦¦à§à¦‡ à¦¨à§‹à¦¡-à¦‡ à¦†à¦›à§‡ â†’ à¦¤à¦¾à¦¦à§‡à¦° à¦®à¦¾à¦¨ à¦¯à§‹à¦— à¦•à¦°à§‡ à¦¨à¦¤à§à¦¨ à¦¨à§‹à¦¡ à¦¬à¦¾à¦¨à¦¾à¦“à¥¤

Case 2: à¦à¦•à¦Ÿà¦¾ à¦¨à§‹à¦¡ à¦¨à§‡à¦‡ â†’ à¦…à¦¨à§à¦¯ à¦¨à§‹à¦¡à¦Ÿà¦¾à¦‡ à¦°à¦¿à¦Ÿà¦¾à¦°à§à¦¨ à¦•à¦°à§‹à¥¤

Case 3: à¦¦à§à¦‡ à¦¨à§‹à¦¡à¦‡ à¦¨à§‡à¦‡ â†’ nullptr à¦°à¦¿à¦Ÿà¦¾à¦°à§à¦¨ à¦•à¦°à§‹ (base case)à¥¤



2. Divide and Conquer
à¦°à§à¦Ÿ à¦®à¦¾à¦°à§à¦œ à¦•à¦°à¦¾à¦° à¦ªà¦°à§‡, left subtree à¦®à¦¾à¦°à§à¦œ à¦•à¦°à¦¬ à¦°à§à¦Ÿà§‡à¦° à¦¬à¦¾à¦® à¦¸à¦¨à§à¦¤à¦¾à¦¨ à¦¦à¦¿à¦¯à¦¼à§‡
à¦†à¦° right subtree à¦®à¦¾à¦°à§à¦œ à¦•à¦°à¦¬ à¦°à§à¦Ÿà§‡à¦° à¦¡à¦¾à¦¨ à¦¸à¦¨à§à¦¤à¦¾à¦¨ à¦¦à¦¿à¦¯à¦¼à§‡à¥¤


3. à¦°à¦¿à¦•à¦¾à¦°à§à¦¸à¦¨ à¦•à¦²à¦¿à¦‚
à¦à¦‡à¦­à¦¾à¦¬à§‡ à¦¬à¦¾à¦°à¦¬à¦¾à¦° à¦•à¦² à¦¹à¦²à§‡, à¦¸à¦¬ à¦¨à§‹à¦¡ à¦ªà§à¦°à¦•à§à¦°à¦¿à¦¯à¦¼à¦¾ à¦¹à¦¯à¦¼à§‡ à¦¯à¦¾à¦¬à§‡à¥¤




---

à¦•à§‹à¦¡à§‡à¦° à¦²à¦¾à¦‡à¦¨ à¦¬à¦¾à¦‡ à¦²à¦¾à¦‡à¦¨ à¦¬à§à¦¯à¦¾à¦–à§à¦¯à¦¾

class Solution 
{
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) 
    {

ðŸ”¹ à¦†à¦®à¦°à¦¾ mergeTrees à¦«à¦¾à¦‚à¦¶à¦¨ à¦²à¦¿à¦–à¦›à¦¿ à¦¯à§‡à¦Ÿà¦¾ à¦¦à§à¦‡à¦Ÿà¦¾ TreeNode* à¦‡à¦¨à¦ªà§à¦Ÿ à¦¨à¦¿à¦¯à¦¼à§‡ à¦®à¦¾à¦°à§à¦œà¦¡ à¦Ÿà§à¦°à¦¿ à¦°à¦¿à¦Ÿà¦¾à¦°à§à¦¨ à¦•à¦°à¦¬à§‡à¥¤


---

if(root1==nullptr) return root2;

ðŸ”¹ Base Case 1:
à¦¯à¦¦à¦¿ root1 à¦¨à¦¾ à¦¥à¦¾à¦•à§‡ (nullptr), à¦¤à¦¾à¦¹à¦²à§‡ root2-à¦à¦° à¦¨à§‹à¦¡à¦Ÿà¦¾à¦‡ à¦°à¦¿à¦Ÿà¦¾à¦°à§à¦¨ à¦•à¦°à§‡ à¦¦à¦¾à¦“à¥¤
à¦®à¦¾à¦¨à§‡ à¦“à¦‡ à¦œà¦¾à¦¯à¦¼à¦—à¦¾à¦¯à¦¼ à¦¶à§à¦§à§ root2 à¦†à¦›à§‡, à¦®à¦¾à¦°à§à¦œ à¦•à¦°à¦¾à¦° à¦•à¦¿à¦›à§ à¦¨à§‡à¦‡à¥¤


---

if(root2==nullptr) return root1;

ðŸ”¹ Base Case 2:
à¦¯à¦¦à¦¿ root2 à¦¨à¦¾ à¦¥à¦¾à¦•à§‡, à¦¤à¦¾à¦¹à¦²à§‡ root1 à¦«à§‡à¦°à¦¤ à¦¦à¦¾à¦“à¥¤


---

TreeNode* root3 ;

ðŸ”¹ à¦®à¦¾à¦°à§à¦œà¦¡ à¦¨à§‹à¦¡à§‡à¦° à¦œà¦¨à§à¦¯ à¦¨à¦¤à§à¦¨ à¦à¦•à¦Ÿà¦¾ à¦ªà¦¯à¦¼à§‡à¦¨à§à¦Ÿà¦¾à¦° root3 à¦¬à¦¾à¦¨à¦¾à¦²à¦¾à¦®à¥¤


---

if(root1->val!=root2->val)
        {
            int s=root1->val+root2->val;
            root3=new TreeNode(s);
        }
        if(root1->val==root2->val)
        {
            int s=root1->val+root2->val;
            root3=new TreeNode(s);
        }

ðŸ”¹ à¦à¦–à¦¾à¦¨à§‡ à¦†à¦¸à¦²à§‡ à¦¦à§à¦‡à¦Ÿà¦¾ if à¦†à¦²à¦¾à¦¦à¦¾ à¦°à¦¾à¦–à¦¾à¦° à¦¦à¦°à¦•à¦¾à¦° à¦¨à§‡à¦‡, à¦•à¦¾à¦°à¦£ à¦¦à§à¦‡ à¦­à§à¦¯à¦¾à¦²à§ à¦¸à¦®à¦¾à¦¨ à¦¹à§‹à¦• à¦¬à¦¾ à¦¨à¦¾ à¦¹à§‹à¦•, à¦¯à§‹à¦—à¦«à¦²à¦‡ à¦²à¦¾à¦—à¦¬à§‡à¥¤
à¦¤à§à¦®à¦¿ à¦¦à§à¦Ÿà§‹ à¦†à¦²à¦¾à¦¦à¦¾ à¦•à¦°à§‡à¦›, à¦•à¦¿à¦¨à§à¦¤à§ à¦•à¦¾à¦œ à¦ à¦¿à¦•à¦‡ à¦¹à¦šà§à¦›à§‡ à¦•à¦¾à¦°à¦£ à¦¦à§à¦‡ à¦•à§‡à¦¸à§‡à¦‡ sum à¦•à¦°à§‡ à¦¨à¦¤à§à¦¨ à¦¨à§‹à¦¡ à¦¬à¦¾à¦¨à¦¾à¦¨à§‹ à¦¹à¦šà§à¦›à§‡à¥¤

ðŸ“Œ à¦—à¦£à¦¿à¦¤ à¦‰à¦¦à¦¾à¦¹à¦°à¦£:
à¦¯à¦¦à¦¿ root1->val = 3 à¦†à¦° root2->val = 5 à¦¹à¦¯à¦¼,
à¦¤à¦¾à¦¹à¦²à§‡ s = 3 + 5 = 8 à¦¹à¦¬à§‡, à¦à¦¬à¦‚ à¦¨à¦¤à§à¦¨ root3-à¦à¦° à¦®à¦¾à¦¨ à¦¹à¦¬à§‡ 8à¥¤


---

root3->left= mergeTrees(root1->left,root2->left);

ðŸ”¹ Left subtree à¦®à¦¾à¦°à§à¦œ à¦•à¦°à¦¾à¦° à¦œà¦¨à§à¦¯ à¦°à¦¿à¦•à¦¾à¦°à§à¦¸à¦¿à¦­ à¦•à¦² à¦¦à¦¿à¦²à¦¾à¦®à¥¤
à¦à¦‡ à¦•à¦²à§‡à¦° à¦­à§‡à¦¤à¦° à¦†à¦¬à¦¾à¦° à¦à¦•à¦‡ à¦²à¦œà¦¿à¦• à¦šà¦¾à¦²à§ à¦¹à¦¬à§‡à¥¤


---

root3->right= mergeTrees(root1->right,root2->right);

ðŸ”¹ Right subtree à¦®à¦¾à¦°à§à¦œ à¦•à¦°à¦²à¦¾à¦® à¦°à¦¿à¦•à¦¾à¦°à§à¦¸à¦¨ à¦¦à¦¿à¦¯à¦¼à§‡à¥¤


---

return root3;
    }
};

ðŸ”¹ à¦¨à¦¤à§à¦¨ à¦®à¦¾à¦°à§à¦œà¦¡ à¦¨à§‹à¦¡ (root3) à¦«à§‡à¦°à¦¤ à¦¦à¦¿à¦²à¦¾à¦®à¥¤
à¦à¦‡à¦­à¦¾à¦¬à§‡ à¦°à¦¿à¦•à¦¾à¦°à§à¦¸à¦¨ à¦¸à¦¬ subtree à¦®à¦¾à¦°à§à¦œ à¦•à¦°à§‡ à¦«à¦¾à¦‡à¦¨à¦¾à¦² à¦Ÿà§à¦°à¦¿ à¦¬à¦¾à¦¨à¦¾à¦¬à§‡à¥¤


---

à¦Ÿà§‡à¦¸à§à¦Ÿ à¦•à§‡à¦¸ à¦¦à¦¿à¦¯à¦¼à§‡ à¦¬à§‹à¦à¦¾

Example 1

root1 = [1,3,2,5]
root2 = [2,1,3,null,4,null,7]

à¦§à¦¾à¦ªà§‡ à¦§à¦¾à¦ªà§‡ à¦®à¦¾à¦°à§à¦œ:

1. à¦°à§à¦Ÿ: 1 + 2 = 3


2. Left child: 3 + 1 = 4


3. Left-left child: 5 + null = 5


4. Left-right child: null + 4 = 4


5. Right child: 2 + 3 = 5


6. Right-right child: null + 7 = 7



à¦«à¦¾à¦‡à¦¨à¦¾à¦² à¦Ÿà§à¦°à¦¿:

3
     / \
    4   5
   / \    \
  5   4    7

à¦†à¦‰à¦Ÿà¦ªà§à¦Ÿ: [3,4,5,5,4,null,7]


---

à¦¸à¦‚à¦•à§à¦·à§‡à¦ªà§‡ à¦šà¦¿à¦¨à§à¦¤à¦¾à¦° à¦«à§à¦²à§‹

1. Base Case â†’ null à¦šà§‡à¦• à¦•à¦°à§‹à¥¤


2. Sum Node Values â†’ à¦¦à§à¦‡ à¦¨à§‹à¦¡ à¦¥à¦¾à¦•à¦²à§‡ à¦¯à§‹à¦— à¦•à¦°à§‹à¥¤


3. Recursive Merge â†’ left à¦“ right subtree à¦®à¦¾à¦°à§à¦œ à¦•à¦°à§‹à¥¤


4. Return â†’ à¦¨à¦¤à§à¦¨ à¦®à¦¾à¦°à§à¦œà¦¡ à¦¨à§‹à¦¡ à¦°à¦¿à¦Ÿà¦¾à¦°à§à¦¨ à¦•à¦°à§‹à¥¤


Full Code:
-----------

  class Solution 
{
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) 
    {
        if(root1==nullptr) return root2;
        if(root2==nullptr) return root1;
        TreeNode* root3 ;
                if(root1->val!=root2->val)
                {
                    int s=root1->val+root2->val;
                    root3=new TreeNode(s);
                }
                if(root1->val==root2->val)
                {
                    int s=root1->val+root2->val;
                    root3=new TreeNode(s);
                }
               root3->left= mergeTrees(root1->left,root2->left);
               root3->right= mergeTrees(root1->right,root2->right);
        return root3;
    }
};
