ржарж┐ржХ ржЖржЫрзЗ тАФ ржЖржорж┐ рждрзЛржорж╛ржХрзЗ ржзрж╛ржкрзЗ ржзрж╛ржкрзЗ ржмрзБржЭрж┐рзЯрзЗ ржжрж┐ржЪрзНржЫрж┐ ржХрзАржнрж╛ржмрзЗ рждрзБржорж┐ ржПржЗ Postorder Traversal рж╕ржорж╕рзНржпрж╛ржЯрж╛ ржмрзБржЭрзЗ рж╕ржорж╛ржзрж╛ржи рж▓рж┐ржЦрждрзЗ ржкрж╛рж░рзЛ, ржЖрж░ ржХрзЗржи рждрзЛржорж╛рж░ рж▓рзЗржЦрж╛ ржХрзЛржб рж╕ржм ржЯрзЗрж╕рзНржЯ ржкрж╛рж╕ ржХрж░ржЫрзЗред

1я╕ПтГг ржкрзНрж░рж╢рзНржи ржкрзЬрзЗржЗ ржХрзАржнрж╛ржмрзЗ ржЪрж┐ржирзНрждрж╛ рж╢рзБрж░рзБ ржХрж░ржм

ржкрзНрж░рж╢рзНржирзЗ ржмрж▓рж╛ рж╣рзЯрзЗржЫрзЗ: Binary Tree ржПрж░ Postorder Traversalред
Postorder ржПрж░ ржирж┐рзЯржоржЯрж╛ рж╣рж▓рзЛ:

Left Subtree тЖТ Right Subtree тЖТ Root Node

ржорж╛ржирзЗ ржкрзНрж░ржержорзЗ ржмрж╛ржо ржжрж┐ржХрзЗрж░ рж╕ржм subtree ржШрзБрж░рзЗ ржЖрж╕ржмрзЗ, рждрж╛рж░ржкрж░ ржбрж╛ржи ржжрж┐ржХрзЗрж░ subtree, рждрж╛рж░ржкрж░ рж╢рзЗрж╖рзЗ root node ржПрж░ ржорж╛ржи ржирж┐ржмрзЗред


---

ржнрж╛ржмржирж╛:

ржпрзЗрж╣рзЗрждрзБ Binary Tree ржжрзЗржУрзЯрж╛ ржЖржЫрзЗ, ржЖржорж╛ржжрзЗрж░ ржПржХржЯрж╛ recursive DFS traversal ржжрж┐рзЯрзЗ рж╕рж╣ржЬрзЗ ржХрж░рж╛ ржпрж╛ржмрзЗред

Recursive approach ржП ржЖржорж░рж╛ рждрж┐ржи ржзрж╛ржкрзЗ ржХрж╛ржЬ ржХрж░ржм:

1. ржпржжрж┐ root ржлрж╛ржБржХрж╛ рж╣рзЯ тЖТ returnред


2. ржкрзНрж░ржержорзЗ ржмрж╛ржо child ржП рж░рж┐ржХрж╛рж░рзНрж╕ржи ржХрж▓ ржХрж░ржмред


3. рждрж╛рж░ржкрж░ ржбрж╛ржи child ржП рж░рж┐ржХрж╛рж░рзНрж╕ржи ржХрж▓ ржХрж░ржмред


4. рж╢рзЗрж╖рзЗ root node ржПрж░ value рж╕ржВржЧрзНрж░рж╣ ржХрж░ржмред




ржПржЯрж╛ржЗ Postorder Traversal ржПрж░ ржорзВрж▓ рж▓ржЬрж┐ржХред


---

2я╕ПтГг ржХрзЛржбрзЗрж░ рж▓рж╛ржЗржи ржмрж╛ржЗ рж▓рж╛ржЗржи ржмрзНржпрж╛ржЦрзНржпрж╛

class Solution 
{
public:
    void postorder(TreeNode* root, vector<int>& v)
    {
        if(root == nullptr) return; // 1я╕ПтГг Base case: ржЧрж╛ржЫ ржлрж╛ржБржХрж╛ рж╣рж▓рзЗ ржХрж┐ржЫрзБ ржХрж░ржм ржирж╛

        if(root->left != nullptr)   // 2я╕ПтГг ржпржжрж┐ ржмрж╛ржо subtree ржерж╛ржХрзЗ
        {
            postorder(root->left, v); // ржкрзНрж░ржержорзЗ ржмрж╛ржо ржжрж┐ржХрзЗрж░ рж╕ржм ржШрзБрж░рзЗ ржЖрж╕ржм
        }

        if(root->right != nullptr)  // 3я╕ПтГг ржпржжрж┐ ржбрж╛ржи subtree ржерж╛ржХрзЗ
        {
            postorder(root->right, v); // ржПрж░ржкрж░ ржбрж╛ржи ржжрж┐ржХрзЗрж░ рж╕ржм ржШрзБрж░рзЗ ржЖрж╕ржм
        }

        v.push_back(root->val);     // 4я╕ПтГг рж╢рзЗрж╖рзЗ ржПржЗ node ржПрж░ ржорж╛ржи ржпрзЛржЧ ржХрж░ржм (Postorder)
    }

    vector<int> postorderTraversal(TreeNode* root) 
    {
        vector<int> v;      // 5я╕ПтГг ржПржЦрж╛ржирзЗ ржлрж▓рж╛ржлрж▓ рж░рж╛ржЦржм
        v.clear();          // (ржЕржкрзНрж░рзЯрзЛржЬржирзАрзЯ, ржХрж╛рж░ржг ржирждрзБржи vector ржбрж┐ржлрж▓рзНржЯрзЗ ржлрж╛ржБржХрж╛)

        postorder(root, v); // 6я╕ПтГг recursive traversal рж╢рзБрж░рзБ

        return v;           // 7я╕ПтГг ржлрж▓рж╛ржлрж▓ рж░рж┐ржЯрж╛рж░рзНржи ржХрж░ржм
    }
};


---

3я╕ПтГг Dry Run & ржорзНржпрж╛ржержорзЗржЯрж┐ржХрзНржпрж╛рж▓ ржмрзНржпрж╛ржЦрзНржпрж╛

Example 1:

root = [1, null, 2, 3]

Tree:
    1
     \
      2
     /
    3

Postorder rule: Left тЖТ Right тЖТ Root

postorder(1)

Left ржирзЗржЗ тЖТ skip

Right ржЖржЫрзЗ тЖТ postorder(2)

Left ржЖржЫрзЗ тЖТ postorder(3)

Left ржирзЗржЗ, Right ржирзЗржЗ тЖТ push_back(3) тЖТ v = [3]


Right ржирзЗржЗ тЖТ skip

push_back(2) тЖТ v = [3, 2]


push_back(1) тЖТ v = [3, 2, 1] тЬЕ



Output: [3, 2, 1]


---

Example 2:

Input: [1,2,3,4,5,null,8,null,null,6,7,9]

Tree:
        1
       / \
      2   3
     / \    \
    4   5    8
       / \     \
      6   7     9

Traversal steps (Postorder):

1. Go left тЖТ (2)

Go left тЖТ (4) тЖТ leaf тЖТ v = [4]

Go right тЖТ (5)

Left тЖТ (6) тЖТ v = [4, 6]

Right тЖТ (7) тЖТ v = [4, 6, 7]

Push 5 тЖТ v = [4, 6, 7, 5]


Push 2 тЖТ v = [4, 6, 7, 5, 2]



2. Go right тЖТ (3)

Left ржирзЗржЗ

Right тЖТ (8)

Left ржирзЗржЗ

Right тЖТ (9) тЖТ v = [4, 6, 7, 5, 2, 9]

Push 8 тЖТ v = [4, 6, 7, 5, 2, 9, 8]


Push 3 тЖТ v = [4, 6, 7, 5, 2, 9, 8, 3]



3. Push 1 тЖТ v = [4, 6, 7, 5, 2, 9, 8, 3, 1] тЬЕ




---

ЁЯТб ржХрзЗржи ржХрзЛржб Accept рж╣ржЪрзНржЫрзЗ?

рждрзБржорж┐ рж╕ржарж┐ржХржнрж╛ржмрзЗ recursion ржжрж┐рзЯрзЗ Postorder rule ржлрж▓рзЛ ржХрж░рзЗржЫрзЛ: Left тЖТ Right тЖТ Root

Base case ржарж┐ржХржнрж╛ржмрзЗ рж╕рзЗржЯ ржХрж░рзЗржЫрзЛ (null рж╣рж▓рзЗ return)

vector<int>& v reference ржжрж┐рзЯрзЗ ржкрж╛ржарж╛ржирзЛрж░ ржХрж╛рж░ржгрзЗ ржкрзНрж░рждрж┐ recursive ржХрж▓ ржП ржПржХржЗ vector ржЖржкржбрзЗржЯ рж╣ржЪрзНржЫрзЗ, extra copy рж╣ржЪрзНржЫрзЗ ржирж╛ тЖТ efficient

Time Complexity: O(N) (ржкрзНрж░рждрж┐ржЯрж┐ node ржПржХржмрж╛рж░ ржХрж░рзЗ ржнрж┐ржЬрж┐ржЯ)

Space Complexity: O(H) (recursion stack height, H = tree height)



---

ржпржжрж┐ рждрзБржорж┐ ржЪрж╛ржУ, ржЖржорж┐ рждрзЛржорж╛рж░ ржЬржирзНржп ржПрж░ iterative version with stack ржУ ржмрзЗрж░ ржХрж░рзЗ ржжрж┐рждрзЗ ржкрж╛рж░рж┐, ржпрж╛рждрзЗ recursion ржЫрж╛рзЬрж╛ Postorder ржХрж░рж╛ ржпрж╛рзЯред
рждрзБржорж┐ ржХрж┐ рж╕рзЗржЯрж╛ ржЪрж╛ржУ?


Full Code:
-------------

  class Solution 
{
public:
    void postorder(TreeNode* root,vector<int>&v)
    {
        if(root==nullptr) return;
        if(root->left!=nullptr)
        {
            postorder(root->left,v);
        }
        if(root->right!=nullptr)
        {
            postorder(root->right,v);
        }
        v.push_back(root->val);
    }
    vector<int> postorderTraversal(TreeNode* root) 
    {
        vector<int>v;
        v.clear();
        postorder(root,v);
        
        
        return v;
    }
};
