ржкрзНрж░рж╢рзНржирзЗрж░ ржмрж┐рж╢рзНрж▓рзЗрж╖ржг

ржкрзНрж░рждрж┐ржЯрж┐ рж╢рж┐рж╢рзБ g[i] рж▓рзЗржнрзЗрж▓рзЗрж░ ржЦрж┐ржжрзЗ (greed factor) рж░рж╛ржЦрзЗред

ржкрзНрж░рждрж┐ржЯрж┐ ржХрзБржХрж┐ s[j] рж╕рж╛ржЗржЬ рж░рж╛ржЦрзЗред

ржпржжрж┐ ржХрзБржХрж┐рж░ рж╕рж╛ржЗржЬ >= рж╢рж┐рж╢рзБрж░ ржЦрж┐ржжрзЗ, рждрж╛рж╣рж▓рзЗ рж╢рж┐рж╢рзБ ржЦрзБрж╢рж┐ред

ржЖржорж╛ржжрзЗрж░ рж▓ржХрзНрж╖рзНржп: рж╕рж░рзНржмрж╛ржзрж┐ржХ рж╢рж┐рж╢рзБржХрзЗ ржЦрзБрж╢рж┐ ржХрж░рж╛ред

ржХрзБржХрж┐ ржПржХржмрж╛рж░рзЗ рж╢рзБржзрзБ ржПржХржЬржи рж╢рж┐рж╢рзБржХрзЗ ржжрж┐рждрзЗ ржкрж╛рж░рж┐ред

ржзрж╛рж░ржгрж╛: ржЫрзЛржЯ рж╕рж╛ржЗржЬрзЗрж░ ржХрзБржХрж┐ ржЫрзЛржЯ ржЦрж┐ржжрзЗ рж╢рж┐рж╢рзБрж░ ржЬржирзНржп ржнрж╛рж▓рзЛред ржмржбрж╝ ржХрзБржХрж┐ ржмржбрж╝ ржЦрж┐ржжрзЗ рж╢рж┐рж╢рзБрж░ ржЬржирзНржп ржнрж╛рж▓рзЛред

ржХрзЛржбрзЗрж░ ржпрзБржХрзНрждрж┐ (line by line)
sort(g.begin(),g.end());
sort(s.begin(),s.end());


ржкрзНрж░ржержорзЗ рж╢рж┐рж╢рзБржжрзЗрж░ ржЦрж┐ржжрзЗ ржЖрж░ ржХрзБржХрж┐рж░ рж╕рж╛ржЗржЬ ascending order ржП рж╕рж╛ржЬрж╛ржЗред

ржХрж╛рж░ржг ржЖржорж░рж╛ ржЫрзЛржЯ ржЦрж┐ржжрзЗ рж╢рж┐рж╢рзБрж░ ржЬржирзНржп ржЫрзЛржЯ ржХрзБржХрж┐ ржжрж┐рждрзЗ ржЪрж╛ржЗ, ржмржбрж╝ ржХрзБржХрж┐ ржкрж░рзЗ ржмрзНржпржмрж╣рж╛рж░ рж╣ржмрзЗред

Technique: Sorting + Greedy

int i=0;
int j=0;
int count=0;


i тЖТ child index

j тЖТ cookie index

count тЖТ ржЦрзБрж╢рж┐ рж╢рж┐рж╢рзБржжрзЗрж░ рж╕ржВржЦрзНржпрж╛

while(i<g.size() && j<s.size())


ржпрждржХрзНрж╖ржг рж╢рж┐рж╢рзБрж░рж╛ ржмрж╛ ржХрзБржХрж┐ рж╢рзЗрж╖ рж╣рзЯржирж┐, loop ржЪрж╛рж▓рж╛ржЗред

if(s[j] >= g[i])
{
    g[i]=s[j];
    i++;
    j++;
    count++;
}
else
{
    j++;
}


Line by line logic:

s[j] >= g[i] тЖТ ржпржжрж┐ ржХрзБржХрж┐рж░ рж╕рж╛ржЗржЬ рж╢рж┐рж╢рзБрж░ ржЦрж┐ржжрзЗрж░ рж╕ржорж╛ржи ржмрж╛ ржмрзЗрж╢рж┐ рж╣рзЯ:

рж╢рж┐рж╢рзБ ржЦрзБрж╢рж┐ тЖТ count++

ржкрж░рзЗрж░ рж╢рж┐рж╢рзБ (i++)

ржкрж░рзЗрж░ ржХрзБржХрж┐ (j++)

else тЖТ ржпржжрж┐ ржХрзБржХрж┐ ржЫрзЛржЯ рж╣рзЯ:

рж╢рж┐рж╢рзБ ржЦрзБрж╢рж┐ рж╣ржмрзЗ ржирж╛

ржкрж░рзЗрж░ ржХрзБржХрж┐ ржжрж┐рзЯрзЗ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рждрзЗ рж╣ржмрзЗ (j++)

ржХрзЗржи ржХрж╛ржЬ ржХрж░ржЫрзЗ:

ржЫрзЛржЯ рж╢рж┐рж╢рзБ ржкрзНрж░ржержорзЗ satisfy рж╣ржЪрзНржЫрзЗ тЖТ ржмржбрж╝ ржХрзБржХрж┐ ржкрж░рзЗ ржмржбрж╝ ржЦрж┐ржжрзЗ рж╢рж┐рж╢рзБрж░ ржЬржирзНржп ржерж╛ржХржмрзЗред

рждрж╛ржЗ ржЖржорж░рж╛ Maximum number of content children ржкрж╛ржЗред

return i;


ржЖржорж░рж╛ i return ржХрж░рж┐ ржХрж╛рж░ржг i = ржЦрзБрж╢рж┐ рж╢рж┐рж╢рзБржжрзЗрж░ рж╕ржВржЦрзНржпрж╛ред

рждрзЛржорж╛рж░ count ржнрзНржпрж╛рж░рж┐рзЯрзЗржмрж▓ technically same, рждржмрзЗ i ржУ count ржПржХржЗ result ржжрзЗрзЯред

Test Case ржжрж┐рзЯрзЗ ржмрзБржЭрж╛

Example 1:
g = [1,2,3], s = [1,1]

Sort тЖТ g = [1,2,3], s = [1,1]

Step 1: i=0, j=0 тЖТ s[0]=1 >= g[0]=1 тЖТ match тЖТ i=1, j=1

Step 2: i=1, j=1 тЖТ s[1]=1 < g[1]=2 тЖТ match ржирж╛ тЖТ j++

Step 3: j рж╢рзЗрж╖ тЖТ loop end

Output тЖТ i=1 (1 рж╢рж┐рж╢рзБ ржЦрзБрж╢рж┐) тЬЕ

Example 2:
g = [1,2], s = [1,2,3]

Sort тЖТ g=[1,2], s=[1,2,3]

Step 1: s[0]=1 >= g[0]=1 тЖТ match тЖТ i=1,j=1

Step 2: s[1]=2 >= g[1]=2 тЖТ match тЖТ i=2,j=2

Output тЖТ i=2 (2 рж╢рж┐рж╢рзБ ржЦрзБрж╢рж┐) тЬЕ

Technique used

Sorting тЖТ ржЫрзЛржЯ ржЦрж┐ржжрзЗ/ржХрзБржХрж┐ ржЖржЧрзЗ process ржХрж░рж╛

Greedy тЖТ ржкрзНрж░рждрж┐ржмрж╛рж░ ржЫрзЛржЯest possible cookie smallest greed satisfy ржХрж░рждрзЗ ржмрзНржпржмрж╣рж╛рж░

Two pointer тЖТ i (children), j (cookies)

ржХрж╛рж░ржг accepted:

рж╕ржм test case satisfy ржХрж░рзЗ тЖТ maximum children get satisfied

Time complexity: O(n log n + m log m) (sorting) + O(n + m) (loop)

Efficient ржПржмржВ constraints ржПрж░ ржоржзрзНржпрзЗ safe

ЁЯТб Summary (Bangla)

ржЫрзЛржЯ рж╢рж┐рж╢рзБ ржЖржЧрзЗ satisfy ржХрж░рж╛ тЖТ ржмржбрж╝ ржХрзБржХрж┐ ржмржбрж╝ рж╢рж┐рж╢рзБрж░ ржЬржирзНржп рж░рж╛ржЦрж╛

Greedy + Two pointer + Sorting тЖТ perfect combination

Maximum number of content children ржкрж╛ржУржпрж╝рж╛ ржпрж╛ржпрж╝


Full Code:
------------

class Solution
 {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) 
    {
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        int i=0;
        int j=0;
        int count=0;
        while(i<g.size()&&j<s.size())
        {
            if(s[j]>=g[i])
            {
                g[i]=s[j];
               /* g.erase(g.begin()+i);
                s.erase(s.begin()+j);
                */
                   i++;
                   j++;
                
                count++;
                
            }
            else
            {
                j++;
            }
           
        }
        return i;
    }
};
