тЬЕ Step 1: ржкрзНрж░рж╢рзНржи ржмрзБржЭрзЗ ржЪрж┐ржирзНрждрж╛ ржХрж░рж╛

ржХрзА ржЪрж╛ржЪрзНржЫрзЗ?

рждрзЛржорж╛ржХрзЗ ржПржоржи i, j ржЬрзЛрзЬрж╛рж░ рж╕ржВржЦрзНржпрж╛ ржЧрзБржирждрзЗ рж╣ржмрзЗ ржпрзЗржЦрж╛ржирзЗ:

0 <= i < j < nums.length

nums[i] ржПрж░ ржкрзНрж░ржержо ржбрж┐ржЬрж┐ржЯ ржПржмржВ nums[j] ржПрж░ рж╢рзЗрж╖ ржбрж┐ржЬрж┐ржЯ coprime (gcd = 1)



---

тЬЕ Step 2: ржХрзЛржб рж▓рзЗржЦрж╛рж░ ржЖржЧрзЗ ржЪрж┐ржирзНрждрж╛ ржХрж░рзЛ - ржкрзНрж░рзЯрзЛржЬржирзАрзЯ ржлрж╛ржВрж╢ржиржЧрзБрж▓рзЛ

ржкрзНрж░ржержорзЗ рж╕ржорж╕рзНржпрж╛ ржнрзЗржЩрзЗ ржнрзЗржЩрзЗ ржжрзЗржЦрж┐:

1. ржПржХржЯрж╛ ржлрж╛ржВрж╢ржи рж▓рж╛ржЧржмрзЗ ржХрзЛржирзЛ рж╕ржВржЦрзНржпрж╛рж░ ржкрзНрж░ржержо ржбрж┐ржЬрж┐ржЯ ржмрзЗрж░ ржХрж░рждрзЗ тЮд findfirst()


2. ржЖрж░рзЗржХржЯрж╛ ржлрж╛ржВрж╢ржи рж▓рж╛ржЧржмрзЗ рж╢рзЗрж╖ ржбрж┐ржЬрж┐ржЯ ржмрзЗрж░ ржХрж░рждрзЗ тЮд findlast()
ржпржжрж┐ржУ рж╢рзЗрж╖ ржбрж┐ржЬрж┐ржЯ n % 10 ржХрж░рж▓рзЗржЗ ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯред


3. ржПржХржЯрж╛ ржлрж╛ржВрж╢ржи рж▓рж╛ржЧржмрзЗ gcd ржмрзЗрж░ ржХрж░рж╛рж░ ржЬржирзНржп тЮд findgcd()




---

тЬЕ Step 3: рж▓ржЬрж┐ржХ ржнрж╛ржмржирж╛ (ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо)

рж╕ржм i < j ржЬрзЛрзЬрж╛рж░ ржЙржкрж░ рж▓рзБржк ржЪрж╛рж▓рж╛ржУ

ржкрзНрж░рждрж┐ржЯрж┐ ржЬрзЛрзЬрж╛рж░ ржЬржирзНржп:

nums[i] ржерзЗржХрзЗ first digit

nums[j] ржерзЗржХрзЗ last digit

рждрж╛ржжрзЗрж░ gcd == 1 ржХрж┐ржирж╛ ржЪрзЗржХ ржХрж░рзЛ тЖТ coprime

рж╣рж▓рзЗ count ржмрж╛рзЬрж╛ржУ




---

тЬЕ Step 4: рждрзЛржорж╛рж░ ржХрзЛржб ржмрзНржпрж╛ржЦрзНржпрж╛ (рж▓рж╛ржЗржи ржмрж╛ржЗ рж▓рж╛ржЗржи)

class Solution 
{
public:

ржПржХржЯрж┐ Solution ржХрзНрж▓рж╛рж╕ ржЦрзБрж▓рзЗржЫрзЛ тАФ LeetCode рж╕рзНржЯрж╛ржЗрж▓ ржЕржирзБрж╕рж╛рж░рзЗред


---

int findgcd(int a,int b)
    {
        while(b!=0)
        {
            int temp=b;
            b=a%b;
            a=temp;
        }
        return a;
    }

ЁЯУМ GCD ржмрзЗрж░ ржХрж░рж╛рж░ ржлрж╛ржВрж╢ржи (Euclidean Algorithm)
ржзрж░рж┐ a = 8, b = 5 тЖТ gcd(8, 5)
тЖТ a % b = 8 % 5 = 3, рждрж╛рж░ржкрж░ a = 5, b = 3
тЖТ a % b = 5 % 3 = 2
тЖТ a = 3, b = 2 тЖТ ... ржпрждржХрзНрж╖ржг ржирж╛ b = 0, рждржЦржи a рж╣ржмрзЗ GCD.


---

int findfirst(int n)
    {
        vector<int>v;
        while(n>0)
        {
            int rem=n%10;
            v.push_back(rem);
            n=n/10;
        }
        reverse(v.begin(),v.end());
        return v[0];
    }

ЁЯУМ findfirst ржлрж╛ржВрж╢ржи: рж╕ржВржЦрзНржпрж╛рж░ ржкрзНрж░ржержо ржбрж┐ржЬрж┐ржЯ ржмрзЗрж░ ржХрж░рж╛рж░ ржЬржирзНржпред ржЙржжрж╛рж╣рж░ржг: n = 2932
тЖТ v = {2, 9, 3, 2}
тЖТ v[0] = 2 тЗТ ржПржЯрж╛ рж╣рж▓рзЛ ржкрзНрж░ржержо ржбрж┐ржЬрж┐ржЯред

ЁЯУМ ржПржЯрж┐ ржПржХржЯрзБ optimize ржХрж░рж╛ ржпрзЗржд тАФ ржирж┐ржЪрзЗ ржмрж▓ржмрзЛред


---

int findlast(int n)
    {
        vector<int>v;
        while(n>0)
        {
            int rem=n%10;
            v.push_back(rem);
            n=n/10;
        }
        reverse(v.begin(),v.end());
        return v[v.size()-1];
    }

ЁЯУМ findlast: ржПржЯрж┐ ржЖрж╕рж▓рзЗ ржмрзЗрж╢рж┐ ржЬржЯрж┐рж▓ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред тЖТ рж╢рзЗрж╖ ржбрж┐ржЬрж┐ржЯ рж╣ржЪрзНржЫрзЗ n % 10 тАФ ржкрзБрж░рзЛ vector ржУ reverse ржжрж░ржХрж╛рж░ ржирзЗржЗред


---

int countBeautifulPairs(vector<int>& nums) 
    {
        int count=0;
        for(int i=0;i<nums.size();i++)
        {
            for(int j=i+1;j<nums.size();j++)
            {
                if(findgcd(findfirst(nums[i]), findlast(nums[j])) == 1)
                {
                    count++;
                }
            }
        }
        return count;
    }

ЁЯУМ ржорзВрж▓ рж▓ржЬрж┐ржХ:

рж╕ржм i < j ржЬрзЛрзЬрж╛рж░ ржЙржкрж░ рж▓рзБржк

nums[i] ржерзЗржХрзЗ first digit, nums[j] ржерзЗржХрзЗ last digit

ржпржжрж┐ рждрж╛ржжрзЗрж░ GCD = 1 тЖТ count++

рж╢рзЗрж╖рзЗ count return



---

тЬЕ Test Case: nums = [2,5,1,4]

ржЖржорж░рж╛ ржЪрзЗржХ ржХрж░рж┐ ржХрзЯржЯрж╛ beautiful pair ржЖржЫрзЗ:

i	j	first(nums[i])	last(nums[j])	gcd	coprime

0	1	2	5	1	тЬЕ
0	2	2	1	1	тЬЕ
0	3	2	4	2	тЭМ
1	2	5	1	1	тЬЕ
1	3	5	4	1	тЬЕ
2	3	1	4	1	тЬЕ


тЬЕ ржорзЛржЯ 5ржЯрж┐ beautiful pair тЖТ Output = 5


---
Full Code:
-------------

  class Solution 
{
public:
    int findgcd(int a,int b)
    {
        int ans;
        while(b!=0)
            {
                int temp=b;
                b=a%b;
                a=temp;
            }
        return a;
    }
    int findfirst(int n)
    {
        vector<int>v;
        while(n>0)
            {
                int rem=n%10;
                v.push_back(rem);
                n=n/10;
            }
        reverse(v.begin(),v.end());
        int first=v[0];
        return first;
        
    }
    int findlast(int n)
    {
        vector<int>v;
        while(n>0)
            {
                int rem=n%10;
                v.push_back(rem);
                n=n/10;
            }
        reverse(v.begin(),v.end());
        int last=v[v.size()-1];
        return last;
        
    }
    int countBeautifulPairs(vector<int>& nums) 
    {
        int count=0;
        for(int i=0;i<nums.size();i++)
            {
                for(int j=i+1;j<nums.size();j++)
                    {
                        if(i!=j)
                        {
                            if(findgcd(findfirst(nums[i]),findlast(nums[j]))==1)
                            {
                                count++;
                            }
                        }
                    }
            }
        return count;
    }
};
