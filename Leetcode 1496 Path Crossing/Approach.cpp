প্রশ্নটি কী?
তোমাকে একটি স্ট্রিং path দেওয়া আছে, যেখানে প্রতিটি ক্যারেক্টার N, S, E, W নির্দেশ করে তুমি 2D plane-এ কোন দিক দিয়ে একটি ইউনিট চলে যাচ্ছো:

N → উত্তর দিকে 1 ইউনিট

S → দক্ষিণ দিকে 1 ইউনিট

E → পূর্ব দিকে 1 ইউনিট

W → পশ্চিম দিকে 1 ইউনিট

তুমি (0, 0) থেকে শুরু করো। প্রশ্ন হলো:

এই path অনুসরণ করে তুমি কি কখনো এমন কোনো পয়েন্টে ফিরে আসবে যেখানে আগে ভিজিট করেছো?
অর্থাৎ, তোমার পথ কি কোনো অবস্থানে নিজেকে ক্রস করে?

যদি করে, তাহলে true রিটার্ন করো, না করলে false।

উদাহরণ:
Input: "NES"
Output: false
কারণ: তুমি (0,0) থেকে (0,1), তারপর (1,1), তারপর (1,0) এ গেছো — কোনও পয়েন্ট বারবার ভিজিট করো নি।

Input: "NESWW"
Output: true
কারণ:
তুমি প্রথমে (0,0) → (0,1) → (1,1) → (1,0) → (0,0) → (-1,0)
দেখো, তুমি আবার (0,0) পয়েন্টে ফিরে এসেছো। তাই ক্রসিং হয়েছে।

সমাধানের ধাপ ও চিন্তা
১. শুরু করার পজিশন সেট করা
তুমি শুরু করো (x, y) = (0, 0) থেকে। এই পজিশনটি তোমার visited সেটে প্রথমে যোগ করো। কারণ তুমি এখানে প্রথমেই আছো।

২. প্রতি ক্যারেক্টার পড়ে চলার দিক নির্ধারণ
path[i] যদি 'N' হয় → y++ (উপর উঠো)

path[i] যদি 'S' হয় → y-- (নিচে নেমো)

path[i] যদি 'E' হয় → x++ (ডানে যাও)

path[i] যদি 'W' হয় → x-- (বামে যাও)

৩. প্রত্যেক নতুন পজিশনে চেক করো
প্রতিবার তোমার নতুন পজিশন (x,y) যদি আগেই visited সেটে থাকে, অর্থাৎ তুমি আগে সেখানে গিয়েছো → তাহলে path ক্রস করেছে → true রিটার্ন করো।

৪. যদি না থাকে, তাহলে ওই পজিশনটাকে visited সেটে যোগ করো।
৫. পুরো path শেষ হওয়া পর্যন্ত কোনো পুনরাবৃত্তি না পাওয়া গেলে → false রিটার্ন করো।
ব্যবহার করা Data Structure:
std::set<std::pair<int,int>> visited;
এটা ব্যবহার করা হয়েছে কারণ:

এখানে প্রতিটি পজিশন (x,y) আলাদা আলাদা অবস্থান ধরে রাখা হয়।

যেকোনো পজিশন খুঁজে পাওয়া যায় O(log n) তে (set এ)।

এটা duplicate চেক করতে সহজ।

কোডের বিশ্লেষণ:
cpp
Copy
Edit
class Solution 
{
public:
    bool isPathCrossing(string path) 
    {
      bool iscross = false; // ক্রসিং হয়েছে কিনা ট্র্যাক করার জন্য
      int x = 0, y = 0;     // শুরু পজিশন
      std::set<std::pair<int,int>> visited;
      visited.insert({x,y}); // শুরু পয়েন্ট যোগ করলাম
      
      for(int i = 0; i < path.size(); i++)
      {
        // চলার দিক অনুযায়ী x,y পরিবর্তন
        if(path[i] == 'E') x++;
        else if(path[i] == 'W') x--;
        else if(path[i] == 'N') y++;
        else if(path[i] == 'S') y--;
        
        // চেক করো এই পজিশন কি আগে থেকেই আছে?
        if(visited.find({x,y}) != visited.end())
        {
          iscross = true;  // হ্যাঁ, ক্রসিং হয়েছে
          break;           // আর লুপ চালানোর দরকার নেই
        }
        visited.insert({x,y}); // নতুন পজিশন যোগ করো
      }
      
      return iscross;
    }
};
কেন এই পদ্ধতি ঠিক?
আমরা প্রতিটি পজিশন ট্র্যাক করছি, যাতে কোন পজিশন বারবার আসছে কিনা চেক করা যায়।

set ব্যবহার করে সহজে visited আছে কি না খুঁজে পাই।

স্ট্রিং এর দৈর্ঘ্য যত বড় হোক, এই পদ্ধতি O(n log n) সময়ে চলে, যা প্রায় যথেষ্ট ভালো।
(যদি unordered_set ব্যবহার করা যেত, তো O(n) তেও করা যেত।)

তুমি কীভাবে চিন্তা করছো এবং কোড লিখছো?
প্রথমেই তোমার ভেতরে লজিক আসবে — তুমি মনে করবে:
"আমি কোথায় আছি? কোথায় গিয়েছি? একই জায়গায় আবার গেলে ক্রস হয়েছে।"

তখন তোমার প্রাথমিক পজিশন (0,0) কে মনে রাখবে।

তারপর স্ট্রিং ধরে ধরে চার দিকের নিয়ম অনুযায়ী এক এক করে পজিশন বদলাবে।

প্রতিবার নতুন পজিশন চেক করবে আগে গিয়েছ কি না।

গিয়েছ → তাড়াতাড়ি true রিটার্ন করো।

সবশেষে false রিটার্ন করো।

টেস্টিং:
Test case 1:
Input: "NES"
Path:
(0,0) → (0,1) → (1,1) → (1,0)
সব পজিশন ইউনিক, তাই আউটপুট false

Test case 2:
Input: "NESWW"
Path:
(0,0) → (0,1) → (1,1) → (1,0) → (0,0) → (-1,0)
(0,0) আবার এসেছে, তাই আউটপুট true

সংক্ষেপে:
টেকনিক: অবস্থান ট্র্যাকিং + সেট ডাটা স্ট্রাকচার ব্যবহার করে ডুপ্লিকেট চেক

কেন গ্রহণযোগ্য: স্ট্রিং এর প্রতিটি চরিত্র ধরে ধরে চলতে হয়, প্রতিটি নতুন পয়েন্ট চেক করতে হয়, সেটের সাহায্যে দ্রুত ডুপ্লিকেট পাওয়া যায়

কোড কার্যকারিতা: ঠিকই কাজ করে, কারণ প্রতিবার চলার পরে স্থান পরীক্ষা করা হয়

টাইম কমপ্লেক্সিটি: O(n log n) বা O(n) (unordered_set হলে) যেখানে n = path.length

স্পেস কমপ্লেক্সিটি: O(n) কারণ worst case path সব ইউনিক পয়েন্ট থাকবে

তোমার কোডের অনুশীলনের জন্য:
তুমি নিজে লিখে দেখতে পারো এই কোডটি,

path ভিন্ন ভিন্ন স্ট্রিং দিয়ে পরীক্ষা করো (যেমন: "NNSSEEW", "WWSSEN", "EEEWWW")

বুঝবে কখন true এবং কখন false আসছে।

Full Code:
-----------

  class Solution 
{
public:
    bool isPathCrossing(string path) 
    {
      bool iscross=false;
      unordered_map<char,int>freq;
      int x=0;
      int y=0;
      std::set<std::pair<int,int>> visited;
      visited.insert({x,y});
      for(int i=0;i<path.size();i++)
      {
        freq[path[i]]++;
        if(path[i]=='E')
        {
          x++;
        }
        if(path[i]=='W')
        {
          x--;
        }
        if(path[i]=='N')
        {
          y++;
        }
        if(path[i]=='S')
        {
          y--;
        }
        if((visited.find({x,y})!=visited.end()))
        {
          iscross=true;
          break;
        }
        visited.insert({x,y});
     
      }
      
      return iscross;
    }
};
