рждрзБржорж┐ ржпрзЗ LeetCode ржкрзНрж░ржмрж▓рзЗржоржЯрж╛ ржжрж┐рзЯрзЗржЫрзЛ, рж╕рзЗржЯрж┐ рж╣ржЪрзНржЫрзЗ:


---

ЁЯФв 1175. Prime Arrangements

> Statement (Bengali Translation):
рждрзЛржорж╛ржХрзЗ рж╕ржВржЦрзНржпрж╛ 1 ржерзЗржХрзЗ n ржкрж░рзНржпржирзНржд рж╕ржм рж╕ржВржЦрзНржпрж╛рж░ ржПржХржЯрж┐ ржкрж╛рж░ржорзБржЯрзЗрж╢ржи (ржмрж┐ржирзНржпрж╛рж╕) ржмрзЗрж░ ржХрж░рждрзЗ рж╣ржмрзЗ, ржпрзЗржЦрж╛ржирзЗ ржкрзНрж░рж╛ржЗржо рж╕ржВржЦрзНржпрж╛ ржЧрзБрж▓рзЛ ржкрзНрж░рж╛ржЗржо ржЗржиржбрзЗржХрзНрж╕рзЗ ржерж╛ржХржмрзЗ (ржЗржиржбрзЗржХрзНрж╕ 1-based)ред
ржлрж▓рж╛ржлрж▓ржЯрж┐ ржЕржирзЗржХ ржмрзЬ рж╣рждрзЗ ржкрж╛рж░рзЗ, рждрж╛ржЗ 10^9 + 7 ржжрж┐рзЯрзЗ mod ржирж┐рждрзЗ рж╣ржмрзЗред




---

ЁЯФН ржЙржжрж╛рж╣рж░ржг:

Input: n = 5
Output: 12
Explanation:
n = 5 тЖТ [1, 2, 3, 4, 5]
ржкрзНрж░рж╛ржЗржо ржЗржиржбрзЗржХрзНрж╕ тЖТ 2, 3, 5
ржПржЗ ржЗржиржбрзЗржХрзНрж╕ржЧрзБрж▓рзЛрждрзЗ ржХрзЗржмрж▓ ржкрзНрж░рж╛ржЗржо рж╕ржВржЦрзНржпрж╛ рж░рж╛ржЦрждрзЗ ржкрж╛рж░ржмрзЗред
ржкрзНрж░рж╛ржЗржо рж╕ржВржЦрзНржпрж╛ тЖТ 2, 3, 5
ржПржЗ рждрж┐ржиржЯрж┐ ржкрзНрж░рж╛ржЗржо рж╕ржВржЦрзНржпрж╛ рждрж┐ржиржЯрж┐ ржкрзНрж░рж╛ржЗржо ржЗржиржбрзЗржХрзНрж╕рзЗ ржпрзЗржХрзЛржирзЛржнрж╛ржмрзЗ ржмрж╕рждрзЗ ржкрж╛рж░рзЗ тЖТ 3! = 6 ржЙржкрж╛рзЯрзЗ
ржмрж╛ржХрж┐ рж╕ржВржЦрзНржпрж╛ржЧрзБрж▓рзЛ (1, 4) ржмрж╛ржХрж┐ ржЗржиржбрзЗржХрзНрж╕рзЗ ржмрж╕ржмрзЗ тЖТ 2! = 2 ржЙржкрж╛рзЯрзЗ
ржорзЛржЯ ржкрж╛рж░ржорзБржЯрзЗрж╢ржи = 6 ├Ч 2 = 12


---

тЬЕ Step-by-Step Approach (Bangla ржмрж┐рж╢рзНрж▓рзЗрж╖ржг)


---

ЁЯТб Step 1: ржмрзБржЭрждрзЗ рж╣ржмрзЗ тАУ ржХрзЛржи рж╕ржВржЦрзНржпрж╛ ржЧрзБрж▓рзЛ ржкрзНрж░рж╛ржЗржо?

ржкрзНрж░ржержорзЗ 1 ржерзЗржХрзЗ n ржкрж░рзНржпржирзНржд ржХрждржЧрзБрж▓рзЛ ржкрзНрж░рж╛ржЗржо рж╕ржВржЦрзНржпрж╛ ржЖржЫрзЗ рждрж╛ ржмрзЗрж░ ржХрж░ржмред

bool TestPrime(int n)

ржПржЗ ржлрж╛ржВрж╢ржиржЯрж┐ ржПржХржЯрж┐ рж╕ржВржЦрзНржпрж╛ n ржкрзНрж░рж╛ржЗржо ржХрж┐ржирж╛ рждрж╛ ржмрж▓рзЗред
ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо:

2 ржПрж░ ржирж┐ржЪрзЗ рж╕ржм рж╕ржВржЦрзНржпрж╛ ржкрзНрж░рж╛ржЗржо ржирж╛ред

рждрж╛рж░ржкрж░ 2 ржерзЗржХрзЗ тИЪn ржкрж░рзНржпржирзНржд ржЪрзЗржХ ржХрж░рж┐ n ржХрж┐ ржХрзЛржирзЛ рж╕ржВржЦрзНржпрж╛ ржжрж┐рзЯрзЗ ржнрж╛ржЧ ржпрж╛рзЯ?

ржпржжрж┐ ржпрж╛рзЯ, рждрж╛рж╣рж▓рзЗ ржкрзНрж░рж╛ржЗржо ржирж╛ред

ржпржжрж┐ ржирж╛ ржпрж╛рзЯ, рждрж╛рж╣рж▓рзЗ ржкрзНрж░рж╛ржЗржоред


тП▒я╕П Time Complexity: O(тИЪn)


---

ЁЯТб Step 2: ржХрждржЧрзБрж▓рзЛ ржкрзНрж░рж╛ржЗржо ржЖржЫрзЗ рждрж╛ ржЧрзБржирзЗ ржирзЗржЗ

for(int i=1;i<=n;i++)
{
    if(TestPrime(i))
    {
        pc++; // ржкрзНрж░рж╛ржЗржо ржХрж╛ржЙржирзНржЯ
    }
}

pc = ржкрзНрж░рж╛ржЗржо рж╕ржВржЦрзНржпрж╛ ржЧрзБрж▓рзЛрж░ рж╕ржВржЦрзНржпрж╛
npc = n - pc = ржиржи-ржкрзНрж░рж╛ржЗржо рж╕ржВржЦрзНржпрж╛рж░ рж╕ржВржЦрзНржпрж╛


---

ЁЯТб Step 3: ржХрждрзЛржнрж╛ржмрзЗ ржмрж╕рж╛ржирзЛ ржпрж╛рзЯ?

ржЖржорж░рж╛ ржЬрж╛ржирж┐,

ржкрзНрж░рж╛ржЗржо рж╕ржВржЦрзНржпрж╛ ржЧрзБрж▓рзЛ ржкрзНрж░рж╛ржЗржо ржЗржиржбрзЗржХрзНрж╕ ржЧрзБрж▓рзЛрждрзЗ ржмрж╕ржмрзЗ

ржиржи-ржкрзНрж░рж╛ржЗржо рж╕ржВржЦрзНржпрж╛ ржЧрзБрж▓рзЛ ржмрж╛ржХрж┐ ржЗржиржбрзЗржХрзНрж╕рзЗ ржмрж╕ржмрзЗ


ржзрж░рж┐:

ржкрзНрж░рж╛ржЗржо рж╕ржВржЦрзНржпрж╛ ржЧрзБрж▓рзЛ pc! ржЙржкрж╛рзЯрзЗ рж╕рж╛ржЬрж╛ржирзЛ ржпрж╛ржмрзЗ

ржиржи-ржкрзНрж░рж╛ржЗржо рж╕ржВржЦрзНржпрж╛ ржЧрзБрж▓рзЛ npc! ржЙржкрж╛рзЯрзЗ рж╕рж╛ржЬрж╛ржирзЛ ржпрж╛ржмрзЗ


int ans = (findfact(pc) * findfact(npc)) % MOD;


---

ЁЯТб Step 4: Factorial ржлрж╛ржВрж╢ржи

long long findfact(int n)
{
    const int MOD=1e9+7;
    long long p=1;
    for(int i=n;i>=1;i--)
    {
        p=(p*i)%MOD;
    }
    return p;
}

ржПржЗ ржлрж╛ржВрж╢ржи n! % MOD рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рзЗ
(ржпрж╛рждрзЗ overflow ржирж╛ рж╣рзЯ)


---

тЬЕ Code Summary:

class Solution 
{
public:
    bool TestPrime(int n)
    {
        if(n<2) return false;
        for(int i=2;i*i<=n;i++)
        {
            if(n%i==0)
                return false;
        }
        return true;
    }

    long long findfact(int n)
    {
        const int MOD=1e9+7;
        long long p=1;
        for(int i=n;i>=1;i--)
        {
            p=(p*i)%MOD;
        }
        return p;
    }

    int numPrimeArrangements(int n) 
    {
        const int MOD=1e9+7;
        int pc=0;
        for(int i=1;i<=n;i++)
        {
            if(TestPrime(i))
                pc++;
        }
        int npc=n-pc;
        return (findfact(pc)*findfact(npc))%MOD;
    }
};


---

ЁЯУК Mathematical Summary:

Total positions = n

Prime numbers count = pc

Prime indices count = pc (1-based indices: 2, 3, 5, 7, ...)

Valid arrangements = pc! * (n - pc)!

Final result = (pc! * npc!) % 1e9+7



---

ЁЯзк Test Case ржмрзНржпрж╛ржЦрзНржпрж╛:

Input: n = 5

Prime numbers: 2, 3, 5 тЖТ pc = 3

Non-prime numbers: 1, 4 тЖТ npc = 2

Total valid permutations: 3! * 2! = 6 * 2 = 12


Input: n = 100

Total primes from 1 to 100 = 25 (pre-known or count with sieve)

So pc = 25, npc = 75

Result = 25! * 75! % 1e9+7 = 682289015



---

ЁЯза ржмрзБржЭрзЗ ржХрзЛржб рж▓рзЗржЦрж╛рж░ ржХрзМрж╢рж▓:

1. ржкрзНрж░рж╢рзНржирзЗ ржмрж▓рж╛ рж╣рзЯрзЗржЫрзЗ тАЬprime numbers should be at prime indicesтАЭ тЖТ ржоржирзЗ рж░рж╛ржЦрждрзЗ рж╣ржмрзЗ 1-based indexingред


2. рждрж╛рж╣рж▓рзЗ ржХрж╛ржЬржЯрж╛ рж╣рзЯрзЗ ржЧрзЗрж▓:

Total ржХрждржЧрзБрж▓рзЛ ржкрзНрж░рж╛ржЗржо ржЖржЫрзЗ рждрж╛ ржмрзЗрж░ ржХрж░рж╛

рждрж╛ржжрзЗрж░ factorial ржмрзЗрж░ ржХрж░рж╛

ржмрж╛ржХрж┐ржжрзЗрж░ factorial ржмрзЗрж░ ржХрж░рж╛

ржЧрзБржг ржХрж░рж╛



3. ржпрждржмрж╛рж░ржЗ factorial ржмрзЗрж░ ржХрж░ржм, рж╕ржмрж╕ржорзЯ MOD ржирж┐рждрзЗ рж╣ржмрзЗред




---

ЁЯФБ Time Complexity:

Prime Count: O(nтИЪn)

Factorial: O(n)
Total: O(nтИЪn)



---

тЬЕ Accepted рж╣ржУрзЯрж╛рж░ ржХрж╛рж░ржг:

рж╕ржм constraint (1 тЙд n тЙд 100) ржПрж░ ржоржзрзНржпрзЗ efficient solution

Modulo overflow рж░ржХрзНрж╖рж╛

Simple, correct logic based on combinatorics



---

Full Code:
-------------

  class Solution 
{
public:
    bool TestPrime(int n)
    {
        if(n<2) return false;
        bool isprime=true;
        for(int i=2;i*i<=n;i++)
            {
                if(n%i==0)
                {
                    isprime=false;
                    break;
                }
            }
        return isprime;
    }
    long long findfact(int n)
    {
        const int MOD=1e9+7;
        long long p=1;
        for(int i=n;i>=1;i--)
            {
                p=(p*i)%MOD;
            }
        return p;
    }
    int numPrimeArrangements(int n) 
    {
        const int MOD=1e9+7;
        int pc=0;
        int npc;
        for(int i=1;i<=n;i++)
            {
                if(TestPrime(i))
                {
                    pc++;
                }
            }
        npc=n-pc;
        int ans=(findfact(pc)*findfact(npc))%MOD;
        return ans;
    }
};
