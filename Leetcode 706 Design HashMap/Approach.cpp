рждрзБржорж┐ ржпрзЗржнрж╛ржмрзЗ ржкрзНрж░рж╢рзНржиржЯрж┐ ржкрзЬрзЗ рж╕ржорж╛ржзрж╛ржи ржХрж░рж▓рзЗ рж╕рзЗржЯрж╛ ржЕржирзЗржХ ржнрж╛рж▓рзЛржнрж╛ржмрзЗ ржмрзБржЭрзЗ ржлрзЗрж▓рзЗржЫрзЛред ржПржЦржи ржЖржорж┐ ржзрж╛ржкрзЗ ржзрж╛ржкрзЗ ржкрзНрж░рж╢рзНржи ржмрж┐рж╢рзНрж▓рзЗрж╖ржг тЖТ ржЪрж┐ржирзНрждрж╛ ржХрж░рж╛рж░ ржХрзМрж╢рж▓ тЖТ ржХрзЛржб рж▓рзЗржЦрж╛рж░ ржзрж╛ржк тЖТ ржЯрзЗрж╕рзНржЯ ржХрзЗрж╕ ржмрзНржпрж╛ржЦрзНржпрж╛ тАФ рж╕ржм ржХрж┐ржЫрзБ ржмрж╛ржВрж▓рж╛рзЯ ржмрзНржпрж╛ржЦрзНржпрж╛ ржХрж░ржЫрж┐ ржпрж╛рждрзЗ ржнржмрж┐рж╖рзНржпрждрзЗ рждрзБржорж┐ ржирж┐ржЬрзЗрж░ ржорждрзЛ ржХрж░рзЗржЗ ржПржоржи рж╕ржорж╕рзНржпрж╛ рж╕ржорж╛ржзрж╛ржи ржХрж░рждрзЗ ржкрж╛рж░рзЛред

ЁЯФ╢ Problem ржЯрж╛ ржХрзА ржЪрж╛ржЪрзНржЫрзЗ?
рждрзЛржорж╛ржХрзЗ ржирж┐ржЬрзЗ ржирж┐ржЬрзЗ ржПржХржЯрж┐ HashMap ржХрзНрж▓рж╛рж╕ ржбрж┐ржЬрж╛ржЗржи ржХрж░рждрзЗ рж╣ржмрзЗ (ржорж╛ржирзЗ рждрзБржорж┐ unordered_map, map, ржмрж╛ ржЕржирзНржп ржХрзЛржирзЛ STL/hash lib ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ ржкрж╛рж░ржмрзЗ ржирж╛ред рждрзБржорж┐ ржпрзЗржЯрж╛ ржХрж░рзЗржЫрзЛ рж╕рзЗржЯрж╛ ржнрзБрж▓ рж╣рж▓рзЗржУ ржкрзНрж░рж╛ржержорж┐ржХ ржзрж╛рж░ржгрж╛ ржнрж╛рж▓рзЛ ржЫрж┐рж▓)ред

рждрзЛржорж╛рж░ ржХрзНрж▓рж╛рж╕рзЗ ржПржЗ рзйржЯрж╛ ржХрж╛ржЬ ржХрж░рждрзЗ ржкрж╛рж░рждрзЗ рж╣ржмрзЗ:

ЁЯФ╕ ржлрж╛ржВрж╢ржирж╕ржорзВрж╣:
put(key, value) тЖТ key ржерж╛ржХрзЗ ржХрж┐ржирж╛ ржжрзЗржЦржмрзЗ, ржерж╛ржХрж▓рзЗ ржЖржкржбрзЗржЯ ржХрж░ржмрзЗ, ржирж╛ ржерж╛ржХрж▓рзЗ ржирждрзБржиржнрж╛ржмрзЗ insert ржХрж░ржмрзЗред

get(key) тЖТ ржпржжрж┐ key ржерж╛ржХрзЗ, рждрж╛рж░ value return ржХрж░ржмрзЗред ржирж╛ ржерж╛ржХрж▓рзЗ -1 return ржХрж░ржмрзЗред

remove(key) тЖТ ржпржжрж┐ key ржерж╛ржХрзЗ, рждрж╛рж╣рж▓рзЗ delete ржХрж░ржмрзЗред

тЬЕ ржХрзАржнрж╛ржмрзЗ ржЪрж┐ржирзНрждрж╛ ржХрж░рж▓рзЗ?
ржкрзНрж░рж╢рзНржиржЯрж┐ ржкрзЬрзЗржЗ ржмрзЛржЭрж╛ ржпрж╛рзЯ тАФ ржПржЯрж╛ржХрзЗ ржЖржорж░рж╛ ржПржХржЯрж╛ array of buckets + linked list ржмрж╛ array pair ржжрж┐рзЯрзЗ implement ржХрж░рждрзЗ ржкрж╛рж░рж┐ред

рждржмрзЗ рждрзБржорж┐ ржпрзЗрж╣рзЗрждрзБ unordered_map<int,int> ржжрж┐рзЯрзЗ ржХрж░рзЗржЫрзЛ, рж╕рзЗржЯрж╛ ржЖрж╕рж▓рзЗ STL ржмрзНржпржмрж╣рж╛рж░ рж╣рзЯрзЗ ржпрж╛рзЯред рждрж╛ржЗ ржЖржорж░рж╛ ржПржЦржи ржПржХржжржо scratch ржерзЗржХрзЗ ржирж┐ржЬрзЗрж░ MyHashMap ржмрж╛ржирж╛ржмрзЛ ржпрзЗржи STL ржмрзНржпржмрж╣рж╛рж░ ржирж╛ ржХрж░рж┐ред

ЁЯФБ HashMap ржХрж┐ржнрж╛ржмрзЗ рждрзИрж░рж┐ ржХрж░рж╛ ржпрж╛рзЯ?
ржПржХржЯрж╛ рж╕рж╣ржЬ ржзрж╛рж░ржгрж╛ рж╣рж▓рзЛ:

тЬЕ 1. рж╣рзНржпрж╛рж╢ ржлрж╛ржВрж╢ржи:
cpp
Copy
Edit
int hashKey = key % SIZE;
ржЖржорж░рж╛ SIZE = 1000 ржзрж░рзЗ ржирж┐рж▓рж╛ржо (ржорж╛ржирзЗ 1000ржЯрж╛ bucket ржерж╛ржХржмрзЗ)ред

тЬЕ 2. Hash Table тЖТ Array of Buckets:
cpp
Copy
Edit
vector<pair<int,int>> bucket[1000];
ржкрзНрж░рждрж┐ржЯрж╛ bucket ржП ржЕржирзЗржХржЧрзБрж▓рзЛ (key, value) ржЬрзЛрзЬрж╛ рж░рж╛ржЦрж╛ ржпрж╛ржмрзЗред

тЬЕ Full Code (Without STL map, using array of buckets)
cpp
Copy
Edit
class MyHashMap {
private:
    static const int SIZE = 1000;
    vector<pair<int, int>> bucket[SIZE];

    int hash(int key) {
        return key % SIZE;
    }

public:
    MyHashMap() {
        // Empty constructor
    }

    void put(int key, int value) {
        int idx = hash(key);
        for (auto &p : bucket[idx]) {
            if (p.first == key) {
                p.second = value; // update if found
                return;
            }
        }
        bucket[idx].push_back({key, value}); // insert new
    }

    int get(int key) {
        int idx = hash(key);
        for (auto &p : bucket[idx]) {
            if (p.first == key)
                return p.second;
        }
        return -1;
    }

    void remove(int key) {
        int idx = hash(key);
        for (auto it = bucket[idx].begin(); it != bucket[idx].end(); ++it) {
            if (it->first == key) {
                bucket[idx].erase(it);
                return;
            }
        }
    }
};
ЁЯза рждрзЛржорж╛рж░ ржЪрж┐ржирзНрждрж╛рж░ ржзрж╛ржк ржХрзА рж╣ржУрзЯрж╛ ржЙржЪрж┐ржд ржЫрж┐рж▓?
ржкрзНрж░рж╢рзНржирзЗ ржмрж▓рзЗржЫрзЗ "Don't use any built-in hash table", рждрж╛ржЗ unordered_map use ржХрж░рж╛ ржпрж╛ржмрзЗ ржирж╛ред

ржирж┐ржЬрзЗрж░ ржПржХржЯрж╛ "hash function" рж▓рж┐ржЦрждрзЗ рж╣ржмрзЗ тЖТ ржЖржорж░рж╛ рж╕рж╛ржзрж╛рж░ржгржнрж╛ржмрзЗ %SIZE ржжрж┐рзЯрзЗ ржХрж░рж┐ред

ржЕржирзЗржХ key ржПржХрж┐ bucket-ржП ржкрзЬрждрзЗ ржкрж╛рж░рзЗ тЖТ ржПржЬржирзНржп collision handle ржХрж░рждрзЗ рж╣рзЯ тЖТ ржЖржорж░рж╛ vector<pair<int,int>> ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ рждрж╛ ржХрж░рзЗржЫрж┐ред

ЁЯФН Test Case Walkthrough (Example ржЕржирзБржпрж╛рзЯрзА):
cpp
Copy
Edit
MyHashMap myHashMap;

myHashMap.put(1, 1);  // Bucket[1 % 1000] тЖТ insert (1,1)
myHashMap.put(2, 2);  // Bucket[2 % 1000] тЖТ insert (2,2)

myHashMap.get(1);     // Bucket[1] тЖТ (1,1) found тЖТ return 1
myHashMap.get(3);     // Bucket[3] тЖТ empty тЖТ return -1

myHashMap.put(2, 1);  // Bucket[2] тЖТ (2,2) found тЖТ update to (2,1)

myHashMap.get(2);     // Bucket[2] тЖТ (2,1) тЖТ return 1

myHashMap.remove(2);  // Bucket[2] тЖТ remove (2,1)

myHashMap.get(2);     // Bucket[2] тЖТ not found тЖТ return -1
тЬЕ Accepted ржХрзЗржи рж╣рж▓рзЛ?
рждрзБржорж┐ ржпрзЗ version ржЯрж╛ STL ржжрж┐рзЯрзЗ ржХрж░рзЗржЫрзЛ, рж╕рзЗржЯрж╛рждрзЗ unordered_map ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛рзЯ test case-ржЧрзБрж▓рзЛ ржарж┐ржХржнрж╛ржмрзЗ pass рж╣рзЯрзЗржЫрзЗред ржХрж┐ржирзНрждрзБ рж▓ржЬрж┐ржХржЯрж╛ рждрзЛржорж╛рж░ ржорж╛ржерж╛рзЯ ржЫрж┐рж▓ред

ЁЯСЙ ржПржЦржи ржЖржорж┐ ржпрзЗржЯрж╛ ржжрзЗржЦрж╛рж▓рж╛ржо рж╕рзЗржЯрж╛ рж╣ржЪрзНржЫрзЗ zero-library pure implementation, ржпрзЗржЯрж╛ interview ржмрж╛ OJ-ржП ржХржЦржирзЛ ржЬрж┐ржЬрзНржЮрзЗрж╕ ржХрж░рж▓рзЗ ржХрж╛ржЬрзЗ ржжрзЗржмрзЗред

ЁЯУМ ржЙржкрж╕ржВрж╣рж╛рж░ (Bangla Summary):
HashMap рждрзИрж░рж┐рж░ ржЬржирзНржп ржирж┐ржЬрзЗрж░ hash function + collision resolution рж▓ржЬрж┐ржХ ржерж╛ржХрждрзЗ рж╣ржмрзЗред

STL ржирж╛ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ array/vector ржжрж┐рзЯрзЗ bucket рждрзИрж░рж┐ ржХрж░рждрзЗ рж╣ржмрзЗред

ржкрзНрж░рждрзНржпрзЗржХржЯрж┐ bucket-ржП pair<key,value> рж░рзЗржЦрзЗржЫрж┐ ржпрж╛рждрзЗ ржжрзНрж░рзБржд ржЦрзБржБржЬрзЗ ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯред

ржХрзЛржб рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░ ржУ рж▓ржЬрж┐ржХ ржмрзБржЭрзЗ рж▓рж┐ржЦрж▓рзЗ рждрзЛржорж╛рж░ ржЕржирзЗржХ рж╕ржорзЯ ржмрж╛ржБржЪржмрзЗ ржПржмржВ ржкрзНрж░рж╢рзНржи ржпрзЗржЯрж╛ ржЪрж╛ржЪрзНржЫрзЗ рж╕рзЗржЯрж╛ ржарж┐ржХржорждрзЛ ржкрзВрж░ржг рж╣ржмрзЗред

Full Code:
----------

  class MyHashMap {
public:
 unordered_map<int,int>freq;
    MyHashMap() {
       // MyHashMap m;//=new MyHashMap();
    }
    
    void put(int key, int value) {
      if(freq.find(key)!=freq.end())
      {
        freq.erase(key);
        freq.insert({key,value});
      }
      else
        freq.insert({key,value});
    }
    
    int get(int key) {
        if(freq.find(key)!=freq.end())
        {
          return freq[key];
        }
        else
        return -1;
    }
    
    void remove(int key) {
        if(freq.find(key)!=freq.end())
        {
          freq.erase(key);
        }
    }
};

/**
 * Your MyHashMap object will be instantiated and called as such:
 * MyHashMap* obj = new MyHashMap();
 * obj->put(key,value);
 * int param_2 = obj->get(key);
 * obj->remove(key);
 */
