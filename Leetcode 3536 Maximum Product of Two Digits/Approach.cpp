প্রশ্নটা কী বলছে? (Problem Understanding)

তোমাকে একটা পজিটিভ ইন্টিজার n দেওয়া আছে।

n এর ডিজিটগুলো নিয়ে, তোমাকে এমন দুটি ডিজিট বাছাই করতে হবে, যাদের গুণফল সবচেয়ে বড়।

একই ডিজিট দুবার ব্যবহার করা যাবে যদি সেটি n এ দুবার বা তার বেশি থাকে।

যদি n এক ডিজিটের কম হয়, তাহলে আউটপুট হবে 0।


উদাহরণ:

n=31 → digits: [3,1] → গুণফলগুলো: 3*1=3 → max product = 3

n=22 → digits: [2,2] → গুণফলগুলো: 2*2=4 → max product=4

n=124 → digits: [1,2,4] → গুণফলগুলো: 12=2, 14=4, 2*4=8 → max product=8



---

তোমার সমাধানের পদ্ধতি (Solution Approach)

1. ডিজিটগুলো বের করা:
n এর প্রতিটি ডিজিট আলাদা করতে হবে।

% 10 অপারেটর ব্যবহার করে তুমি n এর শেষের ডিজিট পাবে।

n / 10 করলে n থেকে শেষের ডিজিট কেটে যায়।

এভাবে লুপ চালিয়ে n এর সব ডিজিট বের করে একটা ভেক্টরে (vector) জমা করবে।



2. ডিজিটগুলোকে উল্টানো (Reverse):
কারন তুমি % 10 করে ডিজিটগুলো বের করছো, তাই প্রথমে শেষ ডিজিট পাবে।
ফলে তোমার ভেক্টরে ডিজিটগুলো উল্টো ক্রমে থাকবে।
সেজন্য ভেক্টরটি রিভার্স করবে যেন মূল সংখ্যার ক্রম মেনে চলে।


3. যদি ডিজিটের সংখ্যা ২ এর কম হয়, তাহলে ০ রিটার্ন করবে।
কারণ দুইটা ডিজিট দরকার দুই ডিজিটের গুণফল বের করতে।


4. সব ডিজিটের দুইট দুইট করে গুণফল বের করা:
দুটি লুপ দিয়ে প্রথম ডিজিট থেকে শেষ ডিজিট পর্যন্ত, পরের ডিজিট থেকে শেষ পর্যন্ত গুণফল বের করবে।

প্রথম লুপ i: 0 থেকে শেষ ডিজিট-1

দ্বিতীয় লুপ j: i+1 থেকে শেষ ডিজিট

p ভেক্টরে এই গুণফলগুলো স্টোর করবে।



5. সব গুণফলের মধ্যে সর্বোচ্চ মান বের করা:
p ভেক্টর থেকে সর্বোচ্চ মান বের করবে।


6. সর্বোচ্চ মান রিটার্ন করবে।




---

কোডের লাইন বাই লাইন ব্যাখ্যা (Line by line explanation)

class Solution 
{
public:
    int maxProduct(int n)
    {
        // 1. যদি n একক ডিজিট হয় (10 এর নিচে), গুণফল করা সম্ভব না, তাই 0 রিটার্ন করো
        if(n<10) return 0;

        vector<int> p; // গুণফলগুলো সংরক্ষণের জন্য ভেক্টর
        vector<int> d; // n এর প্রতিটি ডিজিট সংরক্ষণের জন্য ভেক্টর

        // 2. n এর প্রতিটি ডিজিট আলাদা করা, শেষ থেকে শুরু
        while(n>0)
        {
            int digit = n % 10; // শেষের ডিজিট বের করো
            d.push_back(digit);  // ভেক্টরে যোগ করো
            n = n / 10;          // শেষের ডিজিট কেটে দাও
        }

        // 3. ডিজিটগুলোর ক্রম ঠিক করার জন্য উল্টো করে দাও
        reverse(d.begin(), d.end());

        // 4. যদি ডিজিটের সংখ্যা ২ এর কম হয়, তাহলে 0 রিটার্ন করো
        if(d.size() < 2) return 0;

        // 5. প্রতিটি দুই ডিজিটের গুণফল বের করো
        for(int i = 0; i < d.size(); i++)
        {
            for(int j = i+1; j < d.size(); j++)
            {
                p.push_back(d[i] * d[j]);
            }
        }

        // 6. গুণফলগুলোর মধ্যে সর্বোচ্চ মান খুঁজে বের করো
        int maxv = p[0]; 
        for(int j = 1; j < p.size(); j++)
        {
            if(p[j] > maxv)
            {
                maxv = p[j];
            }
        }

        // 7. সর্বোচ্চ গুণফল রিটার্ন করো
        return maxv;
    }
};


---

তুমি কীভাবে ভাবতে পারো প্রশ্নটা থেকে এই কোড লেখা পর্যন্ত

প্রথমে বুঝবে তোমার কাজ হলো একটা সংখ্যার ডিজিটগুলো নিয়ে সেই ডিজিটের যেকোনো দুইটির গুণফল বের করে, সর্বোচ্চ গুণফল খুঁজে বের করা।

তুমি জানো n থেকে কিভাবে ডিজিট বের করতে হয় (মডুলাস ও ডিভিশন ব্যবহার করে)।

তারপর সেগুলো আলাদা করে একটা ভেক্টরে রাখবে যাতে সহজে কাজ করতে পারো।

এরপর তুমি সব সম্ভাব্য দুই ডিজিটের জোড়া নিয়ে তাদের গুণফল বের করবে (২ লুপের সাহায্যে)।

সব গুণফলগুলোর সর্বোচ্চ মান বের করবে।

সেটা রিটার্ন করবে।



---

এই সলিউশন কেন টেস্টকেসগুলোতে পাস করে?

যেকোনো পজিটিভ ইন্টিজার n এর জন্য সঠিক ডিজিট আলাদা করতে পারে।

দুই ডিজিটের গুণফল সঠিকভাবে বের করতে পারে।

সর্বোচ্চ মান সঠিকভাবে খুঁজে পায়।

ছোট সংখ্যাগুলোর (যেমন একক ডিজিট) জন্য সঠিকভাবে 0 রিটার্ন করে।

Time Complexity: O(d^2) যেখানে d = ডিজিট সংখ্যা, যা সাধারণত ছোট হওয়ায় দ্রুত কাজ করে।

Space Complexity: O(d^2) গুণফল স্টোর করার জন্য, যা সাধারণ সংখ্যার জন্য ঠিক আছে।



---

সংক্ষেপে

> তুমি প্রশ্নটা পড়ার পর বুঝবে: "আমাকে দুই ডিজিটের সর্বোচ্চ গুণফল বের করতে হবে।"

তারপর করো:

সংখ্যার ডিজিট বের করো,

সব দুই ডিজিটের গুণফল বের করো,

সর্বোচ্চ মান খুঁজে রিটার্ন করো।
Test Code:
-----------
কোডের লাইন বাই লাইন ব্যাখ্যা

class Solution 
{
public:
    int maxProduct(int n)
    {
        if(n<10) return 0;

এখানে প্রথমেই চেক করা হচ্ছে যদি n একক অংক হয় (অর্থাৎ ১০ এর থেকে ছোট), তাহলে কোন দুই অংকের গুণফল করা সম্ভব না, তাই সরাসরি ০ রিটার্ন করা হয়েছে।


vector<int>p;
        vector<int>d;

p ভেক্টরটি গুণফলগুলো সংরক্ষণের জন্য।

d ভেক্টরটি সংখ্যার প্রতিটি অংক আলাদা করে রাখার জন্য।


while(n>0)
            {
                int digit=n%10;
                d.push_back(digit);
                n=n/10;
            }
        reverse(d.begin(),d.end());

এই অংশে n থেকে প্রতিটি অংক বের করা হয়েছে। %10 দিয়ে শেষের অংক বের করা হচ্ছে।

d ভেক্টরে রাখা হয়েছে অংকগুলো (লাস্ট অংক থেকে শুরু করে)।

তারপর reverse() ব্যবহার করে অংকগুলোকে তাদের মূল ক্রমে নিয়ে আসা হয়েছে।


if(d.size()<2)return 0;

যদি অংকের সংখ্যা ২ এর থেকে কম হয়, তাহলে দুই অংকের গুণফল করা সম্ভব না, তাই ০ রিটার্ন করা।


for(int i=0;i<d.size();i++)
            {
                for(int j=i+1;j<d.size();j++)
                {
                    p.push_back(d[i]*d[j]);
                }
            }

এখানে দুইটি নেস্টেড লুপের মাধ্যমে d এর প্রতিটি অংকের জোড়া নির্বাচন করা হয়েছে।

প্রতিটি জোড়ার গুণফল p ভেক্টরে সংরক্ষণ করা হয়েছে।


int maxv=p[0];
        for(int j=1;j<p.size();j++)
            {
                if(p[j]>maxv)
                {
                    maxv=p[j];
                }
            }
        return maxv;
    }
};

সব গুণফল থেকে সর্বোচ্চ মান খুঁজে বের করে maxv এ রাখা হয়েছে।

শেষ পর্যন্ত maxv রিটার্ন করা হয়েছে।



---

উদাহরণ অনুযায়ী ব্যাখ্যা

Example 1: n = 31

d হবে [3,1]

সম্ভাব্য গুণফল: 3*1 = 3

সর্বোচ্চ গুণফল = 3

রিটার্ন: 3 (সঠিক)


Example 2: n = 22

d হবে [2, 2]

সম্ভাব্য গুণফল: 2*2 = 4

সর্বোচ্চ গুণফল = 4

রিটার্ন: 4 (সঠিক)


Example 3: n = 124

d হবে [1, 2, 4]

সম্ভাব্য গুণফল:

1*2 = 2

1*4 = 4

2*4 = 8


সর্বোচ্চ গুণফল = 8

রিটার্ন: 8 (সঠিক)



---

কেন accepted হবে?

1. সঠিক অংক আলাদা করা হয়েছে: %10 ও reverse দিয়ে সঠিকভাবে অংকগুলো বের করে ধারাবাহিকভাবে সাজানো হয়েছে।


2. সব জোড়ার গুণফল হিসাব: দুই স্তরের লুপ ব্যবহার করে সব জোড়ার গুণফল নেয়া হয়েছে, কোন জোড়া বাদ নেই।


3. সর্বোচ্চ গুণফল বের করার পদ্ধতি সঠিক: লিনিয়ার স্ক্যানিং করে সর্বোচ্চ মান খুঁজে বের করছে।


4. কোনো ফাঁকা বা ভুল ক্ষেত্রে ০ রিটার্ন: যদি দুই অংকের নিচে হয়, লজিক্যালি ফলাফল ঠিক।


5. কমপ্লেক্সিটি: O(k²), যেখানে k হচ্ছে অংকের সংখ্যা, সাধারণত ছোট সংখ্যার জন্য সমস্যা নেই।




---

সংক্ষেপে:

কোডটি সংখ্যাটির প্রতিটি অংক আলাদা করছে, তারপর প্রতিটি দুই অংকের জোড়ার গুণফল হিসাব করছে এবং সেখান থেকে সর্বোচ্চ গুণফল রিটার্ন করছে।

প্রদত্ত উদাহরণগুলোতে এটি সঠিকভাবে কাজ করছে এবং প্রত্যাশিত আউটপুট দিচ্ছে।

তাই, কোড accepted হবে এবং কাজ করবে ঠিকঠাক।

Full Code:
-------------

  class Solution 
{
public:
    int maxProduct(int n)
    {
        if(n<10) return 0;
        vector<int>p;
        vector<int>d;
        while(n>0)
            {
                int digit=n%10;
                d.push_back(digit);
                n=n/10;
            }
        reverse(d.begin(),d.end());
        if(d.size()<2)return 0;
        for(int i=0;i<d.size();i++)
            {
                for(int j=i+1;j<d.size();j++)
                    
                {
                p.push_back(d[i]*d[j]);
                }
            }
    
        int maxv=p[0];
        for(int j=1;j<p.size();j++)
            {
                if(p[j]>maxv)
                {
                    maxv=p[j];
                }
            }
        return maxv;
    }
};
  
