üî∂ Problem Statement Summary (Bangla):
‡¶§‡ßã‡¶Æ‡¶æ‡¶ï‡ßá ‡¶¶‡ßÅ‡¶ü‡¶ø ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∞‡ßá ‡¶¶‡ßá‡¶ì‡ßü‡¶æ ‡¶Ü‡¶õ‡ßá nums1 ‡¶è‡¶¨‡¶Ç nums2, ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶§‡ßá ‡¶á‡¶â‡¶®‡¶ø‡¶ï ‡¶°‡¶ø‡¶ú‡¶ø‡¶ü (1-9 ‡¶è‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá) ‡¶Ü‡¶õ‡ßá‡•§ ‡¶§‡ßã‡¶Æ‡¶æ‡¶∞ ‡¶ï‡¶æ‡¶ú ‡¶π‡¶≤‡ßã ‡¶è‡¶Æ‡¶® ‡¶è‡¶ï‡¶ü‡¶ø ‡¶õ‡ßã‡¶ü‡¶§‡¶Æ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ ‡¶ï‡¶Æ‡¶™‡¶ï‡ßç‡¶∑‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶°‡¶ø‡¶ú‡¶ø‡¶ü nums1 ‡¶•‡ßá‡¶ï‡ßá ‡¶è‡¶¨‡¶Ç ‡¶è‡¶ï‡¶ü‡¶ø ‡¶°‡¶ø‡¶ú‡¶ø‡¶ü nums2 ‡¶•‡ßá‡¶ï‡ßá ‡¶∞‡¶æ‡¶ñ‡ßá‡•§

üî∑ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£:
cpp
Copy
Edit
nums1 = [4,1,3], nums2 = [5,7]
‚Üí ‡¶â‡¶§‡ßç‡¶§‡¶∞: 15 (1 nums1 ‡¶•‡ßá‡¶ï‡ßá, 5 nums2 ‡¶•‡ßá‡¶ï‡ßá)
nums1 = [3,5,2,6], nums2 = [3,1,7]
‚Üí ‡¶â‡¶§‡ßç‡¶§‡¶∞: 3 (‡¶â‡¶≠‡ßü ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶§‡ßá ‡¶Ü‡¶õ‡ßá)
üî∂ ‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá ‡¶ö‡¶ø‡¶®‡ßç‡¶§‡¶æ ‡¶ï‡¶∞‡¶¨‡ßá (Approach Thinking in Bangla):
‚úÖ Step 1:
‡¶¶‡ßÅ‡¶á ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶§‡ßá‡¶á ‡¶Ø‡¶¶‡¶ø ‡¶è‡¶ï‡¶á ‡¶°‡¶ø‡¶ú‡¶ø‡¶ü ‡¶•‡¶æ‡¶ï‡ßá (‡¶Ø‡ßá‡¶Æ‡¶® 3), ‡¶§‡¶æ‡¶π‡¶≤‡ßá ‡¶∏‡ßá‡¶ü‡¶æ ‡¶∏‡¶∞‡¶æ‡¶∏‡¶∞‡¶ø ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶ï‡¶æ‡¶∞‡¶£ ‡¶è‡¶ü‡¶æ ‡¶¶‡ßÅ‡¶á ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶∞‡¶á digit‡•§

‚úÖ Step 2:
‡¶®‡¶æ ‡¶•‡¶æ‡¶ï‡¶≤‡ßá, ‡¶§‡¶ñ‡¶® ‡¶§‡ßã‡¶Æ‡¶æ‡¶ï‡ßá nums1 ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶¨‡¶ö‡ßá‡ßü‡ßá ‡¶õ‡ßã‡¶ü digit ‡¶è‡¶¨‡¶Ç nums2 ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶¨‡¶ö‡ßá‡ßü‡ßá ‡¶õ‡ßã‡¶ü digit ‡¶®‡¶ø‡ßü‡ßá ‡¶¶‡ßÅ‡¶á‡¶ü‡¶æ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶∞ ‡¶ï‡¶Æ‡ßç‡¶¨‡¶ø‡¶®‡ßá‡¶∂‡¶® ‡¶¨‡¶æ‡¶®‡¶æ‡¶§‡ßá ‡¶π‡¶¨‡ßá ‚Äî a*10 + b ‡¶è‡¶¨‡¶Ç b*10 + a‡•§ ‡¶è‡¶¶‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶Ø‡ßá‡¶ü‡¶æ ‡¶õ‡ßã‡¶ü ‡¶∏‡ßá‡¶ü‡¶æ ‡¶π‡¶¨‡ßá ‡¶â‡¶§‡ßç‡¶§‡¶∞‡•§

üî∑ Full Code with Step-by-Step Bangla Explanation:
cpp
Copy
Edit
class Solution 
{
public:
    // ‡¶è‡¶á ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®‡¶ü‡¶ø ‡¶è‡¶ï‡¶ü‡¶ø ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∞‡ßá ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶¨‡¶ö‡ßá‡ßü‡ßá ‡¶õ‡ßã‡¶ü ‡¶°‡¶ø‡¶ú‡¶ø‡¶ü ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡ßá
    int findMin(const vector<int>& arr) 
    {
        int mini = arr[0]; // ‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶®‡¶ï‡ßá ‡¶õ‡ßã‡¶ü ‡¶ß‡¶∞‡ßá ‡¶®‡¶ø‡¶ö‡ßç‡¶õ‡¶ø

        for (int i = 1; i < arr.size(); i++) 
        {
            if (arr[i] < mini) {
                mini = arr[i]; // ‡¶Ø‡¶¶‡¶ø ‡¶§‡¶æ‡¶∞ ‡¶ö‡ßá‡ßü‡ßá ‡¶õ‡ßã‡¶ü ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶™‡¶æ‡¶á, ‡¶∏‡ßá‡¶ü‡¶æ‡¶á ‡¶∞‡¶æ‡¶ñ‡¶ø
            }
        }

        return mini; // ‡¶∏‡¶¨‡¶ö‡ßá‡ßü‡ßá ‡¶õ‡ßã‡¶ü ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶® ‡¶´‡ßá‡¶∞‡¶§ ‡¶¶‡¶æ‡¶ì
    }

    int minNumber(vector<int>& nums1, vector<int>& nums2) 
    {
        unordered_set<int> set1;       // nums1-‡¶è‡¶∞ ‡¶∏‡¶¨ ‡¶°‡¶ø‡¶ú‡¶ø‡¶ü ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶∞‡¶æ‡¶ñ‡¶¨
        vector<int> commonDigits;      // ‡¶¶‡ßÅ‡¶á ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶§‡ßá ‡¶Æ‡¶ø‡¶≤ ‡¶Ü‡¶õ‡ßá ‡¶è‡¶Æ‡¶® ‡¶°‡¶ø‡¶ú‡¶ø‡¶ü
        int ans;

        // Step 1: nums1-‡¶è‡¶∞ ‡¶∏‡¶¨ ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶® set-‡¶è ‡¶∞‡¶æ‡¶ñ‡¶ø ‡¶Ø‡¶æ‡¶§‡ßá ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü
        for (int j = 0; j < nums1.size(); j++)
        {
            set1.insert(nums1[j]);
        }

        // Step 2: nums2-‡¶è‡¶∞ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶® ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡¶ø nums1-‡¶è ‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø‡¶®‡¶æ
        for (int k = 0; k < nums2.size(); k++)
        {
            if (set1.find(nums2[k]) != set1.end())
            {
                // ‡¶¶‡ßÅ‡¶á ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶§‡ßá ‡¶•‡¶æ‡¶ï‡¶æ ‡¶°‡¶ø‡¶ú‡¶ø‡¶ü commonDigits-‡¶è ‡¶∞‡¶æ‡¶ñ‡¶ø
                commonDigits.push_back(nums2[k]);
            }
        }

        // Step 3: ‡¶Ø‡¶¶‡¶ø commonDigits ‡¶´‡¶æ‡¶Å‡¶ï‡¶æ ‡¶®‡¶æ ‡¶π‡ßü, ‡¶§‡¶æ‡¶π‡¶≤‡ßá ‡¶§‡¶æ‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶∏‡¶¨‡¶ö‡ßá‡ßü‡ßá ‡¶õ‡ßã‡¶ü‡¶ü‡¶æ‡¶á ‡¶â‡¶§‡ßç‡¶§‡¶∞
        if (!commonDigits.empty())
        {
            ans = findMin(commonDigits);
        }
        else
        {
            // Otherwise, nums1 ‡¶ì nums2 ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶¨‡¶ö‡ßá‡ßü‡ßá ‡¶õ‡ßã‡¶ü ‡¶¶‡ßÅ‡¶ü‡¶ø ‡¶°‡¶ø‡¶ú‡¶ø‡¶ü ‡¶®‡¶ø‡¶á
            int a = findMin(nums1);
            int b = findMin(nums2);

            // ‡¶¶‡ßÅ‡¶á‡¶≠‡¶æ‡¶¨‡ßá ‡¶ï‡¶Æ‡ßç‡¶¨‡¶ø‡¶®‡ßá‡¶∂‡¶® ‡¶¨‡¶æ‡¶®‡¶ø‡ßü‡ßá ‡¶õ‡ßã‡¶ü‡¶ü‡¶æ ‡¶∞‡¶æ‡¶ñ‡¶ø
            if (a < b)
            {
                ans = a * 10 + b;
            }
            else
            {
                ans = b * 10 + a;
            }
        }

        return ans;
    }
};
üî∂ ‡¶ï‡ßá‡¶® ‡¶è‡¶á Solution Accepted ‡¶π‡ßü:
‚úÖ Time Complexity: O(n + m), ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá n = nums1.size() ‡¶è‡¶¨‡¶Ç m = nums2.size()‡•§

‚úÖ Space Complexity: O(n) ‚Äî ‡¶ï‡¶æ‡¶∞‡¶£ ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶è‡¶ï‡¶ü‡¶æ set ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá‡¶õ‡¶ø‡•§

‚úÖ Efficient ‡¶ï‡¶æ‡¶∞‡¶£ ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶¶‡ßÅ‡¶á ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶§‡ßá ‡¶è‡¶ï‡¶¨‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá traversal ‡¶ï‡¶∞‡ßá‡¶õ‡¶ø‡•§

‚úÖ Constraints ‡¶õ‡ßã‡¶ü (‚â§9) ‡¶§‡¶æ‡¶á brute-force ‡¶¨‡¶æ sort ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞ ‡¶π‡ßü‡¶®‡¶ø‡•§

‚úÖ ‡¶∏‡¶†‡¶ø‡¶ï‡¶≠‡¶æ‡¶¨‡ßá common digit ‡¶•‡¶æ‡¶ï‡¶≤‡ßá ‡¶∏‡ßá‡¶ü‡¶æ‡¶á return ‡¶ï‡¶∞‡¶õ‡¶ø ‚Äî ‡¶Ü‡¶∞ ‡¶®‡¶æ ‡¶•‡¶æ‡¶ï‡¶≤‡ßá combination ‡¶ï‡¶∞‡ßá smallest ‡¶¨‡¶æ‡¶®‡¶æ‡¶ö‡ßç‡¶õ‡¶ø‡•§

‚úÖ Extra Test Cases:
cpp
Copy
Edit
nums1 = [2, 5, 8], nums2 = [1, 3]
‚Üí common ‡¶®‡ßá‡¶á ‚Üí ‡¶Æ‡¶ø‡¶®(2,1) = 1, 2 ‚Üí 12 or 21 ‚Üí 12 ‚úÖ

nums1 = [9], nums2 = [9]
‚Üí common = 9 ‚Üí ‚úÖ

nums1 = [1,2,3,4,5,6,7,8,9], nums2 = [9]
‚Üí common = 9 ‚Üí ‚úÖ
üîö ‡¶â‡¶™‡¶∏‡¶Ç‡¶π‡¶æ‡¶∞ (Conclusion in Bangla):
‡¶è‡¶á ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®‡ßá ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶¶‡ßÅ‡¶á‡¶ü‡¶æ ‡¶ï‡ßå‡¶∂‡¶≤ ‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá‡¶õ‡¶ø:

‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá common digit ‡¶ñ‡ßÅ‡¶Å‡¶ú‡¶ø‡•§

‡¶Ø‡¶¶‡¶ø ‡¶®‡¶æ ‡¶™‡¶æ‡¶á, ‡¶§‡¶æ‡¶π‡¶≤‡ßá ‡¶¶‡ßÅ‡¶á‡¶ü‡¶æ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∞‡ßá ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶¨‡¶ö‡ßá‡ßü‡ßá ‡¶õ‡ßã‡¶ü digit ‡¶®‡¶ø‡ßü‡ßá ‡¶∏‡¶¨‡¶•‡ßá‡¶ï‡ßá ‡¶õ‡ßã‡¶ü ‡¶¶‡ßÅ‡¶á digit-‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶¨‡¶æ‡¶®‡¶æ‡¶á‡•§


  Full Code:
----------------

  class Solution 
{
public:
 int findMin(const vector<int>& arr) 
 {
    int mini = arr[0]; // Assume first element is minimum

    for (int i = 1; i < arr.size(); i++) 
    {
        if (arr[i] < mini) {
            mini = arr[i]; // Update if a smaller value is found
        }
    }

    return mini;
}
    int minNumber(vector<int>& nums1, vector<int>& nums2) 
    {
        unordered_set<int>set1;
        vector<int>reserve;
        vector<int>v;
        int ans;
       
        for(int j=0;j<nums1.size();j++)
        {
          set1.insert(nums1[j]);
        }
        for(int k=0;k<nums2.size();k++)
        {
            if(set1.find(nums2[k])!=set1.end())
            {
                reserve.push_back(nums2[k]);
            }
            
          
        }
        if(!reserve.empty())
        {

        
      ans=findMin(reserve);
        }
        else{
        int a;
        int b;
        a=findMin(nums1);
         b=findMin(nums2);
      if(a<b)
      {
        ans=a*10+b;
      }
      else if(a>b)
      {
        ans=b*10+a;
      }
        }
      return ans;
    }
};
