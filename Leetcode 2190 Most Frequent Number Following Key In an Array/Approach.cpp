ЁЯФ╢ ржкрзНрж░рж╢рзНржиржЯрж╛ ржХрзА ржмрж▓ржЫрзЗ?
рждрзЛржорж╛ржХрзЗ ржПржХржЯрж╛ nums ржирж╛ржорзЗрж░ ржкрзВрж░рзНржгрж╕ржВржЦрзНржпрж╛рж░ ржЕрзНржпрж╛рж░рзЗ ржжрзЗржУрзЯрж╛ рж╣рзЯрзЗржЫрзЗ ржПржмржВ ржПржХржЯрж┐ key ржжрзЗржУрзЯрж╛ рж╣рзЯрзЗржЫрзЗ ржпрж╛ ржПржЗ nums ржПрж░ ржоржзрзНржпрзЗржЗ ржЖржЫрзЗред
рждрзБржорж┐ ржПржоржи ржкрзНрж░рждрж┐ржЯрж┐ target ржЦрзБржБржЬржмрзЗ ржпрзЗржЯрж╛ key-ржПрж░ ржарж┐ржХ ржкрж░рзЗ ржЖржЫрзЗ тАФ ржЕрж░рзНржерж╛рзО, ржПржоржи i ржЗржиржбрзЗржХрзНрж╕ ржпрзЗржЦрж╛ржирзЗ:

vbnet
Copy
Edit
nums[i] == key ржПржмржВ nums[i + 1] == target
рж╕ржм target-ржПрж░ ржоржзрзНржпрзЗ ржпрзЗржЯрж╛ рж╕ржмржЪрзЗрзЯрзЗ ржмрзЗрж╢рж┐ржмрж╛рж░ key ржПрж░ ржкрж░рзЗ ржЖрж╕рзЗ, рж╕рзЗржЯрж╛ржХрзЗржЗ рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рждрзЗ рж╣ржмрзЗред

тЬЕ рждрзЛржорж╛рж░ ржХрзЛржб ржмрзНржпрж╛ржЦрзНржпрж╛ ржзрж╛ржкрзЗ ржзрж╛ржкрзЗ:
cpp
Copy
Edit
vector<int>reserve1;
ЁЯСЙ reserve1 ржнрзЗржХрзНржЯрж░ржЯрж╛ ржмрж╛ржирж┐рзЯрзЗржЫрзЛ ржпрж╛рждрзЗ key ржПрж░ ржкрж░рзЗ ржпрзЗрж╕ржм рж╕ржВржЦрзНржпрж╛ржЧрзБрж▓рзЛ ржЖрж╕рзЗ, рж╕рзЗржЧрзБрж▓рзЛ рж╕ржВрж░ржХрзНрж╖ржг ржХрж░рж╛ ржпрж╛рзЯред

cpp
Copy
Edit
for(int i=0;i<nums.size()-1;i++)
{
  if(nums[i]==key)
  {
    reserve1.push_back(nums[i+1]);
  }
}
ЁЯСЙ ржПржЦрж╛ржирзЗ рж▓рзБржк ржЪрж╛рж▓рж┐рзЯрзЗ ржкрзНрж░рждрж┐ржмрж╛рж░ ржЪрзЗржХ ржХрж░ржЫрзЛ nums[i] == key ржХрж┐ржирж╛ред
ржпржжрж┐ рж╣рзЯ, рждрж╛рж╣рж▓рзЗ рждрж╛рж░ ржкрж░рзЗрж░ рж╕ржВржЦрзНржпрж╛ nums[i+1] ржХрзЗ reserve1-ржП рж░рж╛ржЦржЫрзЛред

ржЙржжрж╛рж╣рж░ржг:

ржпржжрж┐ nums = [1,100,200,1,100] ржПржмржВ key = 1 рж╣рзЯ

рждрж╛рж╣рж▓рзЗ reserve1 = [100, 100] рж╣ржмрзЗред

cpp
Copy
Edit
unordered_map<int,int>freq;
for(int j=0;j<reserve1.size();j++)
{
  freq[reserve1[j]]++;
}
ЁЯСЙ ржПржЦрж╛ржирзЗ reserve1-ржП ржерж╛ржХрж╛ рж╕ржВржЦрзНржпрж╛ржЧрзБрж▓рзЛрж░ ржлрзНрж░рж┐ржХрзЛрзЯрзЗржирзНрж╕рж┐ (ржХрждржмрж╛рж░ ржПрж╕рзЗржЫрзЗ) ржЧрзБржиржЫрзЛ freq ржирж╛ржорзЗрж░ hashmap/map ржжрж┐рзЯрзЗред

cpp
Copy
Edit
vector<int>reserve2;
int ans;
for(auto it:freq)
{
  reserve2.push_back(it.second);
}
ЁЯСЙ freq ржорзНржпрж╛ржк ржерзЗржХрзЗ ржкрзНрж░рждрж┐ржЯрж┐ рж╕ржВржЦрзНржпрж╛рж░ ржШржирждрзНржм/ржлрзНрж░рж┐ржХрзЛрзЯрзЗржирзНрж╕рж┐ reserve2 рждрзЗ рж░рж╛ржЦржЫрзЛред

cpp
Copy
Edit
int maxx = *std::max_element(reserve2.begin(), reserve2.end());
ЁЯСЙ reserve2 ржерзЗржХрзЗ рж╕рж░рзНржмрзЛржЪрзНржЪ ржлрзНрж░рж┐ржХрзЛрзЯрзЗржирзНрж╕рж┐ ржмрзЗрж░ ржХрж░ржЫрзЛ (ржорж╛ржирзЗ ржХрзЗ рж╕ржмржЪрзЗрзЯрзЗ ржмрзЗрж╢рж┐ржмрж╛рж░ ржПрж╕рзЗржЫрзЗ рждрж╛ ржмрзЗрж░ ржХрж░рж╛)ред

cpp
Copy
Edit
for(auto it:freq)
{
  if(it.second==maxx)
  {
    ans=it.first;  
  }
}
ЁЯСЙ freq ржорзНржпрж╛ржк ржерзЗржХрзЗ ржпрзЗржЗ рж╕ржВржЦрзНржпрж╛рж░ ржлрзНрж░рж┐ржХрзЛрзЯрзЗржирзНрж╕рж┐ maxx ржПрж░ рж╕ржорж╛ржи, рж╕рзЗржЯрж╛ржХрзЗржЗ ans рж╣рж┐рж╕рзЗржмрзЗ рж░рж╛ржЦржЫрзЛред
(ржпрзЗрж╣рзЗрждрзБ ржкрзНрж░рж╢рзНржи ржмрж▓рзЗржЫрзЗ: unique maximum ржерж╛ржХржмрзЗ, рждрж╛ржЗ ржПржХржЯрж┐ржЗ ржЙрждрзНрждрж░ рж╣ржмрзЗред)

cpp
Copy
Edit
return ans;
ЁЯСЙ рж╕ржмржЪрзЗрзЯрзЗ ржмрзЗрж╢рж┐ key-ржПрж░ ржкрж░рзЗ ржпрзЗржЗ рж╕ржВржЦрзНржпрж╛ ржЖрж╕рзЗ, рж╕рзЗржЯрж╛ рж░рж┐ржЯрж╛рж░рзНржи ржХрж░ржЫрзЛред

тЬЕ ржПржЦржи test cases ржжрж┐рзЯрзЗ ржмрзНржпрж╛ржЦрзНржпрж╛ ржХрж░рж┐:
Example 1:
cpp
Copy
Edit
nums = [1,100,200,1,100], key = 1
key = 1

key ржПрж░ ржкрж░рзЗ ржПрж╕рзЗржЫрзЗ: 100, 100 тЖТ freq = {100: 2}

тЖТ Ans = 100 тЬЕ

Example 2:
cpp
Copy
Edit
nums = [2,2,2,2,3], key = 2
key ржПрж░ ржкрж░рзЗ ржПрж╕рзЗржЫрзЗ: 2, 2, 2, 3 тЖТ freq = {2: 3, 3: 1}

тЖТ Ans = 2 тЬЕ

ЁЯза рждрзБржорж┐ ржХрзАржнрж╛ржмрзЗ ржЪрж┐ржирзНрждрж╛ ржХрж░рзЗржЫрзЛ:
ржкрзНрж░ржержорзЗ key ржПрж░ ржкрж░рзЗ ржЖрж╕рж╛ рж╕ржВржЦрзНржпрж╛ржЧрзБрж▓рзЛ ржЖрж▓рж╛ржжрж╛ ржХрж░рзЗ рж░рж╛ржЦржЫрзЛред

ржПрж░ржкрж░ рж╕рзЗржЗ рж╕ржВржЦрзНржпрж╛ржЧрзБрж▓рзЛрж░ ржоржзрзНржпрзЗ ржХрзЛржиржЯрж╛ ржмрзЗрж╢рж┐ ржПрж╕рзЗржЫрзЗ рждрж╛ ржмрзЗрж░ ржХрж░ржЫрзЛред

рж╕ржм рж╢рзЗрж╖рзЗ рж╕рж░рзНржмрзЛржЪрзНржЪ ржлрзНрж░рж┐ржХрзЛрзЯрзЗржирзНрж╕рж┐ржУрзЯрж╛рж▓рж╛ рж╕ржВржЦрзНржпрж╛ржЯрж╛ржЗ рж░рж┐ржЯрж╛рж░рзНржи ржХрж░ржЫрзЛред

ЁЯСЙ ржкрзБрж░рзЛржЯрж╛ ржзрж╛ржкрзЗ ржзрж╛ржкрзЗ ржнрзЗржмрзЗ ржХрж░рзЗржЫрзЛ ржПржмржВ STL-ржПрж░ ржнрж╛рж▓рзЛ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗржЫрзЛ (unordered_map, vector, max_element)ред ржПржЯрж╛ clean ржПржмржВ accepted solution!

ржЪржорзОржХрж╛рж░ ржХрж╛ржЬ! рждрзБржорж┐ ржЪрж╛ржЗрж▓рзЗ ржЖржорж┐ ржПржЗ рж╕ржорж╕рзНржпрж╛рж░ ржЬржирзНржп ржПржХржЯрж┐ flowchart ржмрж╛ ржЪрж┐рждрзНрж░ржУ ржмрж╛ржирж╛рждрзЗ ржкрж╛рж░рж┐ ржнржмрж┐рж╖рзНржпрждрзЗ рж░рж┐ржнрж┐рж╢ржирзЗрж░ ржЬржирзНржпред ржЪрж╛ржУ?


Full Code:
------------
  #include<iostream>
#include <unordered_map>
#include<algorithm>
using namespace std;
class Solution 
{
public:

    int mostFrequent(vector<int>& nums, int key)
     {
        vector<int>reserve1;
        for(int i=0;i<nums.size()-1;i++)
        {
          if(nums[i]==key)
          {
            reserve1.push_back(nums[i+1]);
          }
        }
        unordered_map<int,int>freq;
        for(int j=0;j<reserve1.size();j++)
        {
          freq[reserve1[j]]++;
        }
        vector<int>reserve2;
        int ans;
        for(auto it:freq)
        {
          reserve2.push_back(it.second);
        }
      //  int maxx=std::max(reserve2);
      int maxx = *std::max_element(reserve2.begin(), reserve2.end());
        for(auto it:freq)
        {
          if(it.second==maxx)
          {
            ans=it.first;  
                    }
        }
        return ans;
    }
};





